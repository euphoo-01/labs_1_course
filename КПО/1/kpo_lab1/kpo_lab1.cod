; Listing generated by Microsoft (R) Optimizing Compiler Version 19.41.34120.0 

	TITLE	D:\University\Labs_1_course\ œŒ\1\kpo_lab1\kpo_lab1.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
	ORG $+3
$SG36711 DB	'02012007', 00H
	ORG $+3
$SG37478 DB	'Russian', 00H
$SG37479 DB	0c2H, 0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H
	DB	0f2H, 0f3H, ' ', 0e2H, ' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e0H, 0f2H
	DB	0e5H, ' (', 0c4H, 0c4H, 0ccH, 0ccH, 0c3H, 0c3H, 0c3H, 0c3H, ')'
	DB	': ', 00H
$SG37482 DB	0ceH, 0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '! ', 0c2H, 0e2H, 0e5H
	DB	0e4H, 0e5H, 0edH, 0e0H, ' ', 0edH, 0e5H, 0efH, 0f0H, 0e0H, 0e2H
	DB	0e8H, 0ebH, 0fcH, 0edH, 0e0H, 0ffH, ' ', 0e4H, 0e0H, 0f2H, 0e0H
	DB	00H
	ORG $+2
$SG37488 DB	0ceH, 0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '! ', 0c2H, 0e2H, 0e5H
	DB	0e4H, 0e5H, 0edH, 0e0H, ' ', 0edH, 0e5H, 0efH, 0f0H, 0e0H, 0e2H
	DB	0e8H, 0ebH, 0fcH, 0edH, 0e0H, 0ffH, ' ', 0e4H, 0e0H, 0f2H, 0e0H
	DB	00H
	ORG $+2
$SG37492 DB	0ceH, 0f8H, 0e8H, 0e1H, 0eaH, 0e0H, '! ', 0c2H, 0e2H, 0e5H
	DB	0e4H, 0e5H, 0edH, 0e0H, ' ', 0edH, 0e5H, 0efH, 0f0H, 0e0H, 0e2H
	DB	0e8H, 0ebH, 0fcH, 0edH, 0e0H, 0ffH, ' ', 0e4H, 0e0H, 0f2H, 0e0H
	DB	00H
	ORG $+2
$SG37498 DB	09H, 00H
	ORG $+2
$SG37499 DB	09H, 00H
	ORG $+2
$SG37500 DB	0c2H, 0e2H, 0e5H, 0e4H, 0e5H, 0edH, 0edH, 0e0H, 0ffH, ' ', 0e4H
	DB	0e0H, 0f2H, 0e0H, ': ', 00H
	ORG $+3
$SG37501 DB	0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0fbH, 0e9H
	DB	00H
	ORG $+1
$SG37502 DB	0edH, 0e5H, ' ', 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H
	DB	0edH, 0fbH, 0e9H, 00H
	ORG $+2
$SG37503 DB	0c3H, 0eeH, 0e4H, ' - ', 00H
	ORG $+1
$SG37504 DB	0cfH, 0eeH, 0f0H, 0ffH, 0e4H, 0eaH, 0eeH, 0e2H, 0fbH, 0e9H
	DB	' ', 0edH, 0eeH, 0ecH, 0e5H, 0f0H, ' ', 0e4H, 0edH, 0ffH, ': ', 00H
	ORG $+1
$SG37505 DB	0ceH, 0f1H, 0f2H, 0e0H, 0ebH, 0eeH, 0f1H, 0fcH, ' ', 0e4H
	DB	0edH, 0e5H, 0e9H, ' ', 0e4H, 0eeH, ' ', 0ecH, 0eeH, 0e5H, 0e3H
	DB	0eeH, ' ', 0e4H, 0edH, 0ffH, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H
	DB	0edH, 0e8H, 0ffH, ': ', 00H
CONST	ENDS
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	?fpclassify@@YAHO@Z				; fpclassify
PUBLIC	_fabsl
PUBLIC	_frexpl
PUBLIC	___local_stdio_printf_options
PUBLIC	__vsprintf_s_l
PUBLIC	_sprintf_s
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??1_Iostream_error_category2@std@@UAE@XZ	; std::_Iostream_error_category2::~_Iostream_error_category2
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ	; std::_Locinfo::_Getcvt
PUBLIC	?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ	; std::_Locinfo::_Getlconv
PUBLIC	?_Getfalse@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Getfalse
PUBLIC	?_Gettrue@_Locinfo@std@@QBEPBDXZ		; std::_Locinfo::_Gettrue
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??0id@locale@std@@QAE@I@Z			; std::locale::id::id
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_C_str@locale@std@@QBEPBDXZ			; std::locale::_C_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?is@?$ctype@D@std@@QBE_NFD@Z			; std::ctype<char>::is
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z		; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?precision@ios_base@std@@QBE_JXZ		; std::ios_base::precision
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
PUBLIC	?detViscosity@@YA_NH@Z				; detViscosity
PUBLIC	?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; detSerialNumber
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
PUBLIC	?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z ; std::vector<int,std::allocator<int> >::insert
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
PUBLIC	??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
PUBLIC	?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z ; std::vector<int,std::allocator<int> >::_Make_iterator
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@PAH00@Z ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
PUBLIC	??0?$initializer_list@H@std@@QAE@PBH0@Z		; std::initializer_list<int>::initializer_list<int>
PUBLIC	?begin@?$initializer_list@H@std@@QBEPBHXZ	; std::initializer_list<int>::begin
PUBLIC	?end@?$initializer_list@H@std@@QBEPBHXZ		; std::initializer_list<int>::end
PUBLIC	?size@?$initializer_list@H@std@@QBEIXZ		; std::initializer_list<int>::size
PUBLIC	_main
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$all_of@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA_NV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0P6AHH@Z@Z ; std::all_of<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
PUBLIC	?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
PUBLIC	??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
PUBLIC	??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
PUBLIC	?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
PUBLIC	?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
PUBLIC	?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
PUBLIC	?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
PUBLIC	?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
PUBLIC	?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
PUBLIC	??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
PUBLIC	??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
PUBLIC	??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
PUBLIC	??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
PUBLIC	??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
PUBLIC	?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$move@AAH@std@@YA$$QAHAAH@Z			; std::move<int &>
PUBLIC	??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z ; std::vector<int,std::allocator<int> >::emplace<int>
PUBLIC	??$_Emplace_one_at_back@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int>
PUBLIC	??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::move<std::allocator<int> &>
PUBLIC	??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z	; std::exchange<int *,std::nullptr_t>
PUBLIC	??$?0V?$allocator@H@std@@PAHPAHPAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAPAH22@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z ; std::vector<int,std::allocator<int> >::_Construct_n<int const *,int const *>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
PUBLIC	??$_Refancy@PAD$0A@@std@@YAPADPAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Float_put_desired_precision@O@std@@YAH_JH@Z	; std::_Float_put_desired_precision<long double>
PUBLIC	??$isfinite@O@@YA_NO@Z				; isfinite<long double>
PUBLIC	??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
PUBLIC	??$_Float_put_desired_precision@N@std@@YAH_JH@Z	; std::_Float_put_desired_precision<double>
PUBLIC	??$isfinite@N@@YA_NN@Z				; isfinite<double>
PUBLIC	??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
PUBLIC	?decimal_point@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::decimal_point
PUBLIC	?thousands_sep@?$numpunct@D@std@@QBEDXZ		; std::numpunct<char>::thousands_sep
PUBLIC	?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
PUBLIC	?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
PUBLIC	?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
PUBLIC	??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z	; std::numpunct<char>::numpunct<char>
PUBLIC	?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
PUBLIC	??1?$numpunct@D@std@@MAE@XZ			; std::numpunct<char>::~numpunct<char>
PUBLIC	?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z	; std::numpunct<char>::_Init
PUBLIC	?do_decimal_point@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_decimal_point
PUBLIC	?do_thousands_sep@?$numpunct@D@std@@MBEDXZ	; std::numpunct<char>::do_thousands_sep
PUBLIC	?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_grouping
PUBLIC	?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_falsename
PUBLIC	?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::do_truename
PUBLIC	?_Tidy@?$numpunct@D@std@@AAEXXZ			; std::numpunct<char>::_Tidy
PUBLIC	??_G?$numpunct@D@std@@MAEPAXI@Z			; std::numpunct<char>::`scalar deleting destructor'
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
PUBLIC	?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
PUBLIC	?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
PUBLIC	?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
PUBLIC	?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
PUBLIC	?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$_Deallocate@$07@std@@YAXPAXI@Z		; std::_Deallocate<8>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
PUBLIC	??$forward@H@std@@YA$$QAHAAH@Z			; std::forward<int>
PUBLIC	??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
PUBLIC	?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value
PUBLIC	??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Alloc_temporary2<std::allocator<int> >::~_Alloc_temporary2<std::allocator<int> >
PUBLIC	??$?0H@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@AAV?$allocator@H@1@$$QAH@Z ; std::_Alloc_temporary2<std::allocator<int> >::_Alloc_temporary2<std::allocator<int> ><int>
PUBLIC	??$addressof@H@std@@YAPAHAAH@Z			; std::addressof<int>
PUBLIC	??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$_Move_backward_unchecked@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward_unchecked<int *,int *>
PUBLIC	??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$forward@PAH@std@@YA$$QAPAHAAPAH@Z		; std::forward<int *>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@PBH@std@@YA$$QAPBHAAPBH@Z		; std::forward<int const *>
PUBLIC	??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,int const *,std::allocator<int> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
PUBLIC	??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$_Unfancy_maybe_null@$$CBD@std@@YAPBDPBD@Z	; std::_Unfancy_maybe_null<char const >
PUBLIC	??$_Max_limit@H@std@@YAHXZ			; std::_Max_limit<int>
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<int> >
PUBLIC	??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z	; std::_Maklocchr<char>
PUBLIC	??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Construct_in_place@HH@std@@YAXAAH$$QAH@Z	; std::_Construct_in_place<int,int>
PUBLIC	??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
PUBLIC	??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
PUBLIC	??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z		; std::move<int const * &>
PUBLIC	??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z	; std::_Get_unwrapped<int const *>
PUBLIC	??$_To_address@PBH@std@@YA?A_PABQBH@Z		; std::_To_address<int const *>
PUBLIC	??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z	; std::_Copy_memmove<int const *,int *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_C@_05LAPONLG@false@				; `string'
PUBLIC	??_C@_04LOAJBDKD@true@				; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
PUBLIC	?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
PUBLIC	??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
PUBLIC	??_C@_02BBAHNLBA@?$CFp@				; `string'
PUBLIC	??_C@_02CLHGNPPK@Lu@				; `string'
PUBLIC	??_C@_02HIKPPMOK@Ld@				; `string'
PUBLIC	??_C@_02BDDLJJBK@lu@				; `string'
PUBLIC	??_C@_02EAOCLKAK@ld@				; `string'
PUBLIC	?id@?$numpunct@D@std@@2V0locale@2@A		; std::numpunct<char>::id
PUBLIC	??_7?$numpunct@D@std@@6B@			; std::numpunct<char>::`vftable'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
PUBLIC	??_C@_02MDKMJEGG@eE@				; `string'
PUBLIC	??_C@_02OOPEBDOJ@pP@				; `string'
PUBLIC	??_C@_01LFCBOECM@?4@				; `string'
PUBLIC	?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
PUBLIC	??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$numpunct@D@std@@6B@			; std::numpunct<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$numpunct@D@std@@@8			; std::numpunct<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$numpunct@D@std@@8			; std::numpunct<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$numpunct@D@std@@8		; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@4202a05f20000000
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	_atexit:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	__dtest:PROC
EXTRN	__ldtest:PROC
EXTRN	_abs:PROC
EXTRN	_fabs:PROC
EXTRN	_frexp:PROC
EXTRN	_calloc:PROC
EXTRN	_free:PROC
EXTRN	__errno:PROC
EXTRN	_strtol:PROC
EXTRN	___stdio_common_vsprintf_s:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_strcspn:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xinvalid_argument@std@@YAXPBD@Z:PROC		; std::_Xinvalid_argument
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	_isdigit:PROC
EXTRN	_setlocale:PROC
EXTRN	_localeconv:PROC
EXTRN	__Getctype:PROC
EXTRN	__Getcvt:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z:PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vector deleting destructor'
EXTRN	??_E?$numpunct@D@std@@MAEPAXI@Z:PROC		; std::numpunct<char>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cin
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
_BSS	SEGMENT
?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B DB 018H DUP (?) ; BDAY_DATE
?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A DB 0cH DUP (?) ; days_in_months
_BSS	ENDS
;	COMDAT ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A DD 01H DUP (?) ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
_BSS	ENDS
;	COMDAT ?id@?$numpunct@D@std@@2V0locale@2@A
_BSS	SEGMENT
?id@?$numpunct@D@std@@2V0locale@2@A DD 01H DUP (?)	; std::numpunct<char>::id
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::numpunct<char> >::_Psave
_BSS	ENDS
CRT$XCU	SEGMENT
?BDAY_DATE$initializer$@@3P6AXXZA DD FLAT:??__EBDAY_DATE@@YAXXZ ; BDAY_DATE$initializer$
CRT$XCU	ENDS
;	COMDAT __real@4202a05f20000000
CONST	SEGMENT
__real@4202a05f20000000 DQ 04202a05f20000000r	; 1e+10
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$numpunct@D@std@@8 DD FLAT:??_R0?AV?$numpunct@D@std@@@8 ; std::numpunct<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R2?$numpunct@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$numpunct@D@std@@8 ; std::numpunct<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$numpunct@D@std@@8
rdata$r	SEGMENT
??_R3?$numpunct@D@std@@8 DD 00H				; std::numpunct<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$numpunct@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$numpunct@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::numpunct<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$numpunct@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$numpunct@D@std@@6B@
rdata$r	SEGMENT
??_R4?$numpunct@D@std@@6B@ DD 00H			; std::numpunct<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$numpunct@D@std@@@8
	DD	FLAT:??_R3?$numpunct@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	SEGMENT
??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8 DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@'
	DB	'std@@@std@@@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD 00H ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@8
	DD	FLAT:??_R3?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4@
CONST	SEGMENT
??_C@_01LFCBOECM@?4@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OOPEBDOJ@pP@
CONST	SEGMENT
??_C@_02OOPEBDOJ@pP@ DB 'pP', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MDKMJEGG@eE@
CONST	SEGMENT
??_C@_02MDKMJEGG@eE@ DB 'eE', 00H			; `string'
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_7?$numpunct@D@std@@6B@
CONST	SEGMENT
??_7?$numpunct@D@std@@6B@ DD FLAT:??_R4?$numpunct@D@std@@6B@ ; std::numpunct<char>::`vftable'
	DD	FLAT:??_E?$numpunct@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_decimal_point@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
	DD	FLAT:?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	DD	FLAT:?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
CONST	ENDS
;	COMDAT ??_C@_02EAOCLKAK@ld@
CONST	SEGMENT
??_C@_02EAOCLKAK@ld@ DB 'ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BDDLJJBK@lu@
CONST	SEGMENT
??_C@_02BDDLJJBK@lu@ DB 'lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIKPPMOK@Ld@
CONST	SEGMENT
??_C@_02HIKPPMOK@Ld@ DB 'Ld', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLHGNPPK@Lu@
CONST	SEGMENT
??_C@_02CLHGNPPK@Lu@ DB 'Lu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02BBAHNLBA@?$CFp@
CONST	SEGMENT
??_C@_02BBAHNLBA@?$CFp@ DB '%p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
CONST	SEGMENT
??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ DD FLAT:??_R4?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`vftable'
	DD	FLAT:??_E?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
	DD	FLAT:?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true@
CONST	SEGMENT
??_C@_04LOAJBDKD@true@ DB 'true', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false@
CONST	SEGMENT
??_C@_05LAPONLG@false@ DB 'false', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z$0
__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z$2
__ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01bH
	DW	015cH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0
__ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0
__ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	034H
	DB	041H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	04e6H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$3
__ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z$0
__ehfuncinfo$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z$0
__ehfuncinfo$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	031H
	DB	03eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	0412H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3
__ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	053H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01bH
	DW	0219H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01bH
	DW	0219H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	071H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	071H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	06dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	06dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	02eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	0231H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1
__ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$4
__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0
__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$3
__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$3
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$3
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0
__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$4
__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	01H
	DD	FLAT:__tryblocktable$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0
__ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	095H
voltbl	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$_main$0
	DD	016H
	DD	023H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	01eH
	DD	0680H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	039H
	DD	046H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	01eH
	DD	0170H
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
__ehfuncinfo$_main DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1
__ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	036H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1
__ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0
__ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	03fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Locinfo@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	058H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$??0_Locinfo@std@@QAE@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0_Locinfo@std@@QAE@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	079H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0
__ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0system_error@std@@QAE@Verror_code@1@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0a2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1
__ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01bH
	DB	0b7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1
__ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?days_in_months$initializer$@@3P6AXXZA DD FLAT:??__Edays_in_months@@YAXXZ ; days_in_months$initializer$
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA DD FLAT:??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; ??id$initializer$@?$numpunct@D@std@@2P6AXXZA@@3P6AXXZA
CRT$XCU	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00004	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 84   :         if (_Count > _Max_possible) {
; 85   :             _Throw_bad_array_new_length(); // multiply overflow
; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 90   : }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 151  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 152  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 153  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 154  :     if (_Block_size <= _Bytes) {

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  00015	77 06		 ja	 SHORT $LN8@Allocate_m

; 155  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0001c	90		 npad	 1
$LN8@Allocate_m:

; 156  :     }
; 157  : 
; 158  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001d	8b 55 f8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00020	52		 push	 edx
  00021	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00026	83 c4 04	 add	 esp, 4
  00029	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 159  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002c	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00030	74 02		 je	 SHORT $LN9@Allocate_m
  00032	eb 0a		 jmp	 SHORT $LN6@Allocate_m
$LN9@Allocate_m:
  00034	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00039	90		 npad	 1
  0003a	33 c0		 xor	 eax, eax
  0003c	75 f6		 jne	 SHORT $LN9@Allocate_m
$LN6@Allocate_m:
  0003e	33 c9		 xor	 ecx, ecx
  00040	75 ea		 jne	 SHORT $LN4@Allocate_m

; 160  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00042	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00045	83 c2 23	 add	 edx, 35			; 00000023H
  00048	83 e2 e0	 and	 edx, -32		; ffffffe0H
  0004b	89 55 f4	 mov	 DWORD PTR __Ptr$[ebp], edx

; 161  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004e	b8 04 00 00 00	 mov	 eax, 4
  00053	6b c8 ff	 imul	 ecx, eax, -1
  00056	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00059	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005c	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 162  : 
; 163  : #ifdef _DEBUG
; 164  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 165  : #endif // defined(_DEBUG)
; 166  :     return _Ptr;

  0005f	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 167  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00007	50		 push	 eax
  00008	6a 04		 push	 4
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0000f	83 c4 08	 add	 esp, 8
  00012	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 02		 mov	 DWORD PTR [edx], eax

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEX$$QAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>, COMDAT
; _this$ = ecx

; 1778 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1779 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1780 :         ++_Last;

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	83 c0 04	 add	 eax, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1781 :     }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEX$$QAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4630 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 4631 :     auto _FirstPtr              = _STD _To_address(_First);

  00006	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4632 :     auto _LastPtr               = _STD _To_address(_Last);

  00015	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4633 :     auto _DestPtr               = _STD _To_address(_Dest);

  00024	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4634 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00033	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4635 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00039	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  0003c	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4636 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  0003f	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00042	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4637 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00045	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00048	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0004b	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4638 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00055	52		 push	 edx
  00056	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _memmove
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4639 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4640 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00062	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00065	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4641 :     } else {
; 4642 :         return _Dest + (_LastPtr - _FirstPtr);
; 4643 :     }
; 4644 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT

; 1319 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1320 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1321 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1322 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1323 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1324 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1325 :     } else {
; 1326 :         return static_cast<_Iter&&>(_It);
; 1327 :     }
; 1328 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4509 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4510 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4511 :     return _Val;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 4512 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits>, COMDAT

; 194  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 195  :     // allocate _Bytes
; 196  :     if (_Bytes == 0) {

  00003	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00007	75 04		 jne	 SHORT $LN2@Allocate

; 197  :         return nullptr;

  00009	33 c0		 xor	 eax, eax
  0000b	eb 23		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 198  :     }
; 199  : 
; 200  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 201  :     if (_STD is_constant_evaluated()) {
; 202  :         return _Traits::_Allocate(_Bytes);
; 203  :     }
; 204  : #endif // _HAS_CXX20
; 205  : 
; 206  : #ifdef __cpp_aligned_new
; 207  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 208  :         size_t _Passed_align = _Align;
; 209  : #if defined(_M_IX86) || defined(_M_X64)
; 210  :         if (_Bytes >= _Big_allocation_threshold) {
; 211  :             // boost the alignment of big allocations to help autovectorization
; 212  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 213  :         }
; 214  : #endif // defined(_M_IX86) || defined(_M_X64)
; 215  :         return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
; 216  :     } else
; 217  : #endif // defined(__cpp_aligned_new)
; 218  :     {
; 219  : #if defined(_M_IX86) || defined(_M_X64)
; 220  :         if (_Bytes >= _Big_allocation_threshold) {

  0000d	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00014	72 0e		 jb	 SHORT $LN3@Allocate

; 221  :             // boost the alignment of big allocations to help autovectorization
; 222  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00016	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0001f	83 c4 04	 add	 esp, 4
  00022	eb 0c		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 223  :         }
; 224  : #endif // defined(_M_IX86) || defined(_M_X64)
; 225  :         return _Traits::_Allocate(_Bytes);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002d	83 c4 04	 add	 esp, 4
$LN1@Allocate:

; 226  :     }
; 227  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 79   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 80   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 81   : 
; 82   :     if constexpr (_Overflow_is_possible) {
; 83   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 84   :         if (_Count > _Max_possible) {

  00011	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00018	76 06		 jbe	 SHORT $LN2@Get_size_o

; 85   :             _Throw_bad_array_new_length(); // multiply overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0001f	90		 npad	 1
$LN2@Get_size_o:

; 86   :         }
; 87   :     }
; 88   : 
; 89   :     return _Count * _Ty_size;

  00020	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00023	c1 e0 02	 shl	 eax, 2
$LN1@Get_size_o:

; 90   : }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2173 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2174 : #if _HAS_CXX23
; 2175 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2176 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2177 :         _Count                  = _Allocated;
; 2178 :         return _Ptr;
; 2179 :     } else
; 2180 : #endif // _HAS_CXX23
; 2181 :     {
; 2182 :         return _Al.allocate(_Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2183 :     }
; 2184 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1778 :     _CONSTEXPR20 void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1779 :         allocator_traits<_Alloc>::construct(_Al, _STD _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00007	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  00020	83 c4 04	 add	 esp, 4
  00023	50		 push	 eax
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1780 :         ++_Last;

  00033	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00036	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00039	83 c0 04	 add	 eax, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1781 :     }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT
; _this$ = ecx

; 1783 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1784 :         _First = _Last;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00010	89 10		 mov	 DWORD PTR [eax], edx

; 1785 :         return _Last;

  00012	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00015	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1786 :     }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1773 :     _CONSTEXPR20 ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1774 :         _STD _Destroy_range(_First, _Last, _Al);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00011	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1775 :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1768 :     _CONSTEXPR20 _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4630 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 4631 :     auto _FirstPtr              = _STD _To_address(_First);

  00006	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4632 :     auto _LastPtr               = _STD _To_address(_Last);

  00015	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4633 :     auto _DestPtr               = _STD _To_address(_Dest);

  00024	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4634 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00033	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4635 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00039	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  0003c	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4636 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  0003f	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00042	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4637 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00045	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00048	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0004b	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4638 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  0004e	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00055	52		 push	 edx
  00056	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 _memmove
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4639 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4640 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00062	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00065	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4641 :     } else {
; 4642 :         return _Dest + (_LastPtr - _FirstPtr);
; 4643 :     }
; 4644 : }

  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_To_address@PBH@std@@YA?A_PABQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBH@std@@YA?A_PABQBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4509 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4510 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4511 :     return _Val;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 4512 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_To_address@PBH@std@@YA?A_PABQBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z PROC		; std::_Get_unwrapped<int const *>, COMDAT

; 1319 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1320 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1321 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1322 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1323 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1324 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1325 :     } else {
; 1326 :         return static_cast<_Iter&&>(_It);
; 1327 :     }
; 1328 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z ENDP		; std::_Get_unwrapped<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z PROC		; std::move<int const * &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1548 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z ENDP		; std::move<int const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Backout$ = -36					; size = 12
$T2 = -24						; size = 4
__ULast$ = -20						; size = 4
__UFirst$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_move<int *,std::allocator<int> >, COMDAT

; 1904 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1905 :     // move [_First, _Last) to raw _Dest, using _Al
; 1906 :     // note: only called internally from elsewhere in the STL
; 1907 :     using _Ptrval     = typename _Alloc::value_type*;
; 1908 :     auto _UFirst      = _Get_unwrapped(_First);

  00025	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1909 :     const auto _ULast = _Get_unwrapped(_Last);

  00034	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0003d	83 c4 04	 add	 esp, 4
  00040	89 45 ec	 mov	 DWORD PTR __ULast$[ebp], eax

; 1910 :     if constexpr (conjunction_v<bool_constant<_Iter_move_cat<decltype(_UFirst), _Ptrval>::_Bitcopy_constructible>,
; 1911 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1912 : #if _HAS_CXX20
; 1913 :         if (!_STD is_constant_evaluated())
; 1914 : #endif // _HAS_CXX20
; 1915 :         {
; 1916 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  00043	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0004c	83 c4 04	 add	 esp, 4
  0004f	50		 push	 eax
  00050	8b 45 ec	 mov	 eax, DWORD PTR __ULast$[ebp]
  00053	50		 push	 eax
  00054	8b 4d f0	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1917 :             return _Dest + (_ULast - _UFirst);

  00060	8b 55 ec	 mov	 edx, DWORD PTR __ULast$[ebp]
  00063	2b 55 f0	 sub	 edx, DWORD PTR __UFirst$[ebp]
  00066	c1 fa 02	 sar	 edx, 2
  00069	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0006c	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0006f	eb 5f		 jmp	 SHORT $LN1@Uninitiali

; 1918 :         }
; 1919 :     }
; 1920 : 
; 1921 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00071	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00078	52		 push	 edx
  00079	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0007c	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  00081	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1922 :     for (; _UFirst != _ULast; ++_UFirst) {

  00088	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  0008a	8b 45 f0	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0008d	83 c0 04	 add	 eax, 4
  00090	89 45 f0	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  00093	8b 4d f0	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00096	3b 4d ec	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00099	74 18		 je	 SHORT $LN3@Uninitiali

; 1923 :         _Backout._Emplace_back(_STD move(*_UFirst));

  0009b	8b 55 f0	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  000a4	83 c4 04	 add	 esp, 4
  000a7	50		 push	 eax
  000a8	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000ab	e8 00 00 00 00	 call	 ??$_Emplace_back@H@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int>
  000b0	90		 npad	 1

; 1924 :     }

  000b1	eb d7		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1925 : 
; 1926 :     return _Backout._Release();

  000b3	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b6	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  000bb	89 45 e8	 mov	 DWORD PTR $T2[ebp], eax
  000be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c5	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c8	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  000cd	8b 45 e8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1927 : }

  000d0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000da	59		 pop	 ecx
  000db	8b e5		 mov	 esp, ebp
  000dd	5d		 pop	 ebp
  000de	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_move<int *,std::allocator<int> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Result$ = -32						; size = 4
__Dest_ch$ = -28					; size = 4
__Last_ch$ = -24					; size = 4
__DestPtr$ = -20					; size = 4
__LastPtr$ = -16					; size = 4
__FirstPtr$ = -12					; size = 4
__Count$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC	; std::_Copy_backward_memmove<int *,int *>, COMDAT

; 4954 : _CtgIt2 _Copy_backward_memmove(_CtgIt1 _First, _CtgIt1 _Last, _CtgIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H

; 4955 :     // implement copy_backward-like function as memmove
; 4956 :     auto _FirstPtr              = _STD _To_address(_First);

  00006	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 f4	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4957 :     auto _LastPtr               = _STD _To_address(_Last);

  00015	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 f0	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4958 :     auto _DestPtr               = _STD _To_address(_Dest);

  00024	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00027	52		 push	 edx
  00028	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 ec	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4959 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00033	8b 45 f4	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00036	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4960 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00039	8b 4d f0	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  0003c	89 4d e8	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4961 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  0003f	8b 55 ec	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00042	89 55 e4	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4962 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00045	8b 45 e8	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00048	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0004b	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 4963 :     auto _Result                = _CSTD memmove(_Dest_ch - _Count, _First_ch, _Count);

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	51		 push	 ecx
  00052	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00055	52		 push	 edx
  00056	8b 45 e4	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00059	2b 45 f8	 sub	 eax, DWORD PTR __Count$[ebp]
  0005c	50		 push	 eax
  0005d	e8 00 00 00 00	 call	 _memmove
  00062	83 c4 0c	 add	 esp, 12			; 0000000cH
  00065	89 45 e0	 mov	 DWORD PTR __Result$[ebp], eax

; 4964 :     if constexpr (is_pointer_v<_CtgIt2>) {
; 4965 :         return static_cast<_CtgIt2>(_Result);

  00068	8b 45 e0	 mov	 eax, DWORD PTR __Result$[ebp]

; 4966 :     } else {
; 4967 :         return _Dest - (_LastPtr - _FirstPtr);
; 4968 :     }
; 4969 : }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP	; std::_Copy_backward_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Construct_in_place@HH@std@@YAXAAH$$QAH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@HH@std@@YAXAAH$$QAH@Z PROC	; std::_Construct_in_place<int,int>, COMDAT

; 396  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 397  : #if _HAS_CXX20
; 398  :     if (_STD is_constant_evaluated()) {
; 399  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 400  :     } else
; 401  : #endif // _HAS_CXX20
; 402  :     {
; 403  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 404  :     }
; 405  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@HH@std@@YAXAAH$$QAH@Z ENDP	; std::_Construct_in_place<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ PROC	; `dynamic initializer for 'std::numpunct<char>::id'', COMDAT

; 242  : __PURE_APPDOMAIN_GLOBAL locale::id numpunct<_Elem>::id;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 00		 push	 0
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
  0000a	e8 00 00 00 00	 call	 ??0id@locale@std@@QAE@I@Z ; std::locale::id::id
  0000f	90		 npad	 1
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ENDP	; `dynamic initializer for 'std::numpunct<char>::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ
text$di	SEGMENT
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ PROC ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id'', COMDAT

; 1652 : __PURE_APPDOMAIN_GLOBAL locale::id num_put<_Elem, _OutIt>::id;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a 00		 push	 0
  00005	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  0000a	e8 00 00 00 00	 call	 ??0id@locale@std@@QAE@I@Z ; std::locale::id::id
  0000f	90		 npad	 1
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??__E?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ENDP ; `dynamic initializer for 'std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id''
text$di	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Ptr$ = 12						; size = 4
__Cvt$ = 16						; size = 44
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z PROC ; std::numpunct<char>::_Getvals<char>, COMDAT
; _this$ = ecx

; 153  :     void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt) { // get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 154  :         _Dp         = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);

  00007	8d 45 10	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	b9 01 00 00 00	 mov	 ecx, 1
  00012	6b d1 00	 imul	 edx, ecx, 0
  00015	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	0f b6 14 11	 movzx	 edx, BYTE PTR [ecx+edx]
  0001e	52		 push	 edx
  0001f	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 155  :         _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);

  0002d	8d 55 10	 lea	 edx, DWORD PTR __Cvt$[ebp]
  00030	52		 push	 edx
  00031	6a 00		 push	 0
  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	6b c8 00	 imul	 ecx, eax, 0
  0003b	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0003e	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00041	0f b6 0c 08	 movzx	 ecx, BYTE PTR [eax+ecx]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00051	88 42 0d	 mov	 BYTE PTR [edx+13], al

; 156  :     }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c2 34 00	 ret	 52			; 00000034H
??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ENDP ; std::numpunct<char>::_Getvals<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Byte$ = 8						; size = 1
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z PROC		; std::_Maklocchr<char>, COMDAT

; 485  : _Elem __CRTDECL _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 486  :     // convert char to _Elem using _Cvtvec
; 487  :     return static_cast<_Elem>(static_cast<unsigned char>(_Byte));

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]

; 488  : }

  00007	5d		 pop	 ebp
  00008	c3		 ret	 0
??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ENDP		; std::_Maklocchr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptrdest$ = -12					; size = 4
__Ptrnext$1 = -8					; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 511  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 512  :     // convert C string to _Elem sequence using _Cvtvec
; 513  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _strlen
  0000f	83 c4 04	 add	 esp, 4
  00012	83 c0 01	 add	 eax, 1
  00015	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 514  : 
; 515  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00018	6a 01		 push	 1
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 _calloc
  00023	83 c4 08	 add	 esp, 8
  00026	89 45 f4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 516  : 
; 517  :     if (!_Ptrdest) {

  00029	83 7d f4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  0002d	75 06		 jne	 SHORT $LN5@Maklocstr

; 518  :         _Xbad_alloc();

  0002f	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
  00034	90		 npad	 1
$LN5@Maklocstr:

; 519  :     }
; 520  : 
; 521  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  00035	8b 55 f4	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  00038	89 55 f8	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  0003b	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  0003d	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00040	83 e8 01	 sub	 eax, 1
  00043	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  00049	83 c1 01	 add	 ecx, 1
  0004c	89 4d f8	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  0004f	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00052	83 c2 01	 add	 edx, 1
  00055	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  00058	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0005c	76 0c		 jbe	 SHORT $LN3@Maklocstr

; 522  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  0005e	8b 45 f8	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00064	8a 11		 mov	 dl, BYTE PTR [ecx]
  00066	88 10		 mov	 BYTE PTR [eax], dl

; 523  :     }

  00068	eb d3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 524  : 
; 525  :     return _Ptrdest;

  0006a	8b 45 f4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN1@Maklocstr:

; 526  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ PROC	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >, COMDAT
; _this$ = ecx

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :         if (_Target) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN2@Tidy_guard

; 55   :             _Target->_Tidy();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@D@std@@AAEXXZ ; std::numpunct<char>::_Tidy
  00019	90		 npad	 1
$LN2@Tidy_guard:

; 56   :         }
; 57   :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ENDP	; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<int> >, COMDAT

; 2173 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2174 : #if _HAS_CXX23
; 2175 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2176 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2177 :         _Count                  = _Allocated;
; 2178 :         return _Ptr;
; 2179 :     } else
; 2180 : #endif // _HAS_CXX23
; 2181 :     {
; 2182 :         return _Al.allocate(_Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate

; 2183 :     }
; 2184 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 06		 jae	 SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0002d	90		 npad	 1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00031	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003d	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00040	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004c	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 3011 :         auto& _Al                     = _Getal();

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00057	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0005a	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00067	83 c4 08	 add	 esp, 8
  0006a	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

  00075	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3017 :         _My_data._Myres       = _New_capacity;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00081	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00084	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

  00096	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  0009a	76 48		 jbe	 SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009c	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a4	0f b6 4d 10	 movzx	 ecx, BYTE PTR _<_Args_0>$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000b0	50		 push	 eax
  000b1	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b6	83 c4 04	 add	 esp, 4
  000b9	50		 push	 eax
  000ba	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000bd	51		 push	 ecx
  000be	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c1	e8 00 00 00 00	 call	 ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c6	8b 55 e4	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000c9	52		 push	 edx
  000ca	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000cd	50		 push	 eax
  000ce	8b 4d dc	 mov	 ecx, DWORD PTR __Al$[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000d7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

  000da	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000dd	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000e0	89 02		 mov	 DWORD PTR [edx], eax

; 3024 :         } else {

  000e2	eb 29		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e4	0f b6 4d 10	 movzx	 ecx, BYTE PTR _<_Args_0>$[ebp]
  000e8	51		 push	 ecx
  000e9	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000ec	52		 push	 edx
  000ed	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f4	51		 push	 ecx
  000f5	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000f8	e8 00 00 00 00	 call	 ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000fd	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  00100	52		 push	 edx
  00101	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0010a	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3031 :     }

  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$ = ecx

; 2294 :                 },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2291 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2292 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);

  0001d	8d 45 14	 lea	 eax, DWORD PTR __Ch$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00024	03 4d 10	 add	 ecx, DWORD PTR __Old_size$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0002d	83 c4 08	 add	 esp, 8

; 2293 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00030	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00034	8d 55 ff	 lea	 edx, DWORD PTR $T1[ebp]
  00037	52		 push	 edx
  00038	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0003e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00048	83 c4 08	 add	 esp, 8

; 2294 :                 },

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 10 00	 ret	 16			; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$_Max_limit@H@std@@YAHXZ
_TEXT	SEGMENT
__Unsigned_max$1 = -4					; size = 4
??$_Max_limit@H@std@@YAHXZ PROC				; std::_Max_limit<int>, COMDAT

; 849  : _NODISCARD constexpr _Ty _Max_limit() noexcept { // same as (numeric_limits<_Ty>::max)(), less throughput cost

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 850  :     _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Ty>); // doesn't attempt to handle all types
; 851  :     if constexpr (is_signed_v<_Ty>) {
; 852  :         constexpr auto _Unsigned_max = static_cast<make_unsigned_t<_Ty>>(-1);

  00004	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __Unsigned_max$1[ebp], -1

; 853  :         return static_cast<_Ty>(_Unsigned_max >> 1);

  0000b	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 854  :     } else {
; 855  :         return static_cast<_Ty>(-1);
; 856  :     }
; 857  : }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??$_Max_limit@H@std@@YAHXZ ENDP				; std::_Max_limit<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Unfancy_maybe_null@$$CBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@$$CBD@std@@YAPBDPBD@Z PROC	; std::_Unfancy_maybe_null<char const >, COMDAT

; 46   : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 47   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 48   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy_maybe_null@$$CBD@std@@YAPBDPBD@Z ENDP	; std::_Unfancy_maybe_null<char const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 751  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 752  :     // assign _New_val to _Val, return previous _Val
; 753  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 754  :     _Val         = static_cast<_Other&&>(_New_val);

  0000c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 755  :     return _Old_val;

  00016	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 756  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>, COMDAT

; 705  :     static _CONSTEXPR20 void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 706  : #if _HAS_CXX20
; 707  :         _STD destroy_at(_Ptr);
; 708  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 709  :         _Ptr->~_Uty();
; 710  : #endif // ^^^ !_HAS_CXX20 ^^^
; 711  :     }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1560 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 396  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 397  : #if _HAS_CXX20
; 398  :     if (_STD is_constant_evaluated()) {
; 399  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 400  :     } else
; 401  : #endif // _HAS_CXX20
; 402  :     {
; 403  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 404  :     }
; 405  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -4					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 804  :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 805  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 806  :         ++_Capacity; // Take null terminator into consideration

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0000f	89 0a		 mov	 DWORD PTR [edx], ecx

; 807  : 
; 808  :         pointer _Fancy_ptr = nullptr;

  00011	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Fancy_ptr$[ebp], 0

; 809  :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 810  :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  00025	83 c4 08	 add	 esp, 8
  00028	89 45 fc	 mov	 DWORD PTR __Fancy_ptr$[ebp], eax

; 811  :         } else {
; 812  :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 813  :             _Fancy_ptr = _Al.allocate(_Capacity);
; 814  :         }
; 815  : 
; 816  : #if _HAS_CXX20
; 817  :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 818  :         // but likely more impactful to throughput.
; 819  :         if (_STD is_constant_evaluated()) {
; 820  :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 821  :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 822  :                 _STD construct_at(_Ptr + _Idx);
; 823  :             }
; 824  :         }
; 825  : #endif // _HAS_CXX20
; 826  :         --_Capacity;

  0002b	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	83 e8 01	 sub	 eax, 1
  00033	8b 4d 0c	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  00036	89 01		 mov	 DWORD PTR [ecx], eax

; 827  :         return _Fancy_ptr;

  00038	8b 45 fc	 mov	 eax, DWORD PTR __Fancy_ptr$[ebp]

; 828  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__Backout$ = -40					; size = 12
$T2 = -28						; size = 4
__ULast$ = -24						; size = 4
__UFirst$ = -20						; size = 4
__Can_memmove$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int const *,int const *,std::allocator<int> >, COMDAT

; 1796 :     _InIt _First, _Se _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1797 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1798 :     // note: only called internally from elsewhere in the STL
; 1799 :     using _Ptrval = typename _Alloc::value_type*;
; 1800 : 
; 1801 : #if _HAS_CXX20
; 1802 :     auto _UFirst = _RANGES _Unwrap_iter<_Se>(_STD move(_First));
; 1803 :     auto _ULast  = _RANGES _Unwrap_sent<_InIt>(_STD move(_Last));
; 1804 : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 1805 :     // In pre-concepts world, _Uninitialized_copy should only ever be called with an iterator
; 1806 :     // and sentinel of the same type, so `_Get_unwrapped` is fine to call.
; 1807 :     auto _UFirst = _STD _Get_unwrapped(_STD move(_First));

  00025	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z ; std::move<int const * &>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 ??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z ; std::_Get_unwrapped<int const *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 ec	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1808 :     auto _ULast  = _STD _Get_unwrapped(_STD move(_Last));

  0003d	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ??$move@AAPBH@std@@YA$$QAPBHAAPBH@Z ; std::move<int const * &>
  00046	83 c4 04	 add	 esp, 4
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@PBH@std@@YA?A_T$$QAPBH@Z ; std::_Get_unwrapped<int const *>
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 e8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1809 : #endif // ^^^ !_HAS_CXX20 ^^^
; 1810 : 
; 1811 :     constexpr bool _Can_memmove = _Sent_copy_cat<decltype(_UFirst), decltype(_ULast), _Ptrval>::_Bitcopy_constructible

  00055	c6 45 f3 01	 mov	 BYTE PTR __Can_memmove$[ebp], 1

; 1812 :                                && _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>::value;
; 1813 : 
; 1814 :     if constexpr (_Can_memmove) {
; 1815 : #if _HAS_CXX20
; 1816 :         if (!_STD is_constant_evaluated())
; 1817 : #endif // _HAS_CXX20
; 1818 :         {
; 1819 :             if constexpr (is_same_v<decltype(_UFirst), decltype(_ULast)>) {
; 1820 :                 _STD _Copy_memmove(_STD _To_address(_UFirst), _STD _To_address(_ULast), _STD _Unfancy(_Dest));

  00059	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0005c	52		 push	 edx
  0005d	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  00062	83 c4 04	 add	 esp, 4
  00065	50		 push	 eax
  00066	8d 45 e8	 lea	 eax, DWORD PTR __ULast$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	8d 4d ec	 lea	 ecx, DWORD PTR __UFirst$[ebp]
  00076	51		 push	 ecx
  00077	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  0007c	83 c4 04	 add	 esp, 4
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ; std::_Copy_memmove<int const *,int *>
  00085	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1821 :                 _Dest += _ULast - _UFirst;

  00088	8b 55 e8	 mov	 edx, DWORD PTR __ULast$[ebp]
  0008b	2b 55 ec	 sub	 edx, DWORD PTR __UFirst$[ebp]
  0008e	c1 fa 02	 sar	 edx, 2
  00091	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00094	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00097	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx

; 1822 :             } else {
; 1823 :                 const auto _Count = static_cast<size_t>(_ULast - _UFirst);
; 1824 :                 _STD _Copy_memmove_n(_STD _To_address(_UFirst), _Count, _STD _Unfancy(_Dest));
; 1825 :                 _Dest += _Count;
; 1826 :             }
; 1827 :             return _Dest;

  0009a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0009d	eb 56		 jmp	 SHORT $LN1@Uninitiali

; 1828 :         }
; 1829 :     }
; 1830 : 
; 1831 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  0009f	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  000a6	50		 push	 eax
  000a7	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000aa	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  000af	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1832 :     for (; _UFirst != _ULast; ++_UFirst) {

  000b6	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000bb	83 c1 04	 add	 ecx, 4
  000be	89 4d ec	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@Uninitiali:
  000c1	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000c4	3b 55 e8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  000c7	74 0f		 je	 SHORT $LN3@Uninitiali

; 1833 :         _Backout._Emplace_back(*_UFirst);

  000c9	8b 45 ec	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000cc	50		 push	 eax
  000cd	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000d0	e8 00 00 00 00	 call	 ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
  000d5	90		 npad	 1

; 1834 :     }

  000d6	eb e0		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1835 : 
; 1836 :     return _Backout._Release();

  000d8	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000db	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  000e0	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000ed	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  000f2	8b 45 e4	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1837 : }

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int const *,int const *,std::allocator<int> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@PBH@std@@YA$$QAPBHAAPBH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PBH@std@@YA$$QAPBHAAPBH@Z PROC		; std::forward<int const *>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PBH@std@@YA$$QAPBHAAPBH@Z ENDP		; std::forward<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 53   :     _CONSTEXPR20 ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 54   :         if (_Target) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0b		 je	 SHORT $LN2@Tidy_guard

; 55   :             _Target->_Tidy();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00014	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  00019	90		 npad	 1
$LN2@Tidy_guard:

; 56   :         }
; 57   :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@PAH@std@@YA$$QAPAHAAPAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAH@std@@YA$$QAPAHAAPAH@Z PROC		; std::forward<int *>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PAH@std@@YA$$QAPAHAAPAH@Z ENDP		; std::forward<int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z
_TEXT	SEGMENT
__Newsize$ = -64					; size = 4
__Constructed_last$ = -60				; size = 4
__Oldsize$ = -56					; size = 4
__My_data$ = -52					; size = 4
__Newcapacity$ = -48					; size = 4
__Constructed_first$ = -44				; size = 4
__Mylast$ = -40						; size = 4
__Myfirst$ = -36					; size = 4
__Whereoff$ = -32					; size = 4
_this$ = -28						; size = 4
__Al$ = -24						; size = 4
__Newvec$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>, COMDAT
; _this$ = ecx

; 806  :     _CONSTEXPR20 pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 30	 sub	 esp, 48			; 00000030H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx

; 807  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 808  :         _Alty& _Al        = _Getal();

  0002f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00037	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 809  :         auto& _My_data    = _Mypair._Myval2;

  0003a	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 cc	 mov	 DWORD PTR __My_data$[ebp], eax

; 810  :         pointer& _Myfirst = _My_data._Myfirst;

  00040	8b 4d cc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	89 4d dc	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 811  :         pointer& _Mylast  = _My_data._Mylast;

  00046	8b 55 cc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00049	83 c2 04	 add	 edx, 4
  0004c	89 55 d8	 mov	 DWORD PTR __Mylast$[ebp], edx

; 812  : 
; 813  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 814  : 
; 815  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0004f	8b 45 dc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00055	2b 08		 sub	 ecx, DWORD PTR [eax]
  00057	c1 f9 02	 sar	 ecx, 2
  0005a	89 4d e0	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 816  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  0005d	8b 55 d8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00060	8b 45 dc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00063	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00065	2b 08		 sub	 ecx, DWORD PTR [eax]
  00067	c1 f9 02	 sar	 ecx, 2
  0006a	89 4d c8	 mov	 DWORD PTR __Oldsize$[ebp], ecx

; 817  : 
; 818  :         if (_Oldsize == max_size()) {

  0006d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00075	39 45 c8	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00078	75 06		 jne	 SHORT $LN2@Emplace_re

; 819  :             _Xlength();

  0007a	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
  0007f	90		 npad	 1
$LN2@Emplace_re:

; 820  :         }
; 821  : 
; 822  :         const size_type _Newsize = _Oldsize + 1;

  00080	8b 55 c8	 mov	 edx, DWORD PTR __Oldsize$[ebp]
  00083	83 c2 01	 add	 edx, 1
  00086	89 55 c0	 mov	 DWORD PTR __Newsize$[ebp], edx

; 823  :         size_type _Newcapacity   = _Calculate_growth(_Newsize);

  00089	8b 45 c0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ; std::vector<int,std::allocator<int> >::_Calculate_growth
  00095	89 45 d0	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 824  : 
; 825  :         const pointer _Newvec           = _Allocate_at_least_helper(_Al, _Newcapacity);

  00098	8d 4d d0	 lea	 ecx, DWORD PTR __Newcapacity$[ebp]
  0009b	51		 push	 ecx
  0009c	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<int> >
  000a5	83 c4 08	 add	 esp, 8
  000a8	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 826  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  000ab	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  000ae	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000b1	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  000b5	89 55 c4	 mov	 DWORD PTR __Constructed_last$[ebp], edx

; 827  :         pointer _Constructed_first      = _Constructed_last;

  000b8	8b 45 c4	 mov	 eax, DWORD PTR __Constructed_last$[ebp]
  000bb	89 45 d4	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 828  : 
; 829  :         _TRY_BEGIN

  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 830  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  000c5	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  000c8	51		 push	 ecx
  000c9	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  000ce	83 c4 04	 add	 esp, 4
  000d1	50		 push	 eax
  000d2	8b 55 e0	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  000d5	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  000d8	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000e1	83 c4 04	 add	 esp, 4
  000e4	50		 push	 eax
  000e5	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
  000ee	83 c4 0c	 add	 esp, 12			; 0000000cH

; 831  :         _Constructed_first = _Newvec + _Whereoff;

  000f1	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000f7	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000fa	89 55 d4	 mov	 DWORD PTR __Constructed_first$[ebp], edx

; 832  : 
; 833  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  000fd	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00100	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00103	3b 08		 cmp	 ecx, DWORD PTR [eax]
  00105	75 1e		 jne	 SHORT $LN4@Emplace_re

; 834  :             if constexpr (is_nothrow_move_constructible_v<_Ty> || !is_copy_constructible_v<_Ty>) {
; 835  :                 _Uninitialized_move(_Myfirst, _Mylast, _Newvec, _Al);

  00107	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  0010a	52		 push	 edx
  0010b	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d d8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00112	8b 11		 mov	 edx, DWORD PTR [ecx]
  00114	52		 push	 edx
  00115	8b 45 dc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	51		 push	 ecx
  0011b	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  00120	83 c4 10	 add	 esp, 16			; 00000010H

; 836  :             } else {
; 837  :                 _Uninitialized_copy(_Myfirst, _Mylast, _Newvec, _Al);
; 838  :             }
; 839  :         } else { // provide basic guarantee

  00123	eb 41		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 840  :             _Uninitialized_move(_Myfirst, _Whereptr, _Newvec, _Al);

  00125	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  00128	52		 push	 edx
  00129	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0012c	50		 push	 eax
  0012d	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00130	51		 push	 ecx
  00131	8b 55 dc	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00134	8b 02		 mov	 eax, DWORD PTR [edx]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  0013c	83 c4 10	 add	 esp, 16			; 00000010H

; 841  :             _Constructed_first = _Newvec;

  0013f	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00142	89 4d d4	 mov	 DWORD PTR __Constructed_first$[ebp], ecx

; 842  :             _Uninitialized_move(_Whereptr, _Mylast, _Newvec + _Whereoff + 1, _Al);

  00145	8b 55 e8	 mov	 edx, DWORD PTR __Al$[ebp]
  00148	52		 push	 edx
  00149	8b 45 e0	 mov	 eax, DWORD PTR __Whereoff$[ebp]
  0014c	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0014f	8d 54 81 04	 lea	 edx, DWORD PTR [ecx+eax*4+4]
  00153	52		 push	 edx
  00154	8b 45 d8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00157	8b 08		 mov	 ecx, DWORD PTR [eax]
  00159	51		 push	 ecx
  0015a	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_move<int *,std::allocator<int> >
  00163	83 c4 10	 add	 esp, 16			; 00000010H
$LN5@Emplace_re:
  00166	eb 34		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z$0:

; 843  :         }
; 844  :         _CATCH_ALL
; 845  :         _Destroy_range(_Constructed_first, _Constructed_last, _Al);

  00168	8b 45 e8	 mov	 eax, DWORD PTR __Al$[ebp]
  0016b	50		 push	 eax
  0016c	8b 4d c4	 mov	 ecx, DWORD PTR __Constructed_last$[ebp]
  0016f	51		 push	 ecx
  00170	8b 55 d4	 mov	 edx, DWORD PTR __Constructed_first$[ebp]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00179	83 c4 0c	 add	 esp, 12			; 0000000cH

; 846  :         _Al.deallocate(_Newvec, _Newcapacity);

  0017c	8b 45 d0	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0017f	50		 push	 eax
  00180	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00183	51		 push	 ecx
  00184	8b 4d e8	 mov	 ecx, DWORD PTR __Al$[ebp]
  00187	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 847  :         _RERAISE;

  0018c	6a 00		 push	 0
  0018e	6a 00		 push	 0
  00190	e8 00 00 00 00	 call	 __CxxThrowException@8
  00195	90		 npad	 1

; 848  :         _CATCH_END

  00196	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  0019b	c3		 ret	 0
$LN7@Emplace_re:
  0019c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001a3	eb 07		 jmp	 SHORT $LN9@Emplace_re
$LN10@Emplace_re:
  001a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Emplace_re:

; 849  : 
; 850  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  001ac	8b 55 d0	 mov	 edx, DWORD PTR __Newcapacity$[ebp]
  001af	52		 push	 edx
  001b0	8b 45 c0	 mov	 eax, DWORD PTR __Newsize$[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001b7	51		 push	 ecx
  001b8	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  001bb	e8 00 00 00 00	 call	 ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ; std::vector<int,std::allocator<int> >::_Change_array

; 851  :         return _Newvec + _Whereoff;

  001c0	8b 55 e0	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  001c3	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  001c6	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
$LN1@Emplace_re:

; 852  :     }

  001c9	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001cc	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d3	59		 pop	 ecx
  001d4	5f		 pop	 edi
  001d5	5e		 pop	 esi
  001d6	5b		 pop	 ebx
  001d7	8b e5		 mov	 esp, ebp
  001d9	5d		 pop	 ebp
  001da	c2 08 00	 ret	 8
  001dd	cc		 int	 3
  001de	cc		 int	 3
  001df	cc		 int	 3
  001e0	cc		 int	 3
  001e1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Move_backward_unchecked@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_backward_unchecked@PAHPAH@std@@YAPAHPAH00@Z PROC ; std::_Move_backward_unchecked<int *,int *>, COMDAT

; 5053 : _CONSTEXPR20 _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 5054 :     // move [_First, _Last) backwards to [..., _Dest)
; 5055 :     // note: _Move_backward_unchecked has callers other than the move_backward family
; 5056 :     if constexpr (_Iter_move_cat<_BidIt1, _BidIt2>::_Bitcopy_assignable) {
; 5057 : #if _HAS_CXX20
; 5058 :         if (!_STD is_constant_evaluated())
; 5059 : #endif // _HAS_CXX20
; 5060 :         {
; 5061 :             return _STD _Copy_backward_memmove(_First, _Last, _Dest);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ??$_Copy_backward_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_backward_memmove<int *,int *>
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH
  00017	eb 32		 jmp	 SHORT $LN1@Move_backw
$LN2@Move_backw:

; 5062 :         }
; 5063 :     }
; 5064 : 
; 5065 :     while (_First != _Last) {

  00019	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0001c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0001f	74 27		 je	 SHORT $LN3@Move_backw

; 5066 :         *--_Dest = _STD move(*--_Last);

  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00024	83 e9 04	 sub	 ecx, 4
  00027	89 4d 0c	 mov	 DWORD PTR __Last$[ebp], ecx
  0002a	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0002d	83 ea 04	 sub	 edx, 4
  00030	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  00033	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  0003c	83 c4 04	 add	 esp, 4
  0003f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00042	8b 10		 mov	 edx, DWORD PTR [eax]
  00044	89 11		 mov	 DWORD PTR [ecx], edx

; 5067 :     }

  00046	eb d1		 jmp	 SHORT $LN2@Move_backw
$LN3@Move_backw:

; 5068 : 
; 5069 :     return _Dest;

  00048	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_backw:

; 5070 : }

  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
??$_Move_backward_unchecked@PAHPAH@std@@YAPAHPAH00@Z ENDP ; std::_Move_backward_unchecked<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>, COMDAT

; 696  :     static _CONSTEXPR20 void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 697  : #if _HAS_CXX20
; 698  :         _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);
; 699  : #else // ^^^ _HAS_CXX20 / !_HAS_CXX20 vvv
; 700  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00007	50		 push	 eax
  00008	6a 04		 push	 4
  0000a	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0000f	83 c4 08	 add	 esp, 8
  00012	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00015	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00024	8b 00		 mov	 eax, DWORD PTR [eax]
  00026	89 02		 mov	 DWORD PTR [edx], eax

; 701  : #endif // ^^^ !_HAS_CXX20 ^^^
; 702  :     }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@H@std@@YAPAHAAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@H@std@@YAPAHAAH@Z PROC			; std::addressof<int>, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1560 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@H@std@@YAPAHAAH@Z ENDP			; std::addressof<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0H@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@AAV?$allocator@H@1@$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
_<_Vals_0>$ = 12					; size = 4
??$?0H@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@AAV?$allocator@H@1@$$QAH@Z PROC ; std::_Alloc_temporary2<std::allocator<int> >::_Alloc_temporary2<std::allocator<int> ><int>, COMDAT
; _this$ = ecx

; 2137 :         : _Al(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 2138 :         _Traits::construct(_Al, _STD addressof(_Get_value()), _STD forward<_Args>(_Vals)...);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR _<_Vals_0>$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 08		 mov	 ecx, DWORD PTR [eax]
  00033	51		 push	 ecx
  00034	e8 00 00 00 00	 call	 ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2139 :     }

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??$?0H@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@AAV?$allocator@H@1@$$QAH@Z ENDP ; std::_Alloc_temporary2<std::allocator<int> >::_Alloc_temporary2<std::allocator<int> ><int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Alloc_temporary2<std::allocator<int> >::~_Alloc_temporary2<std::allocator<int> >, COMDAT
; _this$ = ecx

; 2144 :     _CONSTEXPR20 ~_Alloc_temporary2() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2145 :         _Traits::destroy(_Al, _STD addressof(_Get_value()));

  00026	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 ??$addressof@H@std@@YAPAHAAH@Z ; std::addressof<int>
  00034	83 c4 04	 add	 esp, 4
  00037	50		 push	 eax
  00038	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$destroy@H@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::destroy<int>
  00043	83 c4 08	 add	 esp, 8

; 2146 :     }

  00046	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00049	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00050	59		 pop	 ecx
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c3		 ret	 0
  00055	cc		 int	 3
  00056	cc		 int	 3
  00057	cc		 int	 3
  00058	cc		 int	 3
  00059	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Alloc_temporary2<std::allocator<int> >::~_Alloc_temporary2<std::allocator<int> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ PROC ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value, COMDAT
; _this$ = ecx

; 2125 :     _NODISCARD _CONSTEXPR20 value_type& _Get_value() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2126 :         return _Value;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4

; 2127 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ ENDP ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z
_TEXT	SEGMENT
__Result$ = -16						; size = 4
__My_data$ = -12					; size = 4
_this$ = -8						; size = 4
__Mylast$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>, COMDAT
; _this$ = ecx

; 783  :     _CONSTEXPR20 _Ty& _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 784  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 785  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 786  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	89 4d fc	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 787  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 788  :         if constexpr (conjunction_v<is_nothrow_constructible<_Ty, _Valty...>,
; 789  :                           _Uses_default_construct<_Alloc, _Ty*, _Valty...>>) {
; 790  :             _ASAN_VECTOR_MODIFY(1);
; 791  :             _Construct_in_place(*_Mylast, _STD forward<_Valty>(_Val)...);

  00018	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ??$_Construct_in_place@HH@std@@YAXAAH$$QAH@Z ; std::_Construct_in_place<int,int>
  00030	83 c4 08	 add	 esp, 8

; 792  :         } else {
; 793  :             _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Mylast - _My_data._Myfirst) + 1);
; 794  :             _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);
; 795  :             _ASAN_VECTOR_RELEASE_GUARD;
; 796  :         }
; 797  : 
; 798  :         _Orphan_range(_Mylast, _Mylast);

  00033	8b 55 fc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00036	8b 02		 mov	 eax, DWORD PTR [edx]
  00038	50		 push	 eax
  00039	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	52		 push	 edx
  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 799  :         _Ty& _Result = *_Mylast;

  00047	8b 45 fc	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	89 4d f0	 mov	 DWORD PTR __Result$[ebp], ecx

; 800  :         ++_Mylast;

  0004f	8b 55 fc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00052	8b 02		 mov	 eax, DWORD PTR [edx]
  00054	83 c0 04	 add	 eax, 4
  00057	8b 4d fc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0005a	89 01		 mov	 DWORD PTR [ecx], eax

; 801  : 
; 802  :         return _Result;

  0005c	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 803  :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$forward@H@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@H@std@@YA$$QAHAAH@Z PROC			; std::forward<int>, COMDAT

; 1535 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1536 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1537 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@H@std@@YA$$QAHAAH@Z ENDP			; std::forward<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z PROC ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>, COMDAT

; 1319 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1320 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1321 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1322 :         return _It + 0;
; 1323 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1324 :         return static_cast<_Iter&&>(_It)._Unwrapped();

  00003	8b 4d 08	 mov	 ecx, DWORD PTR __It$[ebp]
  00006	e8 00 00 00 00	 call	 ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped

; 1325 :     } else {
; 1326 :         return static_cast<_Iter&&>(_It);
; 1327 :     }
; 1328 : }

  0000b	5d		 pop	 ebp
  0000c	c3		 ret	 0
??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z PROC ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT

; 1292 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1293 :     // check that [_First, _Last) forms an iterator range
; 1294 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1295 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1296 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1297 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1298 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1299 :         _Verify_range(_First, _Last);
; 1300 :     }
; 1301 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ENDP ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 100  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 101  :             return _Ok;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 102  :         }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$ = 12						; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 98   :             : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Noskip$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00043	e8 00 00 00 00	 call	 ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	88 41 04	 mov	 BYTE PTR [ecx+4], al
  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv72 = -20						; size = 4
__Rdbuf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 83   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 84   :             const auto _Rdbuf = _Myistr.rdbuf();

  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00030	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  00038	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0003b	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00040	89 45 f0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 85   :             if (_Rdbuf) {

  00043	83 7d f0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00047	74 0e		 je	 SHORT $LN2@Sentry_bas

; 86   :                 _Rdbuf->_Unlock();

  00049	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00051	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00054	ff d0		 call	 eax
  00056	90		 npad	 1
$LN2@Sentry_bas:

; 87   :             }
; 88   :         }

  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Rdbuf$ = -4						; size = 4
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 76   :         __CLR_OR_THIS_CALL _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 77   :             const auto _Rdbuf = _Myistr.rdbuf();

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00021	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00024	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00029	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 78   :             if (_Rdbuf) {

  0002c	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00030	74 0e		 je	 SHORT $LN2@Sentry_bas

; 79   :                 _Rdbuf->_Lock();

  00032	8b 45 fc	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	ff d0		 call	 eax
  0003f	90		 npad	 1
$LN2@Sentry_bas:

; 80   :             }
; 81   :         }

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 3355 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  0000c	50		 push	 eax
  0000d	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00011	51		 push	 ecx
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
  0001a	90		 npad	 1
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1503 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1504 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 3440 :     _CONSTEXPR23 pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3441 :         return _STD exchange(_Mypair._Myval2, nullptr);

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
  0001d	83 c4 08	 add	 esp, 8

; 3442 :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3410 :     _CONSTEXPR23 ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3411 :         if (_Mypair._Myval2) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 16		 je	 SHORT $LN2@unique_ptr

; 3412 :             _Mypair._Get_first()(_Mypair._Myval2);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
  0001d	8b c8		 mov	 ecx, eax
  0001f	e8 00 00 00 00	 call	 ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
  00024	90		 npad	 1
$LN2@unique_ptr:

; 3413 :         }
; 3414 :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv70 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 3300 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3301 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3302 :         delete _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000f	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00013	74 13		 je	 SHORT $LN3@operator
  00015	6a 01		 push	 1
  00017	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	ff d0		 call	 eax
  00023	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00026	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00028	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@operator:

; 3303 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1046 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1047 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1048 :         _Left = _STD move(_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
  0000c	83 c4 04	 add	 esp, 4

; 1049 :     }
; 1050 : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1560 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 06		 jae	 SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0002d	90		 npad	 1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00031	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003d	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00040	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004c	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 3011 :         auto& _Al                     = _Getal();

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00057	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0005a	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00067	83 c4 08	 add	 esp, 8
  0006a	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

  00075	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3017 :         _My_data._Myres       = _New_capacity;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00081	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00084	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

  00096	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  0009a	76 4c		 jbe	 SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009c	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a4	0f b6 4d 14	 movzx	 ecx, BYTE PTR _<_Args_1>$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000ba	83 c4 04	 add	 esp, 4
  000bd	50		 push	 eax
  000be	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000c1	52		 push	 edx
  000c2	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c5	e8 00 00 00 00	 call	 ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000ca	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cd	50		 push	 eax
  000ce	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

  000de	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e1	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e4	89 08		 mov	 DWORD PTR [eax], ecx

; 3024 :         } else {

  000e6	eb 2d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e8	0f b6 55 14	 movzx	 edx, BYTE PTR _<_Args_1>$[ebp]
  000ec	52		 push	 edx
  000ed	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f4	51		 push	 ecx
  000f5	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000fc	50		 push	 eax
  000fd	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00100	e8 00 00 00 00	 call	 ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00105	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00108	51		 push	 ecx
  00109	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00112	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

  00115	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3031 :     }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 1543 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1540 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1541 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  0001d	0f b6 45 18	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00029	03 55 10	 add	 edx, DWORD PTR __Old_size$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1542 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00035	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00039	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00040	03 4d 14	 add	 ecx, DWORD PTR __Count$[ebp]
  00043	03 4d 08	 add	 ecx, DWORD PTR __New_ptr$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004c	83 c4 08	 add	 esp, 8

; 1543 :             },

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 14 00	 ret	 20			; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
_<_Args_2>$ = 24					; size = 1
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>, COMDAT
; _this$ = ecx

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 06		 jae	 SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0002d	90		 npad	 1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00031	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003d	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00040	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004c	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 3011 :         auto& _Al                     = _Getal();

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00057	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0005a	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00067	83 c4 08	 add	 esp, 8
  0006a	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

  00075	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3017 :         _My_data._Myres       = _New_capacity;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00081	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00084	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

  00096	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  0009a	76 50		 jbe	 SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009c	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a4	0f b6 4d 18	 movzx	 ecx, BYTE PTR _<_Args_2>$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 55 14	 mov	 edx, DWORD PTR _<_Args_1>$[ebp]
  000ac	52		 push	 edx
  000ad	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000b4	51		 push	 ecx
  000b5	8b 55 e0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000be	83 c4 04	 add	 esp, 4
  000c1	50		 push	 eax
  000c2	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000c5	50		 push	 eax
  000c6	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c9	e8 00 00 00 00	 call	 ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000ce	8b 4d e4	 mov	 ecx, DWORD PTR __Old_capacity$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 e0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 dc	 mov	 eax, DWORD PTR __Al$[ebp]
  000d9	50		 push	 eax
  000da	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000df	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000e5	8b 55 f0	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  000e8	89 11		 mov	 DWORD PTR [ecx], edx

; 3024 :         } else {

  000ea	eb 31		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000ec	0f b6 45 18	 movzx	 eax, BYTE PTR _<_Args_2>$[ebp]
  000f0	50		 push	 eax
  000f1	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000f4	51		 push	 ecx
  000f5	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000fc	50		 push	 eax
  000fd	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00100	51		 push	 ecx
  00101	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  00104	52		 push	 edx
  00105	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00108	e8 00 00 00 00	 call	 ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  0010d	8d 45 f0	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  00110	50		 push	 eax
  00111	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0011a	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

  0011d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3031 :     }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 14 00	 ret	 20			; 00000014H
??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Off$ = 20						; size = 4
__Count$ = 24						; size = 4
__Ch$ = 28						; size = 1
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z PROC ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator(), COMDAT
; _this$ = ecx

; 1792 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1789 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);

  00007	8b 45 14	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00018	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1790 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);

  0001b	0f b6 45 1c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0001f	50		 push	 eax
  00020	8b 4d 18	 mov	 ecx, DWORD PTR __Count$[ebp]
  00023	51		 push	 ecx
  00024	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00027	03 55 14	 add	 edx, DWORD PTR __Off$[ebp]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1791 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00033	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00036	2b 45 14	 sub	 eax, DWORD PTR __Off$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	50		 push	 eax
  0003d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00040	03 4d 14	 add	 ecx, DWORD PTR __Off$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00047	03 55 14	 add	 edx, DWORD PTR __Off$[ebp]
  0004a	03 55 18	 add	 edx, DWORD PTR __Count$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1792 :             },

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 18 00	 ret	 24			; 00000018H
??R<lambda_6607a66f2a10a1261ff9db96cba1015b>@@QBE@QADQBDIIID@Z ENDP ; <lambda_6607a66f2a10a1261ff9db96cba1015b>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 95   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 96   :     // return smaller of _Left and _Right
; 97   :     return _Right < _Left ? _Right : _Left;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@min
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 98   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 289  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 290  :     if constexpr (is_array_v<_Ty>) {
; 291  :         _STD _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 292  :     } else {
; 293  :         _Obj.~_Ty();
; 294  :     }
; 295  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Deallocate@$07@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07@std@@YAXPAXI@Z PROC			; std::_Deallocate<8>, COMDAT

; 230  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 231  :     // deallocate storage allocated by _Allocate
; 232  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 233  :     if (_STD is_constant_evaluated()) {
; 234  :         ::operator delete(_Ptr);
; 235  :         return;
; 236  :     }
; 237  : #endif // _HAS_CXX20
; 238  : 
; 239  : #ifdef __cpp_aligned_new
; 240  :     if constexpr (_Align > __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
; 241  :         size_t _Passed_align = _Align;
; 242  : #if defined(_M_IX86) || defined(_M_X64)
; 243  :         if (_Bytes >= _Big_allocation_threshold) {
; 244  :             // boost the alignment of big allocations to help autovectorization
; 245  :             _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
; 246  :         }
; 247  : #endif // defined(_M_IX86) || defined(_M_X64)
; 248  :         ::operator delete(_Ptr, _Bytes, align_val_t{_Passed_align});
; 249  :     } else
; 250  : #endif // defined(__cpp_aligned_new)
; 251  :     {
; 252  : #if defined(_M_IX86) || defined(_M_X64)
; 253  :         if (_Bytes >= _Big_allocation_threshold) {

  00022	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00029	72 10		 jb	 SHORT $LN2@Deallocate

; 254  :             // boost the alignment of big allocations to help autovectorization
; 255  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0002b	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00038	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 256  :         }
; 257  : #endif // defined(_M_IX86) || defined(_M_X64)
; 258  :         ::operator delete(_Ptr, _Bytes);

  0003b	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0003e	52		 push	 edx
  0003f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00048	83 c4 08	 add	 esp, 8

; 259  :     }
; 260  : }

  0004b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0004e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00055	59		 pop	 ecx
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
  0005a	cc		 int	 3
  0005b	cc		 int	 3
  0005c	cc		 int	 3
  0005d	cc		 int	 3
  0005e	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07@std@@YAXPAXI@Z ENDP			; std::_Deallocate<8>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 72   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 73   :     // return larger of _Left and _Right
; 74   :     return _Left < _Right ? _Right : _Left;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@max
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 75   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  :         return *_IPnext ? *_IPcount : 0;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00012	74 0d		 je	 SHORT $LN3@Pnavail
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  0001f	eb 07		 jmp	 SHORT $LN4@Pnavail
$LN3@Pnavail:
  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Pnavail:
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002b	99		 cdq

; 262  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  :         --*_IPcount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	83 ea 01	 sub	 edx, 1
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 257  :         return (*_IPnext)++;

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f8	 mov	 DWORD PTR tv76[ebp], ecx
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	83 c1 01	 add	 ecx, 1
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]

; 258  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail, COMDAT
; _this$ = ecx

; 231  :     streamsize __CLR_OR_THIS_CALL _Gnavail() const noexcept { // count number of available elements in read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 232  :         return *_IGnext ? *_IGcount : 0;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00012	74 0d		 je	 SHORT $LN3@Gnavail
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  0001f	eb 07		 jmp	 SHORT $LN4@Gnavail
$LN3@Gnavail:
  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Gnavail:
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002b	99		 cdq

; 233  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv72 = -8						; size = 4
_this$ = -4						; size = 4
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc, COMDAT
; _this$ = ecx

; 226  :     _Elem* __CLR_OR_THIS_CALL _Gnpreinc() noexcept { // preincrement current position in read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 227  :         --*_IGcount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	83 ea 01	 sub	 edx, 1
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 228  :         return ++(*_IGnext);

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	83 c1 01	 add	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  0002a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002d	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00030	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  00033	89 08		 mov	 DWORD PTR [eax], ecx
  00035	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]

; 229  :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc, COMDAT
; _this$ = ecx

; 221  :     _Elem* __CLR_OR_THIS_CALL _Gninc() noexcept { // increment current position in read buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 222  :         --*_IGcount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	83 ea 01	 sub	 edx, 1
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 2c	 mov	 ecx, DWORD PTR [eax+44]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 223  :         return (*_IGnext)++;

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f8	 mov	 DWORD PTR tv76[ebp], ecx
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	83 c1 01	 add	 ecx, 1
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]

; 224  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::gptr, COMDAT
; _this$ = ecx

; 183  :     _Elem* __CLR_OR_THIS_CALL gptr() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 184  :         return *_IGnext;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000d	8b 01		 mov	 eax, DWORD PTR [ecx]

; 185  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::gptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 170  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  :         return xsputn(_Ptr, _Count);

  00007	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00012	52		 push	 edx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0001e	ff d0		 call	 eax

; 172  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv85 = -16						; size = 8
tv78 = -8						; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 165  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  00011	89 45 f0	 mov	 DWORD PTR tv85[ebp], eax
  00014	89 55 f4	 mov	 DWORD PTR tv85[ebp+4], edx
  00017	83 7d f4 00	 cmp	 DWORD PTR tv85[ebp+4], 0
  0001b	7c 27		 jl	 SHORT $LN3@sputc
  0001d	7f 06		 jg	 SHORT $LN5@sputc
  0001f	83 7d f0 00	 cmp	 DWORD PTR tv85[ebp], 0
  00023	76 1f		 jbe	 SHORT $LN3@sputc
$LN5@sputc:
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
  0002d	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  00030	88 08		 mov	 BYTE PTR [eax], cl
  00032	0f b6 55 08	 movzx	 edx, BYTE PTR __Ch$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00042	eb 1e		 jmp	 SHORT $LN4@sputc
$LN3@sputc:
  00044	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0004e	83 c4 04	 add	 esp, 4
  00051	50		 push	 eax
  00052	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	8b 11		 mov	 edx, DWORD PTR [ecx]
  00057	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0005d	ff d0		 call	 eax
  0005f	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
$LN4@sputc:
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv78[ebp]

; 167  :     }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv89 = -20						; size = 8
tv83 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::snextc, COMDAT
; _this$ = ecx

; 137  :     int_type __CLR_OR_THIS_CALL snextc() { // point to next character and return it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :         return 1 < _Gnavail()                                 ? _Traits::to_int_type(*_Gnpreinc())

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  00011	89 45 ec	 mov	 DWORD PTR tv89[ebp], eax
  00014	89 55 f0	 mov	 DWORD PTR tv89[ebp+4], edx
  00017	83 7d f0 00	 cmp	 DWORD PTR tv89[ebp+4], 0
  0001b	7c 23		 jl	 SHORT $LN5@snextc
  0001d	7f 06		 jg	 SHORT $LN7@snextc
  0001f	83 7d ec 01	 cmp	 DWORD PTR tv89[ebp], 1
  00023	76 1b		 jbe	 SHORT $LN5@snextc
$LN7@snextc:
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Gnpreinc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnpreinc
  0002d	8a 00		 mov	 al, BYTE PTR [eax]
  0002f	0f b6 c8	 movzx	 ecx, al
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
  0003e	eb 39		 jmp	 SHORT $LN6@snextc
$LN5@snextc:
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00054	83 c4 08	 add	 esp, 8
  00057	0f b6 d0	 movzx	 edx, al
  0005a	85 d2		 test	 edx, edx
  0005c	74 0a		 je	 SHORT $LN3@snextc
  0005e	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00063	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
  00066	eb 0b		 jmp	 SHORT $LN4@snextc
$LN3@snextc:
  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
  00070	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN4@snextc:
  00073	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00076	89 45 f4	 mov	 DWORD PTR tv83[ebp], eax
$LN6@snextc:
  00079	8b 45 f4	 mov	 eax, DWORD PTR tv83[ebp]

; 139  :              : _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof()
; 140  :                                                               : sgetc();
; 141  :     }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::snextc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv82 = -16						; size = 8
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sgetc, COMDAT
; _this$ = ecx

; 128  :     int_type __CLR_OR_THIS_CALL sgetc() { // get a character and don't point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  00011	89 45 f0	 mov	 DWORD PTR tv82[ebp], eax
  00014	89 55 f4	 mov	 DWORD PTR tv82[ebp+4], edx
  00017	83 7d f4 00	 cmp	 DWORD PTR tv82[ebp+4], 0
  0001b	7c 23		 jl	 SHORT $LN3@sgetc
  0001d	7f 06		 jg	 SHORT $LN5@sgetc
  0001f	83 7d f0 00	 cmp	 DWORD PTR tv82[ebp], 0
  00023	76 1b		 jbe	 SHORT $LN3@sgetc
$LN5@sgetc:
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::gptr
  0002d	8a 00		 mov	 al, BYTE PTR [eax]
  0002f	0f b6 c8	 movzx	 ecx, al
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0003e	eb 10		 jmp	 SHORT $LN4@sgetc
$LN3@sgetc:
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 50 18	 mov	 edx, DWORD PTR [eax+24]
  0004b	ff d2		 call	 edx
  0004d	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
$LN4@sgetc:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]

; 130  :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
tv82 = -16						; size = 8
tv75 = -8						; size = 4
_this$ = -4						; size = 4
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc, COMDAT
; _this$ = ecx

; 124  :     int_type __CLR_OR_THIS_CALL sbumpc() { // get a character and point past it

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 125  :         return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gnavail
  00011	89 45 f0	 mov	 DWORD PTR tv82[ebp], eax
  00014	89 55 f4	 mov	 DWORD PTR tv82[ebp+4], edx
  00017	83 7d f4 00	 cmp	 DWORD PTR tv82[ebp+4], 0
  0001b	7c 23		 jl	 SHORT $LN3@sbumpc
  0001d	7f 06		 jg	 SHORT $LN5@sbumpc
  0001f	83 7d f0 00	 cmp	 DWORD PTR tv82[ebp], 0
  00023	76 1b		 jbe	 SHORT $LN3@sbumpc
$LN5@sbumpc:
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Gninc
  0002d	8a 00		 mov	 al, BYTE PTR [eax]
  0002f	0f b6 c8	 movzx	 ecx, al
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0003e	eb 10		 jmp	 SHORT $LN4@sbumpc
$LN3@sbumpc:
  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 50 1c	 mov	 edx, DWORD PTR [eax+28]
  0004b	ff d2		 call	 edx
  0004d	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
$LN4@sbumpc:
  00050	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]

; 126  :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sbumpc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 120  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  :         return sync();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00012	ff d0		 call	 eax

; 122  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 1500 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001b	90		 npad	 1
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT

; 396  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 397  : #if _HAS_CXX20
; 398  :     if (_STD is_constant_evaluated()) {
; 399  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 400  :     } else
; 401  : #endif // _HAS_CXX20
; 402  :     {
; 403  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 404  :     }
; 405  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 2999 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3000 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3001 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3002 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 3003 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 3004 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 06		 jae	 SHORT $LN2@Reallocate

; 3005 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  0002d	90		 npad	 1
$LN2@Reallocate:

; 3006 :         }
; 3007 : 
; 3008 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00031	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00034	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 3009 :         const size_type _Old_capacity = _My_data._Myres;

  00037	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003a	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003d	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 3010 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00040	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00043	50		 push	 eax
  00044	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004c	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 3011 :         auto& _Al                     = _Getal();

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00057	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 3012 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0005a	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005d	51		 push	 ecx
  0005e	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00067	83 c4 08	 add	 esp, 8
  0006a	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 3013 : 
; 3014 :         _My_data._Orphan_all();

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3015 :         _ASAN_STRING_REMOVE(*this);
; 3016 :         _My_data._Mysize      = _New_size;

  00075	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00078	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007b	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3017 :         _My_data._Myres       = _New_capacity;

  0007e	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00081	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00084	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3018 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0008a	51		 push	 ecx
  0008b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00090	83 c4 04	 add	 esp, 4
  00093	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 3019 :         if (_Old_capacity > _Small_string_capacity) {

  00096	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  0009a	76 4b		 jbe	 SHORT $LN3@Reallocate

; 3020 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009c	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009f	8b 02		 mov	 eax, DWORD PTR [edx]
  000a1	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3021 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a4	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b9	83 c4 04	 add	 esp, 4
  000bc	50		 push	 eax
  000bd	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000c0	52		 push	 edx
  000c1	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c4	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3022 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c9	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000d0	51		 push	 ecx
  000d1	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3023 :             _My_data._Bx._Ptr = _New_ptr;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx

; 3024 :         } else {

  000e5	eb 2c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 3025 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e7	8b 55 14	 mov	 edx, DWORD PTR _<_Args_1>$[ebp]
  000ea	52		 push	 edx
  000eb	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000ee	50		 push	 eax
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f2	51		 push	 ecx
  000f3	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f6	52		 push	 edx
  000f7	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000fa	50		 push	 eax
  000fb	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000fe	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 3026 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00103	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00106	51		 push	 ecx
  00107	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0010a	52		 push	 edx
  0010b	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00110	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 3027 :         }
; 3028 : 
; 3029 :         _ASAN_STRING_CREATE(*this);
; 3030 :         return *this;

  00113	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 3031 :     }

  00116	8b e5		 mov	 esp, ebp
  00118	5d		 pop	 ebp
  00119	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 1516 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1513 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1514 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0001d	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 14	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00028	03 55 10	 add	 edx, DWORD PTR __Old_size$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1515 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00034	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00038	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0003f	03 4d 18	 add	 ecx, DWORD PTR __Count$[ebp]
  00042	03 4d 08	 add	 ecx, DWORD PTR __New_ptr$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004b	83 c4 08	 add	 esp, 8

; 1516 :             },

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 1062 : _CONSTEXPR20 void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1063 :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 1064 :     using _Ty = typename _Alloc::value_type;
; 1065 :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 1066 :         for (; _First != _Last; ++_First) {
; 1067 :             allocator_traits<_Alloc>::destroy(_Al, _STD _Unfancy(_First));
; 1068 :         }
; 1069 :     }
; 1070 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1548 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$numpunct@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$numpunct@D@std@@MAEPAXI@Z PROC			; std::numpunct<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$numpunct@D@std@@MAE@XZ ; std::numpunct<char>::~numpunct<char>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 18		 push	 24			; 00000018H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$numpunct@D@std@@MAEPAXI@Z ENDP			; std::numpunct<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Tidy@?$numpunct@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$numpunct@D@std@@AAEXXZ PROC			; std::numpunct<char>::_Tidy, COMDAT
; _this$ = ecx

; 207  :     void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 208  :         _CSTD free(const_cast<char*>(_Grouping));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _free
  00013	83 c4 04	 add	 esp, 4

; 209  :         _CSTD free(const_cast<_Elem*>(_Falsename));

  00016	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _free
  00022	83 c4 04	 add	 esp, 4

; 210  :         _CSTD free(const_cast<_Elem*>(_Truename));

  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 _free
  00031	83 c4 04	 add	 esp, 4

; 211  :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?_Tidy@?$numpunct@D@std@@AAEXXZ ENDP			; std::numpunct<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_truename, COMDAT
; _this$ = ecx

; 202  :     virtual string_type __CLR_OR_THIS_CALL do_truename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 203  :         return string_type{_Truename};

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00016	51		 push	 ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00022	83 ca 01	 or	 edx, 1
  00025	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 204  :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?do_truename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_falsename, COMDAT
; _this$ = ecx

; 198  :     virtual string_type __CLR_OR_THIS_CALL do_falsename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 199  :         return string_type{_Falsename};

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00016	51		 push	 ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00022	83 ca 01	 or	 edx, 1
  00025	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 200  :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?do_falsename@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::do_grouping, COMDAT
; _this$ = ecx

; 194  :     virtual string __CLR_OR_THIS_CALL do_grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 195  :         return string{_Grouping};

  00010	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00016	51		 push	 ecx
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00022	83 ca 01	 or	 edx, 1
  00025	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  00028	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 196  :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?do_grouping@?$numpunct@D@std@@MBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::do_grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_thousands_sep@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_thousands_sep, COMDAT
; _this$ = ecx

; 190  :     virtual _Elem __CLR_OR_THIS_CALL do_thousands_sep() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  :         return _Kseparator;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 0d	 movzx	 eax, BYTE PTR [eax+13]

; 192  :     }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?do_thousands_sep@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_decimal_point@?$numpunct@D@std@@MBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?do_decimal_point@?$numpunct@D@std@@MBEDXZ PROC		; std::numpunct<char>::do_decimal_point, COMDAT
; _this$ = ecx

; 186  :     virtual _Elem __CLR_OR_THIS_CALL do_decimal_point() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  :         return _Dp;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 0c	 movzx	 eax, BYTE PTR [eax+12]

; 188  :     }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?do_decimal_point@?$numpunct@D@std@@MBEDXZ ENDP		; std::numpunct<char>::do_decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
_TEXT	SEGMENT
__Guard$ = -120						; size = 4
__Ptr$ = -116						; size = 4
tv82 = -112						; size = 4
_this$ = -108						; size = 4
$T2 = -104						; size = 44
__Cvt$ = -60						; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Isdef$ = 12						; size = 1
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z PROC	; std::numpunct<char>::_Init, COMDAT
; _this$ = ecx

; 163  :     void _Init(const _Locinfo& _Lobj, bool _Isdef = false) { // initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	56		 push	 esi
  0001f	57		 push	 edi
  00020	50		 push	 eax
  00021	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00024	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002a	89 4d 94	 mov	 DWORD PTR _this$[ebp], ecx

; 164  :         const lconv* _Ptr      = _Lobj._Getlconv();

  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ; std::_Locinfo::_Getlconv
  00035	89 45 8c	 mov	 DWORD PTR __Ptr$[ebp], eax

; 165  :         _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt(); // conversion information

  00038	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt

; 166  : 
; 167  :         _Grouping  = nullptr;

  00044	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0

; 168  :         _Falsename = nullptr;

  0004e	8b 55 94	 mov	 edx, DWORD PTR _this$[ebp]
  00051	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 169  :         _Truename  = nullptr;

  00058	8b 45 94	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 170  : 
; 171  :         _Tidy_guard<numpunct> _Guard{this};

  00062	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	89 4d 88	 mov	 DWORD PTR __Guard$[ebp], ecx
  00068	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 172  :         _Grouping      = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());

  0006f	0f b6 55 0c	 movzx	 edx, BYTE PTR __Isdef$[ebp]
  00073	85 d2		 test	 edx, edx
  00075	74 09		 je	 SHORT $LN5@Init
  00077	c7 45 90 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], OFFSET ??_C@_00CNPNBAHC@@
  0007e	eb 09		 jmp	 SHORT $LN6@Init
$LN5@Init:
  00080	8b 45 8c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00083	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00086	89 4d 90	 mov	 DWORD PTR tv82[ebp], ecx
$LN6@Init:
  00089	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00090	e8 00 00 00 00	 call	 ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ; std::_Locinfo::_Getcvt
  00095	50		 push	 eax
  00096	6a 00		 push	 0
  00098	8b 45 90	 mov	 eax, DWORD PTR tv82[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a4	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 173  :         _Falsename     = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);

  000aa	8d 55 c4	 lea	 edx, DWORD PTR __Cvt$[ebp]
  000ad	52		 push	 edx
  000ae	6a 00		 push	 0
  000b0	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000b3	e8 00 00 00 00	 call	 ?_Getfalse@_Locinfo@std@@QBEPBDXZ ; std::_Locinfo::_Getfalse
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000c4	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 174  :         _Truename      = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);

  000c7	8d 55 c4	 lea	 edx, DWORD PTR __Cvt$[ebp]
  000ca	52		 push	 edx
  000cb	6a 00		 push	 0
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000d0	e8 00 00 00 00	 call	 ?_Gettrue@_Locinfo@std@@QBEPBDXZ ; std::_Locinfo::_Gettrue
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000db	83 c4 0c	 add	 esp, 12			; 0000000cH
  000de	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 175  :         _Guard._Target = nullptr;

  000e4	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __Guard$[ebp], 0

; 176  : 
; 177  :         if (_Isdef) { // apply defaults for required facets

  000eb	0f b6 55 0c	 movzx	 edx, BYTE PTR __Isdef$[ebp]
  000ef	85 d2		 test	 edx, edx
  000f1	74 2e		 je	 SHORT $LN2@Init

; 178  :             // _Grouping = _Maklocstr("", static_cast<char *>(nullptr), _Cvt);
; 179  :             _Dp         = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);

  000f3	8d 45 c4	 lea	 eax, DWORD PTR __Cvt$[ebp]
  000f6	50		 push	 eax
  000f7	6a 00		 push	 0
  000f9	6a 2e		 push	 46			; 0000002eH
  000fb	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH
  00103	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00106	88 41 0c	 mov	 BYTE PTR [ecx+12], al

; 180  :             _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);

  00109	8d 55 c4	 lea	 edx, DWORD PTR __Cvt$[ebp]
  0010c	52		 push	 edx
  0010d	6a 00		 push	 0
  0010f	6a 2c		 push	 44			; 0000002cH
  00111	e8 00 00 00 00	 call	 ??$_Maklocchr@D@std@@YADDPADABU_Cvtvec@@@Z ; std::_Maklocchr<char>
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
  00119	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  0011c	88 41 0d	 mov	 BYTE PTR [ecx+13], al

; 181  :         } else {

  0011f	eb 1e		 jmp	 SHORT $LN3@Init
$LN2@Init:

; 182  :             _Getvals(_Elem{}, _Ptr, _Cvt);

  00121	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00124	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00129	8d 75 c4	 lea	 esi, DWORD PTR __Cvt$[ebp]
  0012c	8b fc		 mov	 edi, esp
  0012e	f3 a5		 rep movsd
  00130	8b 55 8c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00133	52		 push	 edx
  00134	6a 00		 push	 0
  00136	8b 4d 94	 mov	 ecx, DWORD PTR _this$[ebp]
  00139	e8 00 00 00 00	 call	 ??$_Getvals@D@?$numpunct@D@std@@IAEXDPBUlconv@@U_Cvtvec@@@Z ; std::numpunct<char>::_Getvals<char>
  0013e	90		 npad	 1
$LN3@Init:

; 183  :         }
; 184  :     }

  0013f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00146	8d 4d 88	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00149	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
  0014e	90		 npad	 1
  0014f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00152	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00159	59		 pop	 ecx
  0015a	5f		 pop	 edi
  0015b	5e		 pop	 esi
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0015f	33 cd		 xor	 ecx, ebp
  00161	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00166	8b e5		 mov	 esp, ebp
  00168	5d		 pop	 ebp
  00169	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Guard$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$numpunct@D@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::numpunct<char> >::~_Tidy_guard<std::numpunct<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ENDP	; std::numpunct<char>::_Init
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??1?$numpunct@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$numpunct@D@std@@MAE@XZ PROC			; std::numpunct<char>::~numpunct<char>, COMDAT
; _this$ = ecx

; 142  :     __CLR_OR_THIS_CALL ~numpunct() noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$numpunct@D@std@@6B@

; 143  :         _Tidy();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$numpunct@D@std@@AAEXXZ ; std::numpunct<char>::_Tidy
  00018	90		 npad	 1

; 144  :     }

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00021	90		 npad	 1
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1?$numpunct@D@std@@MAE@XZ ENDP			; std::numpunct<char>::~numpunct<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv129 = -32						; size = 4
tv132 = -28						; size = 4
tv90 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::numpunct<char>::_Getcat, COMDAT

; 133  :     static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 134  :         // return locale category mask and construct standard facet
; 135  :         if (_Ppf && !*_Ppf) {

  0002c	83 7d 08 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00030	0f 84 9a 00 00
	00		 je	 $LN9@Getcat
  00036	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	0f 85 8e 00 00
	00		 jne	 $LN9@Getcat

; 136  :             *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->_C_str()), 0, true);

  00042	6a 18		 push	 24			; 00000018H
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	83 7d ec 00	 cmp	 DWORD PTR $T4[ebp], 0
  0005a	74 3c		 je	 SHORT $LN4@Getcat
  0005c	6a 01		 push	 1
  0005e	6a 00		 push	 0
  00060	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00063	e8 00 00 00 00	 call	 ?_C_str@locale@std@@QBEPBDXZ ; std::locale::_C_str
  00068	50		 push	 eax
  00069	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006c	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  00071	89 45 e4	 mov	 DWORD PTR tv132[ebp], eax
  00074	8b 4d e4	 mov	 ecx, DWORD PTR tv132[ebp]
  00077	89 4d e0	 mov	 DWORD PTR tv129[ebp], ecx
  0007a	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0007e	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp]
  00081	83 ca 01	 or	 edx, 1
  00084	89 55 f0	 mov	 DWORD PTR $T5[ebp], edx
  00087	8b 45 e0	 mov	 eax, DWORD PTR tv129[ebp]
  0008a	50		 push	 eax
  0008b	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  0008e	e8 00 00 00 00	 call	 ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ; std::numpunct<char>::numpunct<char>
  00093	89 45 e8	 mov	 DWORD PTR tv90[ebp], eax
  00096	eb 07		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00098	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv90[ebp], 0
$LN5@Getcat:
  0009f	8b 4d e8	 mov	 ecx, DWORD PTR tv90[ebp]
  000a2	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx
  000a5	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000ac	8b 55 08	 mov	 edx, DWORD PTR __Ppf$[ebp]
  000af	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  000b2	89 02		 mov	 DWORD PTR [edx], eax
  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8b 4d f0	 mov	 ecx, DWORD PTR $T5[ebp]
  000be	83 e1 01	 and	 ecx, 1
  000c1	74 0d		 je	 SHORT $LN9@Getcat
  000c3	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  000c7	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ca	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
  000cf	90		 npad	 1
$LN9@Getcat:

; 137  :         }
; 138  :         return _X_NUMERIC;

  000d0	b8 04 00 00 00	 mov	 eax, 4

; 139  :     }

  000d5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000df	59		 pop	 ecx
  000e0	8b e5		 mov	 esp, ebp
  000e2	5d		 pop	 ebp
  000e3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  0001f	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::numpunct<char>::_Getcat
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
__Isdef$ = 16						; size = 1
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z PROC	; std::numpunct<char>::numpunct<char>, COMDAT
; _this$ = ecx

; 129  :     numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$numpunct@D@std@@6B@

; 130  :         _Init(_Lobj, _Isdef);

  00042	0f b6 55 10	 movzx	 edx, BYTE PTR __Isdef$[ebp]
  00046	52		 push	 edx
  00047	8b 45 08	 mov	 eax, DWORD PTR __Lobj$[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Init@?$numpunct@D@std@@IAEXABV_Locinfo@2@_N@Z ; std::numpunct<char>::_Init
  00053	90		 npad	 1

; 131  :     }

  00054	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0005b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00061	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00068	59		 pop	 ecx
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$numpunct@D@std@@QAE@ABV_Locinfo@1@I_N@Z ENDP	; std::numpunct<char>::numpunct<char>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::truename, COMDAT
; _this$ = ecx

; 115  :     string_type truename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 116  :         return do_truename();

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001f	ff d0		 call	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00024	83 c9 01	 or	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 117  :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::truename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::falsename, COMDAT
; _this$ = ecx

; 111  :     string_type falsename() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 112  :         return do_falsename();

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0001f	ff d0		 call	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00024	83 c9 01	 or	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 113  :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::falsename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::numpunct<char>::grouping, COMDAT
; _this$ = ecx

; 107  :     string grouping() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 108  :         return do_grouping();

  00010	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	8b 11		 mov	 edx, DWORD PTR [ecx]
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001f	ff d0		 call	 eax
  00021	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00024	83 c9 01	 or	 ecx, 1
  00027	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 109  :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::numpunct<char>::grouping
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?thousands_sep@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?thousands_sep@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::thousands_sep, COMDAT
; _this$ = ecx

; 103  :     _Elem thousands_sep() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 104  :         return do_thousands_sep();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00012	ff d0		 call	 eax

; 105  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?thousands_sep@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::thousands_sep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?decimal_point@?$numpunct@D@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?decimal_point@?$numpunct@D@std@@QBEDXZ PROC		; std::numpunct<char>::decimal_point, COMDAT
; _this$ = ecx

; 99   :     _Elem decimal_point() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 100  :         return do_decimal_point();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00012	ff d0		 call	 eax

; 101  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?decimal_point@?$numpunct@D@std@@QBEDXZ ENDP		; std::numpunct<char>::decimal_point
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
__Lock$3 = -36						; size = 4
__Id$4 = -32						; size = 4
__Psave_guard$5 = -28					; size = 4
__Pf$6 = -24						; size = 4
__Pfmod$7 = -20						; size = 4
__Psave$8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::numpunct<char> >, COMDAT

; 420  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 421  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00025	6a 00		 push	 0
  00027	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 422  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::numpunct<char> >::_Psave
  0003b	89 45 f0	 mov	 DWORD PTR __Psave$8[ebp], eax

; 423  : 
; 424  :     const size_t _Id         = _Facet::id;

  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$numpunct@D@std@@2V0locale@2@A ; std::numpunct<char>::id
  00043	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00048	89 45 e0	 mov	 DWORD PTR __Id$4[ebp], eax

; 425  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004b	8b 4d e0	 mov	 ecx, DWORD PTR __Id$4[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$6[ebp], eax

; 426  : 
; 427  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$6[ebp], 0
  0005e	75 7d		 jne	 SHORT $LN6@use_facet

; 428  :         if (_Psave) {

  00060	83 7d f0 00	 cmp	 DWORD PTR __Psave$8[ebp], 0
  00064	74 08		 je	 SHORT $LN3@use_facet

; 429  :             _Pf = _Psave; // lazy facet already allocated

  00066	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  00069	89 55 e8	 mov	 DWORD PTR __Pf$6[ebp], edx
  0006c	eb 6f		 jmp	 SHORT $LN6@use_facet
$LN3@use_facet:

; 430  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0006e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00071	50		 push	 eax
  00072	8d 4d f0	 lea	 ecx, DWORD PTR __Psave$8[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Getcat@?$numpunct@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::numpunct<char>::_Getcat
  0007b	83 c4 08	 add	 esp, 8
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	75 08		 jne	 SHORT $LN5@use_facet

; 431  : #if _HAS_EXCEPTIONS
; 432  :             _Throw_bad_cast(); // lazy disallowed

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  00088	90		 npad	 1

; 433  : #else
; 434  :             _CSTD abort(); // lazy disallowed
; 435  : #endif
; 436  :         } else { // queue up lazy facet for destruction

  00089	eb 52		 jmp	 SHORT $LN6@use_facet
$LN5@use_facet:

; 437  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008b	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  0008e	89 55 ec	 mov	 DWORD PTR __Pfmod$7[ebp], edx

; 438  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00091	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$7[ebp]
  00094	50		 push	 eax
  00095	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  00098	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  0009d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 439  : 
; 440  : #if defined(_M_CEE)
; 441  :             _Facet_Register_m(_Pfmod);
; 442  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 443  :             _Facet_Register(_Pfmod);

  000a1	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000aa	83 c4 04	 add	 esp, 4

; 444  : #endif // ^^^ !defined(_M_CEE) ^^^
; 445  : 
; 446  :             _Pfmod->_Incref();

  000ad	8b 55 ec	 mov	 edx, DWORD PTR __Pfmod$7[ebp]
  000b0	8b 02		 mov	 eax, DWORD PTR [edx]
  000b2	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000b5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b8	ff d2		 call	 edx

; 447  :             _Facetptr<_Facet>::_Psave = _Psave;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR __Psave$8[ebp]
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$numpunct@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::numpunct<char> >::_Psave

; 448  :             _Pf                       = _Psave;

  000c2	8b 4d f0	 mov	 ecx, DWORD PTR __Psave$8[ebp]
  000c5	89 4d e8	 mov	 DWORD PTR __Pf$6[ebp], ecx

; 449  : 
; 450  :             (void) _Psave_guard.release();

  000c8	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000cb	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 451  :         }

  000d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d4	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000d7	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  000dc	90		 npad	 1
$LN6@use_facet:

; 452  :     }
; 453  : 
; 454  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000dd	8b 55 e8	 mov	 edx, DWORD PTR __Pf$6[ebp]
  000e0	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  000ed	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000f2	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 455  :     _END_LOCK()
; 456  : } // end of use_facet body

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::numpunct<char> >
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT ??$isfinite@N@@YA_NN@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
__X$ = 8						; size = 8
??$isfinite@N@@YA_NN@Z PROC				; isfinite<double>, COMDAT

; 406  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 407  :         return fpclassify(_X) <= 0;

  00004	83 ec 08	 sub	 esp, 8
  00007	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00011	e8 00 00 00 00	 call	 ?fpclassify@@YAHN@Z	; fpclassify
  00016	83 c4 08	 add	 esp, 8
  00019	85 c0		 test	 eax, eax
  0001b	7f 09		 jg	 SHORT $LN3@isfinite
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00024	eb 07		 jmp	 SHORT $LN4@isfinite
$LN3@isfinite:
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@isfinite:
  0002d	0f b6 45 fc	 movzx	 eax, BYTE PTR tv67[ebp]

; 408  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$isfinite@N@@YA_NN@Z ENDP				; isfinite<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@N@std@@YAH_JH@Z
_TEXT	SEGMENT
__Default_precision$1 = -8				; size = 4
__Is_default_float$2 = -4				; size = 1
__Is_hex$ = -3						; size = 1
tv72 = -2						; size = 1
tv65 = -1						; size = 1
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@N@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<double>, COMDAT

; 1184 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1185 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1186 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00006	81 7d 10 00 30
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 12288 ; 00003000H
  0000d	75 06		 jne	 SHORT $LN10@Float_put_
  0000f	c6 45 ff 01	 mov	 BYTE PTR tv65[ebp], 1
  00013	eb 04		 jmp	 SHORT $LN11@Float_put_
$LN10@Float_put_:
  00015	c6 45 ff 00	 mov	 BYTE PTR tv65[ebp], 0
$LN11@Float_put_:
  00019	8a 45 ff	 mov	 al, BYTE PTR tv65[ebp]
  0001c	88 45 fd	 mov	 BYTE PTR __Is_hex$[ebp], al

; 1187 :     if (_Is_hex) {

  0001f	0f b6 4d fd	 movzx	 ecx, BYTE PTR __Is_hex$[ebp]
  00023	85 c9		 test	 ecx, ecx
  00025	74 07		 je	 SHORT $LN2@Float_put_

; 1188 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1189 :         if constexpr (is_same_v<_Ty, double>) {
; 1190 :             return ((DBL_MANT_DIG - 1) + 3) / 4;

  00027	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0002c	eb 56		 jmp	 SHORT $LN6@Float_put_
$LN2@Float_put_:

; 1191 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1192 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;
; 1193 :         } else {
; 1194 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1195 :         }
; 1196 :     }
; 1197 : 
; 1198 :     if (_Precision > 0) {

  0002e	83 7d 0c 00	 cmp	 DWORD PTR __Precision$[ebp+4], 0
  00032	7c 0f		 jl	 SHORT $LN3@Float_put_
  00034	7f 06		 jg	 SHORT $LN14@Float_put_
  00036	83 7d 08 00	 cmp	 DWORD PTR __Precision$[ebp], 0
  0003a	76 07		 jbe	 SHORT $LN3@Float_put_
$LN14@Float_put_:

; 1199 :         return static_cast<int>(_Precision);

  0003c	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0003f	eb 43		 jmp	 SHORT $LN6@Float_put_
  00041	eb 41		 jmp	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1200 :     } else if (_Precision == 0) {

  00043	8b 55 08	 mov	 edx, DWORD PTR __Precision$[ebp]
  00046	0b 55 0c	 or	 edx, DWORD PTR __Precision$[ebp+4]
  00049	75 2d		 jne	 SHORT $LN5@Float_put_

; 1201 :         const bool _Is_default_float = _Float_flags == 0;

  0004b	83 7d 10 00	 cmp	 DWORD PTR __Float_flags$[ebp], 0
  0004f	75 06		 jne	 SHORT $LN12@Float_put_
  00051	c6 45 fe 01	 mov	 BYTE PTR tv72[ebp], 1
  00055	eb 04		 jmp	 SHORT $LN13@Float_put_
$LN12@Float_put_:
  00057	c6 45 fe 00	 mov	 BYTE PTR tv72[ebp], 0
$LN13@Float_put_:
  0005b	8a 45 fe	 mov	 al, BYTE PTR tv72[ebp]
  0005e	88 45 fc	 mov	 BYTE PTR __Is_default_float$2[ebp], al

; 1202 :         if (_Is_default_float) {

  00061	0f b6 4d fc	 movzx	 ecx, BYTE PTR __Is_default_float$2[ebp]
  00065	85 c9		 test	 ecx, ecx
  00067	74 09		 je	 SHORT $LN7@Float_put_

; 1203 :             return 1;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	eb 14		 jmp	 SHORT $LN6@Float_put_

; 1204 :         } else {

  00070	eb 04		 jmp	 SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1205 :             return 0;

  00072	33 c0		 xor	 eax, eax
  00074	eb 0e		 jmp	 SHORT $LN6@Float_put_
$LN8@Float_put_:

; 1206 :         }
; 1207 :     } else {

  00076	eb 0c		 jmp	 SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1208 :         constexpr int _Default_precision = 6;

  00078	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR __Default_precision$1[ebp], 6

; 1209 :         return _Default_precision;

  0007f	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1210 :     }
; 1211 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??$_Float_put_desired_precision@N@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
_TEXT	SEGMENT
$T2 = -212						; size = 8
$T3 = -204						; size = 8
$T4 = -196						; size = 8
$T5 = -188						; size = 8
$T6 = -180						; size = 8
$T7 = -172						; size = 8
$T8 = -164						; size = 8
$T9 = -156						; size = 8
tv397 = -148						; size = 8
__Eoff$ = -140						; size = 4
tv295 = -136						; size = 4
tv154 = -132						; size = 4
__Ctype_fac$ = -128					; size = 4
tv292 = -124						; size = 4
tv299 = -120						; size = 4
tv188 = -116						; size = 4
__Exps$ = -112						; size = 4
tv69 = -108						; size = 4
__Adjustfield$ = -104					; size = 4
__Punct_fac$ = -100					; size = 4
__Off$10 = -96						; size = 4
__Poff$ = -92						; size = 4
__Dp$ = -88						; size = 2
__Fillcount$ = -84					; size = 4
_this$ = -80						; size = 4
__Pg$11 = -76						; size = 4
__Kseparator$ = -69					; size = 1
__Prefix$ = -68						; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Buf$ = 28						; size = 4
__Count$ = 32						; size = 4
__Is_finite_val$ = 36					; size = 1
??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>, COMDAT
; _this$ = ecx

; 1476 :         bool _Is_finite_val) const { // put formatted floating-point to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	53		 push	 ebx
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1477 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  0002f	83 7d 20 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00033	76 1f		 jbe	 SHORT $LN20@Fput_v3
  00035	8b 45 1c	 mov	 eax, DWORD PTR __Buf$[ebp]
  00038	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003b	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0003e	74 0b		 je	 SHORT $LN19@Fput_v3
  00040	8b 55 1c	 mov	 edx, DWORD PTR __Buf$[ebp]
  00043	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00046	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00049	75 09		 jne	 SHORT $LN20@Fput_v3
$LN19@Fput_v3:
  0004b	c7 45 94 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00052	eb 07		 jmp	 SHORT $LN21@Fput_v3
$LN20@Fput_v3:
  00054	c7 45 94 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN21@Fput_v3:
  0005b	8b 4d 94	 mov	 ecx, DWORD PTR tv69[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR __Prefix$[ebp], ecx

; 1478 :         const char* _Exps;
; 1479 :         if ((_Iosbase.flags() & ios_base::floatfield) != (ios_base::scientific | ios_base::fixed)) {

  00061	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00064	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00069	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  0006e	3d 00 30 00 00	 cmp	 eax, 12288		; 00003000H
  00073	74 09		 je	 SHORT $LN4@Fput_v3

; 1480 :             _Exps = "eE";

  00075	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __Exps$[ebp], OFFSET ??_C@_02MDKMJEGG@eE@

; 1481 :         } else { // correct for hexadecimal floating-point

  0007c	eb 47		 jmp	 SHORT $LN6@Fput_v3
$LN4@Fput_v3:

; 1482 :             _Exps = "pP";

  0007e	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __Exps$[ebp], OFFSET ??_C@_02OOPEBDOJ@pP@

; 1483 :             if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1484 :                 && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  00085	8b 55 bc	 mov	 edx, DWORD PTR __Prefix$[ebp]
  00088	83 c2 02	 add	 edx, 2
  0008b	3b 55 20	 cmp	 edx, DWORD PTR __Count$[ebp]
  0008e	77 35		 ja	 SHORT $LN6@Fput_v3
  00090	8b 45 1c	 mov	 eax, DWORD PTR __Buf$[ebp]
  00093	03 45 bc	 add	 eax, DWORD PTR __Prefix$[ebp]
  00096	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00099	83 f9 30	 cmp	 ecx, 48			; 00000030H
  0009c	75 27		 jne	 SHORT $LN6@Fput_v3
  0009e	8b 55 1c	 mov	 edx, DWORD PTR __Buf$[ebp]
  000a1	03 55 bc	 add	 edx, DWORD PTR __Prefix$[ebp]
  000a4	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  000a8	83 f8 78	 cmp	 eax, 120		; 00000078H
  000ab	74 0f		 je	 SHORT $LN7@Fput_v3
  000ad	8b 4d 1c	 mov	 ecx, DWORD PTR __Buf$[ebp]
  000b0	03 4d bc	 add	 ecx, DWORD PTR __Prefix$[ebp]
  000b3	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  000b7	83 fa 58	 cmp	 edx, 88			; 00000058H
  000ba	75 09		 jne	 SHORT $LN6@Fput_v3
$LN7@Fput_v3:

; 1485 :                 _Prefix += 2;

  000bc	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  000bf	83 c0 02	 add	 eax, 2
  000c2	89 45 bc	 mov	 DWORD PTR __Prefix$[ebp], eax
$LN6@Fput_v3:

; 1486 :             }
; 1487 :         }
; 1488 :         const size_t _Eoff = _CSTD strcspn(&_Buf[0], _Exps); // find exponent

  000c5	8b 4d 90	 mov	 ecx, DWORD PTR __Exps$[ebp]
  000c8	51		 push	 ecx
  000c9	ba 01 00 00 00	 mov	 edx, 1
  000ce	6b c2 00	 imul	 eax, edx, 0
  000d1	03 45 1c	 add	 eax, DWORD PTR __Buf$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _strcspn
  000da	83 c4 08	 add	 esp, 8
  000dd	89 85 74 ff ff
	ff		 mov	 DWORD PTR __Eoff$[ebp], eax

; 1489 :         char _Dp[2]        = {"."};

  000e3	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR ??_C@_01LFCBOECM@?4@
  000ea	66 89 4d a8	 mov	 WORD PTR __Dp$[ebp], cx

; 1490 :         _Dp[0]             = _CSTD localeconv()->decimal_point[0];

  000ee	e8 00 00 00 00	 call	 _localeconv
  000f3	ba 01 00 00 00	 mov	 edx, 1
  000f8	6b ca 00	 imul	 ecx, edx, 0
  000fb	8b 10		 mov	 edx, DWORD PTR [eax]
  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	6b c0 00	 imul	 eax, eax, 0
  00105	8a 0c 11	 mov	 cl, BYTE PTR [ecx+edx]
  00108	88 4c 05 a8	 mov	 BYTE PTR __Dp$[ebp+eax], cl

; 1491 :         const size_t _Poff = _CSTD strcspn(&_Buf[0], &_Dp[0]); // find decimal point

  0010c	ba 01 00 00 00	 mov	 edx, 1
  00111	6b c2 00	 imul	 eax, edx, 0
  00114	8d 4c 05 a8	 lea	 ecx, DWORD PTR __Dp$[ebp+eax]
  00118	51		 push	 ecx
  00119	ba 01 00 00 00	 mov	 edx, 1
  0011e	6b c2 00	 imul	 eax, edx, 0
  00121	03 45 1c	 add	 eax, DWORD PTR __Buf$[ebp]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _strcspn
  0012a	83 c4 08	 add	 esp, 8
  0012d	89 45 a4	 mov	 DWORD PTR __Poff$[ebp], eax

; 1492 : 
; 1493 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  00130	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00136	51		 push	 ecx
  00137	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0013a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0013f	89 45 88	 mov	 DWORD PTR tv299[ebp], eax
  00142	8b 55 88	 mov	 edx, DWORD PTR tv299[ebp]
  00145	89 55 84	 mov	 DWORD PTR tv292[ebp], edx
  00148	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0014f	8b 45 84	 mov	 eax, DWORD PTR tv292[ebp]
  00152	50		 push	 eax
  00153	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00158	83 c4 04	 add	 esp, 4
  0015b	89 45 80	 mov	 DWORD PTR __Ctype_fac$[ebp], eax
  0015e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00165	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0016b	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00170	90		 npad	 1

; 1494 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  00171	6a 00		 push	 0
  00173	8b 4d 20	 mov	 ecx, DWORD PTR __Count$[ebp]
  00176	51		 push	 ecx
  00177	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0017a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0017f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1495 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00186	6a 00		 push	 0
  00188	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0018b	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00190	50		 push	 eax
  00191	8b 55 1c	 mov	 edx, DWORD PTR __Buf$[ebp]
  00194	03 55 20	 add	 edx, DWORD PTR __Count$[ebp]
  00197	52		 push	 edx
  00198	8b 45 1c	 mov	 eax, DWORD PTR __Buf$[ebp]
  0019b	50		 push	 eax
  0019c	8b 4d 80	 mov	 ecx, DWORD PTR __Ctype_fac$[ebp]
  0019f	e8 00 00 00 00	 call	 ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ; std::ctype<char>::widen
  001a4	90		 npad	 1

; 1496 : 
; 1497 :         const auto& _Punct_fac  = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  001a5	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  001ab	51		 push	 ecx
  001ac	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  001af	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  001b4	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  001ba	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  001c0	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv295[ebp], edx
  001c6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  001ca	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv295[ebp]
  001d0	50		 push	 eax
  001d1	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  001d6	83 c4 04	 add	 esp, 4
  001d9	89 45 9c	 mov	 DWORD PTR __Punct_fac$[ebp], eax
  001dc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001e0	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  001e6	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  001eb	90		 npad	 1

; 1498 :         const string _Grouping  = _Punct_fac.grouping();

  001ec	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  001ef	51		 push	 ecx
  001f0	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$[ebp]
  001f3	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
  001f8	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1499 :         const _Elem _Kseparator = _Punct_fac.thousands_sep();

  001fc	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$[ebp]
  001ff	e8 00 00 00 00	 call	 ?thousands_sep@?$numpunct@D@std@@QBEDXZ ; std::numpunct<char>::thousands_sep
  00204	88 45 bb	 mov	 BYTE PTR __Kseparator$[ebp], al

; 1500 : 
; 1501 :         if (_Poff != _Count) {

  00207	8b 55 a4	 mov	 edx, DWORD PTR __Poff$[ebp]
  0020a	3b 55 20	 cmp	 edx, DWORD PTR __Count$[ebp]
  0020d	74 18		 je	 SHORT $LN8@Fput_v3

; 1502 :             _Groupstring[_Poff] = _Punct_fac.decimal_point();

  0020f	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$[ebp]
  00212	e8 00 00 00 00	 call	 ?decimal_point@?$numpunct@D@std@@QBEDXZ ; std::numpunct<char>::decimal_point
  00217	8a d8		 mov	 bl, al
  00219	8b 45 a4	 mov	 eax, DWORD PTR __Poff$[ebp]
  0021c	50		 push	 eax
  0021d	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00220	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00225	88 18		 mov	 BYTE PTR [eax], bl
$LN8@Fput_v3:

; 1503 :         }
; 1504 : 
; 1505 :         if (_Is_finite_val) {

  00227	0f b6 4d 24	 movzx	 ecx, BYTE PTR __Is_finite_val$[ebp]
  0022b	85 c9		 test	 ecx, ecx
  0022d	0f 84 91 00 00
	00		 je	 $LN3@Fput_v3

; 1506 :             size_t _Off     = _Poff == _Count ? _Eoff : _Poff;

  00233	8b 55 a4	 mov	 edx, DWORD PTR __Poff$[ebp]
  00236	3b 55 20	 cmp	 edx, DWORD PTR __Count$[ebp]
  00239	75 0b		 jne	 SHORT $LN22@Fput_v3
  0023b	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR __Eoff$[ebp]
  00241	89 45 8c	 mov	 DWORD PTR tv188[ebp], eax
  00244	eb 06		 jmp	 SHORT $LN23@Fput_v3
$LN22@Fput_v3:
  00246	8b 4d a4	 mov	 ecx, DWORD PTR __Poff$[ebp]
  00249	89 4d 8c	 mov	 DWORD PTR tv188[ebp], ecx
$LN23@Fput_v3:
  0024c	8b 55 8c	 mov	 edx, DWORD PTR tv188[ebp]
  0024f	89 55 a0	 mov	 DWORD PTR __Off$10[ebp], edx

; 1507 :             const char* _Pg = &_Grouping[0];

  00252	6a 00		 push	 0
  00254	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00257	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0025c	89 45 b4	 mov	 DWORD PTR __Pg$11[ebp], eax
$LN2@Fput_v3:

; 1508 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix) {

  0025f	8b 45 b4	 mov	 eax, DWORD PTR __Pg$11[ebp]
  00262	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00265	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  00268	74 5a		 je	 SHORT $LN3@Fput_v3
  0026a	8b 55 b4	 mov	 edx, DWORD PTR __Pg$11[ebp]
  0026d	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00270	85 c0		 test	 eax, eax
  00272	7e 50		 jle	 SHORT $LN3@Fput_v3
  00274	8b 4d b4	 mov	 ecx, DWORD PTR __Pg$11[ebp]
  00277	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0027a	8b 45 a0	 mov	 eax, DWORD PTR __Off$10[ebp]
  0027d	2b 45 bc	 sub	 eax, DWORD PTR __Prefix$[ebp]
  00280	3b d0		 cmp	 edx, eax
  00282	73 40		 jae	 SHORT $LN3@Fput_v3

; 1509 :                 // add thousands separator
; 1510 :                 _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);

  00284	8b 4d b4	 mov	 ecx, DWORD PTR __Pg$11[ebp]
  00287	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  0028a	8b 45 a0	 mov	 eax, DWORD PTR __Off$10[ebp]
  0028d	2b c2		 sub	 eax, edx
  0028f	89 45 a0	 mov	 DWORD PTR __Off$10[ebp], eax
  00292	0f b6 4d bb	 movzx	 ecx, BYTE PTR __Kseparator$[ebp]
  00296	51		 push	 ecx
  00297	6a 01		 push	 1
  00299	8b 55 a0	 mov	 edx, DWORD PTR __Off$10[ebp]
  0029c	52		 push	 edx
  0029d	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  002a0	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  002a5	90		 npad	 1

; 1511 :                 if ('\0' < _Pg[1]) {

  002a6	b8 01 00 00 00	 mov	 eax, 1
  002ab	c1 e0 00	 shl	 eax, 0
  002ae	8b 4d b4	 mov	 ecx, DWORD PTR __Pg$11[ebp]
  002b1	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  002b5	85 d2		 test	 edx, edx
  002b7	7e 09		 jle	 SHORT $LN10@Fput_v3

; 1512 :                     ++_Pg; // not last group, advance

  002b9	8b 45 b4	 mov	 eax, DWORD PTR __Pg$11[ebp]
  002bc	83 c0 01	 add	 eax, 1
  002bf	89 45 b4	 mov	 DWORD PTR __Pg$11[ebp], eax
$LN10@Fput_v3:

; 1513 :                 }
; 1514 :             }

  002c2	eb 9b		 jmp	 SHORT $LN2@Fput_v3
$LN3@Fput_v3:

; 1515 :         }
; 1516 : 
; 1517 :         _Count = _Groupstring.size();

  002c4	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  002c7	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  002cc	89 45 20	 mov	 DWORD PTR __Count$[ebp], eax

; 1518 : 
; 1519 :         size_t _Fillcount;
; 1520 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  002cf	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  002d2	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  002d7	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  002dd	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv397[ebp+4], edx
  002e3	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv397[ebp+4], 0
  002ea	7c 18		 jl	 SHORT $LN13@Fput_v3
  002ec	7f 09		 jg	 SHORT $LN28@Fput_v3
  002ee	83 bd 6c ff ff
	ff 00		 cmp	 DWORD PTR tv397[ebp], 0
  002f5	76 0d		 jbe	 SHORT $LN13@Fput_v3
$LN28@Fput_v3:
  002f7	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  002fa	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  002ff	3b 45 20	 cmp	 eax, DWORD PTR __Count$[ebp]
  00302	77 09		 ja	 SHORT $LN11@Fput_v3
$LN13@Fput_v3:

; 1521 :             _Fillcount = 0;

  00304	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1522 :         } else {

  0030b	eb 0e		 jmp	 SHORT $LN12@Fput_v3
$LN11@Fput_v3:

; 1523 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  0030d	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00310	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00315	2b 45 20	 sub	 eax, DWORD PTR __Count$[ebp]
  00318	89 45 ac	 mov	 DWORD PTR __Fillcount$[ebp], eax
$LN12@Fput_v3:

; 1524 :         }
; 1525 : 
; 1526 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  0031b	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0031e	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00323	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00328	89 45 98	 mov	 DWORD PTR __Adjustfield$[ebp], eax

; 1527 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  0032b	83 7d 98 40	 cmp	 DWORD PTR __Adjustfield$[ebp], 64 ; 00000040H
  0032f	74 79		 je	 SHORT $LN14@Fput_v3
  00331	81 7d 98 00 01
	00 00		 cmp	 DWORD PTR __Adjustfield$[ebp], 256 ; 00000100H
  00338	74 70		 je	 SHORT $LN14@Fput_v3

; 1528 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  0033a	8b 4d ac	 mov	 ecx, DWORD PTR __Fillcount$[ebp]
  0033d	51		 push	 ecx
  0033e	0f b6 55 18	 movzx	 edx, BYTE PTR __Fill$[ebp]
  00342	52		 push	 edx
  00343	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00346	50		 push	 eax
  00347	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0034a	51		 push	 ecx
  0034b	8d 95 54 ff ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  00351	52		 push	 edx
  00352	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00355	50		 push	 eax
  00356	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  0035b	83 c4 18	 add	 esp, 24			; 00000018H
  0035e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00360	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00363	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  00366	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1529 :             _Fillcount = 0;

  00369	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1530 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  00370	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  00373	50		 push	 eax
  00374	6a 00		 push	 0
  00376	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00379	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0037e	50		 push	 eax
  0037f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  00382	51		 push	 ecx
  00383	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  00386	52		 push	 edx
  00387	8d 85 4c ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0038d	50		 push	 eax
  0038e	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00391	51		 push	 ecx
  00392	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00397	83 c4 18	 add	 esp, 24			; 00000018H
  0039a	8b 10		 mov	 edx, DWORD PTR [eax]
  0039c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0039f	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  003a2	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
  003a5	e9 ab 00 00 00	 jmp	 $LN17@Fput_v3
$LN14@Fput_v3:

; 1531 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

  003aa	81 7d 98 00 01
	00 00		 cmp	 DWORD PTR __Adjustfield$[ebp], 256 ; 00000100H
  003b1	75 6d		 jne	 SHORT $LN16@Fput_v3

; 1532 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  003b3	8b 4d bc	 mov	 ecx, DWORD PTR __Prefix$[ebp]
  003b6	51		 push	 ecx
  003b7	6a 00		 push	 0
  003b9	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  003bc	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  003c1	50		 push	 eax
  003c2	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  003c5	52		 push	 edx
  003c6	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  003c9	50		 push	 eax
  003ca	8d 8d 44 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  003d0	51		 push	 ecx
  003d1	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  003d4	52		 push	 edx
  003d5	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  003da	83 c4 18	 add	 esp, 24			; 00000018H
  003dd	8b 08		 mov	 ecx, DWORD PTR [eax]
  003df	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003e2	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  003e5	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1533 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  003e8	8b 45 ac	 mov	 eax, DWORD PTR __Fillcount$[ebp]
  003eb	50		 push	 eax
  003ec	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  003f0	51		 push	 ecx
  003f1	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  003f4	52		 push	 edx
  003f5	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  003f8	50		 push	 eax
  003f9	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003ff	51		 push	 ecx
  00400	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00403	52		 push	 edx
  00404	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00409	83 c4 18	 add	 esp, 24			; 00000018H
  0040c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0040e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00411	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  00414	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1534 :             _Fillcount = 0;

  00417	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1535 :         } else {

  0041e	eb 35		 jmp	 SHORT $LN17@Fput_v3
$LN16@Fput_v3:

; 1536 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  00420	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  00423	50		 push	 eax
  00424	6a 00		 push	 0
  00426	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00429	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0042e	50		 push	 eax
  0042f	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  00432	51		 push	 ecx
  00433	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  00436	52		 push	 edx
  00437	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0043d	50		 push	 eax
  0043e	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00441	51		 push	 ecx
  00442	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00447	83 c4 18	 add	 esp, 24			; 00000018H
  0044a	8b 10		 mov	 edx, DWORD PTR [eax]
  0044c	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0044f	89 55 0c	 mov	 DWORD PTR __Dest$[ebp], edx
  00452	89 45 10	 mov	 DWORD PTR __Dest$[ebp+4], eax
$LN17@Fput_v3:

; 1537 :         }
; 1538 : 
; 1539 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00455	8b 4d 20	 mov	 ecx, DWORD PTR __Count$[ebp]
  00458	2b 4d bc	 sub	 ecx, DWORD PTR __Prefix$[ebp]
  0045b	51		 push	 ecx
  0045c	8b 55 bc	 mov	 edx, DWORD PTR __Prefix$[ebp]
  0045f	52		 push	 edx
  00460	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00463	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00468	50		 push	 eax
  00469	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  0046c	50		 push	 eax
  0046d	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00470	51		 push	 ecx
  00471	8d 95 2c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00477	52		 push	 edx
  00478	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0047b	50		 push	 eax
  0047c	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00481	83 c4 18	 add	 esp, 24			; 00000018H
  00484	8b 08		 mov	 ecx, DWORD PTR [eax]
  00486	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00489	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  0048c	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1540 :         _Iosbase.width(0);

  0048f	6a 00		 push	 0
  00491	6a 00		 push	 0
  00493	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00496	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width

; 1541 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  0049b	8b 45 ac	 mov	 eax, DWORD PTR __Fillcount$[ebp]
  0049e	50		 push	 eax
  0049f	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  004a3	51		 push	 ecx
  004a4	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  004a7	52		 push	 edx
  004a8	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  004ab	50		 push	 eax
  004ac	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  004af	51		 push	 ecx
  004b0	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  004b3	52		 push	 edx
  004b4	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  004b9	83 c4 18	 add	 esp, 24			; 00000018H
  004bc	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  004c0	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  004c3	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  004cf	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  004d2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  004d7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1542 :     }

  004da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004e4	59		 pop	 ecx
  004e5	5b		 pop	 ebx
  004e6	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004e9	33 cd		 xor	 ecx, ebp
  004eb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004f0	8b e5		 mov	 esp, ebp
  004f2	5d		 pop	 ebp
  004f3	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$0:
  00000	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$2:
  00013	8d 8d 5c ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00019	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z$3:
  0001e	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00021	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00026	cc		 int	 3
  00027	cc		 int	 3
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
__ehhandler$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z:
  0002b	90		 npad	 1
  0002c	90		 npad	 1
  0002d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00031	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00034	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0003a	33 c8		 xor	 ecx, eax
  0003c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00041	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00044	33 c8		 xor	 ecx, eax
  00046	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z
  00050	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT ??$isfinite@O@@YA_NO@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
__X$ = 8						; size = 8
??$isfinite@O@@YA_NO@Z PROC				; isfinite<long double>, COMDAT

; 406  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 407  :         return fpclassify(_X) <= 0;

  00004	83 ec 08	 sub	 esp, 8
  00007	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000c	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00011	e8 00 00 00 00	 call	 ?fpclassify@@YAHO@Z	; fpclassify
  00016	83 c4 08	 add	 esp, 8
  00019	85 c0		 test	 eax, eax
  0001b	7f 09		 jg	 SHORT $LN3@isfinite
  0001d	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00024	eb 07		 jmp	 SHORT $LN4@isfinite
$LN3@isfinite:
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@isfinite:
  0002d	0f b6 45 fc	 movzx	 eax, BYTE PTR tv67[ebp]

; 408  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$isfinite@O@@YA_NO@Z ENDP				; isfinite<long double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??$_Float_put_desired_precision@O@std@@YAH_JH@Z
_TEXT	SEGMENT
__Default_precision$1 = -8				; size = 4
__Is_default_float$2 = -4				; size = 1
__Is_hex$ = -3						; size = 1
tv72 = -2						; size = 1
tv65 = -1						; size = 1
__Precision$ = 8					; size = 8
__Float_flags$ = 16					; size = 4
??$_Float_put_desired_precision@O@std@@YAH_JH@Z PROC	; std::_Float_put_desired_precision<long double>, COMDAT

; 1184 : int _Float_put_desired_precision(const streamsize _Precision, const ios_base::fmtflags _Float_flags) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1185 :     // return the effective precision determined by N4950 [facet.num.put.virtuals]/2.1 and printf's rules
; 1186 :     const bool _Is_hex = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00006	81 7d 10 00 30
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 12288 ; 00003000H
  0000d	75 06		 jne	 SHORT $LN10@Float_put_
  0000f	c6 45 ff 01	 mov	 BYTE PTR tv65[ebp], 1
  00013	eb 04		 jmp	 SHORT $LN11@Float_put_
$LN10@Float_put_:
  00015	c6 45 ff 00	 mov	 BYTE PTR tv65[ebp], 0
$LN11@Float_put_:
  00019	8a 45 ff	 mov	 al, BYTE PTR tv65[ebp]
  0001c	88 45 fd	 mov	 BYTE PTR __Is_hex$[ebp], al

; 1187 :     if (_Is_hex) {

  0001f	0f b6 4d fd	 movzx	 ecx, BYTE PTR __Is_hex$[ebp]
  00023	85 c9		 test	 ecx, ecx
  00025	74 07		 je	 SHORT $LN2@Float_put_

; 1188 :         // return the number of hexits needed (after the radix point) to represent the floating-point value exactly
; 1189 :         if constexpr (is_same_v<_Ty, double>) {
; 1190 :             return ((DBL_MANT_DIG - 1) + 3) / 4;
; 1191 :         } else if constexpr (is_same_v<_Ty, long double>) {
; 1192 :             return ((LDBL_MANT_DIG - 1) + 3) / 4;

  00027	b8 0d 00 00 00	 mov	 eax, 13			; 0000000dH
  0002c	eb 56		 jmp	 SHORT $LN6@Float_put_
$LN2@Float_put_:

; 1193 :         } else {
; 1194 :             _STL_INTERNAL_STATIC_ASSERT(false); // unexpected type; shouldn't be float
; 1195 :         }
; 1196 :     }
; 1197 : 
; 1198 :     if (_Precision > 0) {

  0002e	83 7d 0c 00	 cmp	 DWORD PTR __Precision$[ebp+4], 0
  00032	7c 0f		 jl	 SHORT $LN3@Float_put_
  00034	7f 06		 jg	 SHORT $LN14@Float_put_
  00036	83 7d 08 00	 cmp	 DWORD PTR __Precision$[ebp], 0
  0003a	76 07		 jbe	 SHORT $LN3@Float_put_
$LN14@Float_put_:

; 1199 :         return static_cast<int>(_Precision);

  0003c	8b 45 08	 mov	 eax, DWORD PTR __Precision$[ebp]
  0003f	eb 43		 jmp	 SHORT $LN6@Float_put_
  00041	eb 41		 jmp	 SHORT $LN6@Float_put_
$LN3@Float_put_:

; 1200 :     } else if (_Precision == 0) {

  00043	8b 55 08	 mov	 edx, DWORD PTR __Precision$[ebp]
  00046	0b 55 0c	 or	 edx, DWORD PTR __Precision$[ebp+4]
  00049	75 2d		 jne	 SHORT $LN5@Float_put_

; 1201 :         const bool _Is_default_float = _Float_flags == 0;

  0004b	83 7d 10 00	 cmp	 DWORD PTR __Float_flags$[ebp], 0
  0004f	75 06		 jne	 SHORT $LN12@Float_put_
  00051	c6 45 fe 01	 mov	 BYTE PTR tv72[ebp], 1
  00055	eb 04		 jmp	 SHORT $LN13@Float_put_
$LN12@Float_put_:
  00057	c6 45 fe 00	 mov	 BYTE PTR tv72[ebp], 0
$LN13@Float_put_:
  0005b	8a 45 fe	 mov	 al, BYTE PTR tv72[ebp]
  0005e	88 45 fc	 mov	 BYTE PTR __Is_default_float$2[ebp], al

; 1202 :         if (_Is_default_float) {

  00061	0f b6 4d fc	 movzx	 ecx, BYTE PTR __Is_default_float$2[ebp]
  00065	85 c9		 test	 ecx, ecx
  00067	74 09		 je	 SHORT $LN7@Float_put_

; 1203 :             return 1;

  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	eb 14		 jmp	 SHORT $LN6@Float_put_

; 1204 :         } else {

  00070	eb 04		 jmp	 SHORT $LN8@Float_put_
$LN7@Float_put_:

; 1205 :             return 0;

  00072	33 c0		 xor	 eax, eax
  00074	eb 0e		 jmp	 SHORT $LN6@Float_put_
$LN8@Float_put_:

; 1206 :         }
; 1207 :     } else {

  00076	eb 0c		 jmp	 SHORT $LN6@Float_put_
$LN5@Float_put_:

; 1208 :         constexpr int _Default_precision = 6;

  00078	c7 45 f8 06 00
	00 00		 mov	 DWORD PTR __Default_precision$1[ebp], 6

; 1209 :         return _Default_precision;

  0007f	b8 06 00 00 00	 mov	 eax, 6
$LN6@Float_put_:

; 1210 :     }
; 1211 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??$_Float_put_desired_precision@O@std@@YAH_JH@Z ENDP	; std::_Float_put_desired_precision<long double>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
__New_capacity$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 853  :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 854  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 855  : 
; 856  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 857  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 858  :         } else {
; 859  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 860  :         }
; 861  : 
; 862  :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 06		 jbe	 SHORT $LN2@Construct

; 863  :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00021	90		 npad	 1
$LN2@Construct:

; 864  :         }
; 865  : 
; 866  :         auto& _Al       = _Getal();

  00022	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002a	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 867  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B

; 868  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00034	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003b	52		 push	 edx
  0003c	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
  00044	90		 npad	 1

; 869  : 
; 870  :         if (_Count <= _Small_string_capacity) {

  00045	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  00049	77 30		 ja	 SHORT $LN3@Construct

; 871  :             _My_data._Mysize = _Count;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 872  :             _My_data._Myres  = _Small_string_capacity;

  00054	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00057	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 873  : 
; 874  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 875  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 876  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 877  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 878  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 879  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 880  :             } else { // _Strat == _Construct_strategy::_From_string
; 881  : #ifdef _INSERT_STRING_ANNOTATION
; 882  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 883  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 884  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  0005e	6a 10		 push	 16			; 00000010H
  00060	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00063	50		 push	 eax
  00064	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 885  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 886  :             }
; 887  : 
; 888  :             _Proxy._Release();

  00070	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  00078	90		 npad	 1

; 889  :             return;

  00079	eb 78		 jmp	 SHORT $LN1@Construct
$LN3@Construct:

; 890  :         }
; 891  : 
; 892  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  0007b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00083	50		 push	 eax
  00084	6a 0f		 push	 15			; 0000000fH
  00086	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0008f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00092	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 893  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00095	8d 45 f0	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00098	50		 push	 eax
  00099	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  0009c	51		 push	 ecx
  0009d	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  000a2	83 c4 08	 add	 esp, 8
  000a5	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 894  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a8	8d 55 ec	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000b5	83 c4 08	 add	 esp, 8

; 895  : 
; 896  :         _My_data._Mysize = _Count;

  000b8	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000bb	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000be	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 897  :         _My_data._Myres  = _New_capacity;

  000c1	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000c7	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 898  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 899  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 900  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 901  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 902  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 903  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 904  :         } else { // _Strat == _Construct_strategy::_From_string
; 905  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000ca	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000cd	83 c2 01	 add	 edx, 1
  000d0	52		 push	 edx
  000d1	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000d4	50		 push	 eax
  000d5	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000de	83 c4 04	 add	 esp, 4
  000e1	50		 push	 eax
  000e2	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000e7	83 c4 0c	 add	 esp, 12			; 0000000cH

; 906  :         }
; 907  : 
; 908  :         _ASAN_STRING_CREATE(*this);
; 909  :         _Proxy._Release();

  000ea	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000ed	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  000f2	90		 npad	 1
$LN1@Construct:

; 910  :     }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 08 00	 ret	 8
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_capacity$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 853  :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 854  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 855  : 
; 856  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 857  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 858  :         } else {
; 859  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 860  :         }
; 861  : 
; 862  :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 06		 jbe	 SHORT $LN2@Construct

; 863  :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00021	90		 npad	 1
$LN2@Construct:

; 864  :         }
; 865  : 
; 866  :         auto& _Al       = _Getal();

  00022	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002a	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 867  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B

; 868  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00034	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003b	52		 push	 edx
  0003c	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
  00044	90		 npad	 1

; 869  : 
; 870  :         if (_Count <= _Small_string_capacity) {

  00045	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  00049	77 4c		 ja	 SHORT $LN3@Construct

; 871  :             _My_data._Mysize = _Count;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 872  :             _My_data._Myres  = _Small_string_capacity;

  00054	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00057	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 873  : 
; 874  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 875  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 876  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 877  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 878  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  0005e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00061	50		 push	 eax
  00062	8b 4d 08	 mov	 ecx, DWORD PTR __Arg$[ebp]
  00065	51		 push	 ecx
  00066	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0006f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 879  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00072	c6 45 fe 00	 mov	 BYTE PTR $T2[ebp], 0
  00076	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  00079	50		 push	 eax
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0007d	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00080	51		 push	 ecx
  00081	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00086	83 c4 08	 add	 esp, 8

; 880  :             } else { // _Strat == _Construct_strategy::_From_string
; 881  : #ifdef _INSERT_STRING_ANNOTATION
; 882  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 883  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 884  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 885  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 886  :             }
; 887  : 
; 888  :             _Proxy._Release();

  00089	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0008c	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  00091	90		 npad	 1

; 889  :             return;

  00092	e9 95 00 00 00	 jmp	 $LN1@Construct
$LN3@Construct:

; 890  :         }
; 891  : 
; 892  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00097	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0009f	50		 push	 eax
  000a0	6a 0f		 push	 15			; 0000000fH
  000a2	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000ab	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ae	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 893  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  000b1	8d 45 ec	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b8	51		 push	 ecx
  000b9	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  000be	83 c4 08	 add	 esp, 8
  000c1	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 894  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000c4	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000d1	83 c4 08	 add	 esp, 8

; 895  : 
; 896  :         _My_data._Mysize = _Count;

  000d4	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000d7	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000da	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 897  :         _My_data._Myres  = _New_capacity;

  000dd	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000e3	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 898  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 899  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 900  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 901  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 902  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  000e6	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000f1	51		 push	 ecx
  000f2	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000f7	83 c4 04	 add	 esp, 4
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00100	83 c4 0c	 add	 esp, 12			; 0000000cH

; 903  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00103	c6 45 fd 00	 mov	 BYTE PTR $T1[ebp], 0
  00107	8d 55 fd	 lea	 edx, DWORD PTR $T1[ebp]
  0010a	52		 push	 edx
  0010b	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0010e	50		 push	 eax
  0010f	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00114	83 c4 04	 add	 esp, 4
  00117	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00120	83 c4 08	 add	 esp, 8

; 904  :         } else { // _Strat == _Construct_strategy::_From_string
; 905  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 906  :         }
; 907  : 
; 908  :         _ASAN_STRING_CREATE(*this);
; 909  :         _Proxy._Release();

  00123	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00126	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  0012b	90		 npad	 1
$LN1@Construct:

; 910  :     }

  0012c	8b e5		 mov	 esp, ebp
  0012e	5d		 pop	 ebp
  0012f	c2 08 00	 ret	 8
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_capacity$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 1
__Count$ = 12						; size = 4
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>, COMDAT
; _this$ = ecx

; 852  :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 853  :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 854  :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 855  : 
; 856  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 857  :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 858  :         } else {
; 859  :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 860  :         }
; 861  : 
; 862  :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 06		 jbe	 SHORT $LN2@Construct

; 863  :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
  00021	90		 npad	 1
$LN2@Construct:

; 864  :         }
; 865  : 
; 866  :         auto& _Al       = _Getal();

  00022	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002a	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 867  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B

; 868  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00034	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003b	52		 push	 edx
  0003c	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
  00044	90		 npad	 1

; 869  : 
; 870  :         if (_Count <= _Small_string_capacity) {

  00045	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  00049	77 4d		 ja	 SHORT $LN3@Construct

; 871  :             _My_data._Mysize = _Count;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00051	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 872  :             _My_data._Myres  = _Small_string_capacity;

  00054	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00057	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 873  : 
; 874  :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 875  :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);

  0005e	0f b6 45 08	 movzx	 eax, BYTE PTR __Arg$[ebp]
  00062	50		 push	 eax
  00063	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00066	51		 push	 ecx
  00067	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0006a	52		 push	 edx
  0006b	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH

; 876  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00073	c6 45 fe 00	 mov	 BYTE PTR $T2[ebp], 0
  00077	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  0007a	50		 push	 eax
  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0007e	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00081	51		 push	 ecx
  00082	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00087	83 c4 08	 add	 esp, 8

; 877  :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 878  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 879  :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 880  :             } else { // _Strat == _Construct_strategy::_From_string
; 881  : #ifdef _INSERT_STRING_ANNOTATION
; 882  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 883  : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 884  :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 885  : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 886  :             }
; 887  : 
; 888  :             _Proxy._Release();

  0008a	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  00092	90		 npad	 1

; 889  :             return;

  00093	e9 96 00 00 00	 jmp	 $LN1@Construct
$LN3@Construct:

; 890  :         }
; 891  : 
; 892  :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00098	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000a0	50		 push	 eax
  000a1	6a 0f		 push	 15			; 0000000fH
  000a3	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 893  :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  000b2	8d 45 ec	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  000b5	50		 push	 eax
  000b6	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 894  :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000c5	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000cc	50		 push	 eax
  000cd	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000d2	83 c4 08	 add	 esp, 8

; 895  : 
; 896  :         _My_data._Mysize = _Count;

  000d5	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000d8	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000db	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 897  :         _My_data._Myres  = _New_capacity;

  000de	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e1	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000e4	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 898  :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 899  :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);

  000e7	0f b6 55 08	 movzx	 edx, BYTE PTR __Arg$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000f9	83 c4 04	 add	 esp, 4
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 900  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00105	c6 45 fd 00	 mov	 BYTE PTR $T1[ebp], 0
  00109	8d 55 fd	 lea	 edx, DWORD PTR $T1[ebp]
  0010c	52		 push	 edx
  0010d	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00116	83 c4 04	 add	 esp, 4
  00119	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00122	83 c4 08	 add	 esp, 8

; 901  :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 902  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 903  :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 904  :         } else { // _Strat == _Construct_strategy::_From_string
; 905  :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 906  :         }
; 907  : 
; 908  :         _ASAN_STRING_CREATE(*this);
; 909  :         _Proxy._Release();

  00125	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00128	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  0012d	90		 npad	 1
$LN1@Construct:

; 910  :     }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 08 00	 ret	 8
??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00017	90		 npad	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1500 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001b	90		 npad	 1
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1548 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1560 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 271  : _CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 272  :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 273  : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>, COMDAT
; _this$ = ecx

; 1495 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00017	90		 npad	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z
_TEXT	SEGMENT
__Al$ = -36						; size = 4
__Alproxy$ = -32					; size = 4
__Guard$2 = -28						; size = 4
__My_data$ = -24					; size = 4
_this$ = -20						; size = 4
__Proxy$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
_<_Val_1>$ = 16						; size = 4
??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z PROC ; std::vector<int,std::allocator<int> >::_Construct_n<int const *,int const *>, COMDAT
; _this$ = ecx

; 2059 :     _CONSTEXPR20 void _Construct_n(_CRT_GUARDOVERFLOW const size_type _Count, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 2060 :         // Dispatches between the three sized constructions.
; 2061 :         // 1-arg -> value-construction, e.g. vector(5)
; 2062 :         // 2-arg -> fill, e.g. vector(5, "meow")
; 2063 :         // 3-arg -> sized range construction, e.g. vector{"Hello", "Fluffy", "World"}
; 2064 :         auto& _Al       = _Getal();

  00028	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00030	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 2065 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  00033	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B

; 2066 :         auto& _My_data  = _Mypair._Myval2;

  0003a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	89 45 e8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2067 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00040	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 e0	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  00047	52		 push	 edx
  00048	8d 4d f3	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
  00050	90		 npad	 1

; 2068 :         if (_Count != 0) {

  00051	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00055	74 66		 je	 SHORT $LN2@Construct_

; 2069 :             _Buy_nonzero(_Count);

  00057	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero

; 2070 :             _Tidy_guard<vector> _Guard{this};

  00063	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	89 4d e4	 mov	 DWORD PTR __Guard$2[ebp], ecx
  00069	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2071 :             if constexpr (sizeof...(_Val) == 0) {
; 2072 :                 _My_data._Mylast = _STD _Uninitialized_value_construct_n(_My_data._Myfirst, _Count, _Al);
; 2073 :             } else if constexpr (sizeof...(_Val) == 1) {
; 2074 :                 _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Valty..., const _Ty&>);
; 2075 :                 _My_data._Mylast = _STD _Uninitialized_fill_n(_My_data._Myfirst, _Count, _Val..., _Al);
; 2076 :             } else if constexpr (sizeof...(_Val) == 2) {
; 2077 :                 _My_data._Mylast = _STD _Uninitialized_copy(_STD forward<_Valty>(_Val)..., _My_data._Myfirst, _Al);

  00070	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00073	52		 push	 edx
  00074	8b 45 e8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 08		 mov	 ecx, DWORD PTR [eax]
  00079	51		 push	 ecx
  0007a	8b 55 10	 mov	 edx, DWORD PTR _<_Val_1>$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ??$forward@PBH@std@@YA$$QAPBHAAPBH@Z ; std::forward<int const *>
  00083	83 c4 04	 add	 esp, 4
  00086	8b 00		 mov	 eax, DWORD PTR [eax]
  00088	50		 push	 eax
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ??$forward@PBH@std@@YA$$QAPBHAAPBH@Z ; std::forward<int const *>
  00092	83 c4 04	 add	 esp, 4
  00095	8b 10		 mov	 edx, DWORD PTR [eax]
  00097	52		 push	 edx
  00098	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBHPBHV?$allocator@H@std@@@std@@YAPAHPBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,int const *,std::allocator<int> >
  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	8b 4d e8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000a3	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 2078 :             } else {
; 2079 :                 _STL_INTERNAL_STATIC_ASSERT(false); // unexpected number of arguments
; 2080 :             }
; 2081 :             _ASAN_VECTOR_CREATE;
; 2082 :             _Guard._Target = nullptr;

  000a6	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Guard$2[ebp], 0

; 2083 :         }

  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b4	8d 4d e4	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  000b7	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  000bc	90		 npad	 1
$LN2@Construct_:

; 2084 : 
; 2085 :         _Proxy._Release();

  000bd	8d 4d f3	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000c0	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
  000c5	90		 npad	 1

; 2086 :     }

  000c6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d0	59		 pop	 ecx
  000d1	8b e5		 mov	 esp, ebp
  000d3	5d		 pop	 ebp
  000d4	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z$0:
  00000	8d 4d e4	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Construct_n<int const *,int const *>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 1084 :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1085 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1086 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1087 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1088 : 
; 1089 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1090 :         if (_Len > _STD _Max_limit<_Size_type>()) {
; 1091 :             _Xlength_error("size is too long for _Size_type");
; 1092 :         }
; 1093 :     }
; 1094 : 
; 1095 :     return static_cast<_Size_type>(_Len);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1096 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 1500 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  0001b	90		 npad	 1
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@PAHPAHPAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAPAH22@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
_<_Val2_1>$ = 20					; size = 4
_<_Val2_2>$ = 24					; size = 4
??$?0V?$allocator@H@std@@PAHPAHPAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAPAH22@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>, COMDAT
; _this$ = ecx

; 1500 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d 18	 mov	 ecx, DWORD PTR _<_Val2_2>$[ebp]
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ??$forward@PAH@std@@YA$$QAPAHAAPAH@Z ; std::forward<int *>
  0001c	83 c4 04	 add	 esp, 4
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	8b 45 14	 mov	 eax, DWORD PTR _<_Val2_1>$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$forward@PAH@std@@YA$$QAPAHAAPAH@Z ; std::forward<int *>
  0002b	83 c4 04	 add	 esp, 4
  0002e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00030	51		 push	 ecx
  00031	8b 55 10	 mov	 edx, DWORD PTR _<_Val2_0>$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$forward@PAH@std@@YA$$QAPAHAAPAH@Z ; std::forward<int *>
  0003a	83 c4 04	 add	 esp, 4
  0003d	8b 00		 mov	 eax, DWORD PTR [eax]
  0003f	50		 push	 eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@PAH00@Z ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00048	90		 npad	 1
  00049	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 14 00	 ret	 20			; 00000014H
??$?0V?$allocator@H@std@@PAHPAHPAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAPAH22@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\utility
;	COMDAT ??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z PROC	; std::exchange<int *,std::nullptr_t>, COMDAT

; 751  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 752  :     // assign _New_val to _Val, return previous _Val
; 753  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 754  :     _Val         = static_cast<_Other&&>(_New_val);

  0000c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 755  :     return _Old_val;

  00016	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 756  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z ENDP	; std::exchange<int *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::move<std::allocator<int> &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1548 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::move<std::allocator<int> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??$_Emplace_one_at_back@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z
_TEXT	SEGMENT
__Mylast$ = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
_<_Val_0>$ = 8						; size = 4
??$_Emplace_one_at_back@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int>, COMDAT
; _this$ = ecx

; 770  :     _CONSTEXPR20 _Ty& _Emplace_one_at_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 771  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 772  :         auto& _My_data   = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 773  :         pointer& _Mylast = _My_data._Mylast;

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	83 c1 04	 add	 ecx, 4
  00015	89 4d f4	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 774  : 
; 775  :         if (_Mylast != _My_data._Myend) {

  00018	8b 55 f4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0001b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0001e	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00020	3b 48 08	 cmp	 ecx, DWORD PTR [eax+8]
  00023	74 17		 je	 SHORT $LN2@Emplace_on

; 776  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00025	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  00028	52		 push	 edx
  00029	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
  0003a	eb 1b		 jmp	 SHORT $LN1@Emplace_on
$LN2@Emplace_on:

; 777  :         }
; 778  : 
; 779  :         return *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	52		 push	 edx
  0004f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
$LN1@Emplace_on:

; 780  :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 04 00	 ret	 4
??$_Emplace_one_at_back@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z
_TEXT	SEGMENT
__Obj$2 = -40						; size = 8
__Al$3 = -32						; size = 4
__My_data$ = -28					; size = 4
__Whereptr$ = -24					; size = 4
_this$ = -20						; size = 4
__Oldlast$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
_<_Val_0>$ = 16						; size = 4
??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::emplace<int>, COMDAT
; _this$ = ecx

; 963  :     _CONSTEXPR20 iterator emplace(const_iterator _Where, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 964  :         // insert by perfectly forwarding _Val at _Where
; 965  :         const pointer _Whereptr = _Where._Ptr;

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]
  0002b	89 45 e8	 mov	 DWORD PTR __Whereptr$[ebp], eax

; 966  :         auto& _My_data          = _Mypair._Myval2;

  0002e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	89 4d e4	 mov	 DWORD PTR __My_data$[ebp], ecx

; 967  :         const pointer _Oldlast  = _My_data._Mylast;

  00034	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00037	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003a	89 45 f0	 mov	 DWORD PTR __Oldlast$[ebp], eax

; 968  : #if _ITERATOR_DEBUG_LEVEL == 2
; 969  :         _STL_VERIFY(
; 970  :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Oldlast >= _Whereptr,
; 971  :             "vector emplace iterator outside range");
; 972  : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 973  : 
; 974  :         if (_Oldlast != _My_data._Myend) {

  0003d	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00040	8b 55 f0	 mov	 edx, DWORD PTR __Oldlast$[ebp]
  00043	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  00046	0f 84 ef 00 00
	00		 je	 $LN2@emplace

; 975  :             if (_Whereptr == _Oldlast) { // at back, provide strong guarantee

  0004c	8b 45 e8	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0004f	3b 45 f0	 cmp	 eax, DWORD PTR __Oldlast$[ebp]
  00052	75 1b		 jne	 SHORT $LN3@emplace

; 976  :                 _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Val_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  0005d	83 c4 04	 add	 esp, 4
  00060	50		 push	 eax
  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_back_with_unused_capacity<int>
  00069	90		 npad	 1

; 977  :             } else {

  0006a	e9 b7 00 00 00	 jmp	 $LN4@emplace
$LN3@emplace:

; 978  :                 auto& _Al = _Getal();

  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00077	89 45 e0	 mov	 DWORD PTR __Al$3[ebp], eax

; 979  :                 _Alloc_temporary2<_Alty> _Obj(_Al, _STD forward<_Valty>(_Val)...); // handle aliasing

  0007a	8b 55 10	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00083	83 c4 04	 add	 esp, 4
  00086	50		 push	 eax
  00087	8b 45 e0	 mov	 eax, DWORD PTR __Al$3[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d d8	 lea	 ecx, DWORD PTR __Obj$2[ebp]
  0008e	e8 00 00 00 00	 call	 ??$?0H@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@AAV?$allocator@H@1@$$QAH@Z ; std::_Alloc_temporary2<std::allocator<int> >::_Alloc_temporary2<std::allocator<int> ><int>
  00093	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 980  :                 // after constructing _Obj, provide basic guarantee
; 981  :                 _Orphan_range(_Whereptr, _Oldlast);

  0009a	8b 4d f0	 mov	 ecx, DWORD PTR __Oldlast$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  000a1	52		 push	 edx
  000a2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Orphan_range

; 982  :                 _ASAN_VECTOR_EXTEND_GUARD(static_cast<size_type>(_Oldlast - _My_data._Myfirst) + 1);
; 983  :                 _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));

  000aa	b8 04 00 00 00	 mov	 eax, 4
  000af	6b c8 ff	 imul	 ecx, eax, -1
  000b2	03 4d f0	 add	 ecx, DWORD PTR __Oldlast$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  000bb	83 c4 04	 add	 esp, 4
  000be	50		 push	 eax
  000bf	8b 55 f0	 mov	 edx, DWORD PTR __Oldlast$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c8	83 c4 04	 add	 esp, 4
  000cb	50		 push	 eax
  000cc	8b 45 e0	 mov	 eax, DWORD PTR __Al$3[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ??$construct@HH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAH$$QAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int>
  000d5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 984  :                 _ASAN_VECTOR_RELEASE_GUARD;
; 985  :                 ++_My_data._Mylast;

  000d8	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000de	83 c2 04	 add	 edx, 4
  000e1	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e4	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 986  :                 _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);

  000e7	8b 4d f0	 mov	 ecx, DWORD PTR __Oldlast$[ebp]
  000ea	51		 push	 ecx
  000eb	8b 55 f0	 mov	 edx, DWORD PTR __Oldlast$[ebp]
  000ee	83 ea 04	 sub	 edx, 4
  000f1	52		 push	 edx
  000f2	8b 45 e8	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  000f5	50		 push	 eax
  000f6	e8 00 00 00 00	 call	 ??$_Move_backward_unchecked@PAHPAH@std@@YAPAHPAH00@Z ; std::_Move_backward_unchecked<int *,int *>
  000fb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 987  :                 *_Whereptr = _STD move(_Obj._Get_value());

  000fe	8d 4d d8	 lea	 ecx, DWORD PTR __Obj$2[ebp]
  00101	e8 00 00 00 00	 call	 ?_Get_value@?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAEAAHXZ ; std::_Alloc_temporary2<std::allocator<int> >::_Get_value
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  0010c	83 c4 04	 add	 esp, 4
  0010f	8b 4d e8	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00112	8b 10		 mov	 edx, DWORD PTR [eax]
  00114	89 11		 mov	 DWORD PTR [ecx], edx

; 988  :             }

  00116	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0011d	8d 4d d8	 lea	 ecx, DWORD PTR __Obj$2[ebp]
  00120	e8 00 00 00 00	 call	 ??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Alloc_temporary2<std::allocator<int> >::~_Alloc_temporary2<std::allocator<int> >
  00125	90		 npad	 1
$LN4@emplace:

; 989  : 
; 990  :             return _Make_iterator(_Whereptr);

  00126	8b 45 e8	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00129	50		 push	 eax
  0012a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0012d	51		 push	 ecx
  0012e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z ; std::vector<int,std::allocator<int> >::_Make_iterator
  00136	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00139	eb 29		 jmp	 SHORT $LN1@emplace
$LN2@emplace:

; 991  :         }
; 992  : 
; 993  :         return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward<_Valty>(_Val)...));

  0013b	8b 55 10	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  0013e	52		 push	 edx
  0013f	e8 00 00 00 00	 call	 ??$forward@H@std@@YA$$QAHAAH@Z ; std::forward<int>
  00144	83 c4 04	 add	 esp, 4
  00147	50		 push	 eax
  00148	8b 45 e8	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0014b	50		 push	 eax
  0014c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0014f	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@H@?$vector@HV?$allocator@H@std@@@std@@AAEPAHQAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_reallocate<int>
  00154	50		 push	 eax
  00155	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00158	51		 push	 ecx
  00159	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z ; std::vector<int,std::allocator<int> >::_Make_iterator
  00161	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@emplace:

; 994  :     }

  00164	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00167	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016e	59		 pop	 ecx
  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Obj$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Alloc_temporary2@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Alloc_temporary2<std::allocator<int> >::~_Alloc_temporary2<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::emplace<int>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$move@AAH@std@@YA$$QAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAH@std@@YA$$QAHAAH@Z PROC			; std::move<int &>, COMDAT

; 1546 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1547 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1548 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAH@std@@YA$$QAHAAH@Z ENDP			; std::move<int &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 1558 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1559 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1560 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\iterator
;	COMDAT ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed, COMDAT
; _this$ = ecx

; 547  :     _NODISCARD bool failed() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 548  :         return _Failed;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 00	 movzx	 eax, BYTE PTR [eax]

; 549  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\iterator
;	COMDAT ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++, COMDAT
; _this$ = ecx

; 539  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 540  :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 541  :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\iterator
;	COMDAT ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*, COMDAT
; _this$ = ecx

; 535  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 536  :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 537  :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\iterator
;	COMDAT ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 1
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=, COMDAT
; _this$ = ecx

; 527  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 26		 je	 SHORT $LN3@operator
  00010	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Right$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00018	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  0001b	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  00020	50		 push	 eax
  00021	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0002c	83 c4 08	 add	 esp, 8
  0002f	0f b6 c0	 movzx	 eax, al
  00032	85 c0		 test	 eax, eax
  00034	74 06		 je	 SHORT $LN2@operator
$LN3@operator:

; 529  :             _Failed = true;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	c6 01 01	 mov	 BYTE PTR [ecx], 1
$LN2@operator:

; 530  :         }
; 531  : 
; 532  :         return *this;

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 533  :     }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\iterator
;	COMDAT ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Sb$ = 8						; size = 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z PROC ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 523  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 524  : 
; 525  :     ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Strbuf(_Ostr.rdbuf()) {}
; 526  : 
; 527  :     ostreambuf_iterator& operator=(_Elem _Right) { // store element and increment
; 528  :         if (!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right))) {
; 529  :             _Failed = true;
; 530  :         }
; 531  : 
; 532  :         return *this;
; 533  :     }
; 534  : 
; 535  :     _NODISCARD ostreambuf_iterator& operator*() noexcept /* strengthened */ {
; 536  :         return *this;
; 537  :     }
; 538  : 
; 539  :     ostreambuf_iterator& operator++() noexcept /* strengthened */ {
; 540  :         return *this;
; 541  :     }
; 542  : 
; 543  :     ostreambuf_iterator& operator++(int) noexcept /* strengthened */ {
; 544  :         return *this;
; 545  :     }
; 546  : 
; 547  :     _NODISCARD bool failed() const noexcept {
; 548  :         return _Failed;
; 549  :     }
; 550  : 
; 551  : private:
; 552  :     bool _Failed = false; // true if any stores have failed

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c6 00 00	 mov	 BYTE PTR [eax], 0

; 523  :     ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb) {}

  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 55 08	 mov	 edx, DWORD PTR __Sb$[ebp]
  00013	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ENDP ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAEPAXI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ch$ = 24						; size = 1
__Count$ = 28						; size = 4
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep, COMDAT

; 1637 :     _OutIt __CLRCALL_OR_CDECL _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const { // put _Count * _Ch to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1638 :         for (; 0 < _Count; --_Count, (void) ++_Dest) {

  00003	eb 12		 jmp	 SHORT $LN4@Rep
$LN2@Rep:
  00005	8b 45 1c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 1c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
  00016	90		 npad	 1
$LN4@Rep:
  00017	83 7d 1c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0001b	76 17		 jbe	 SHORT $LN3@Rep

; 1639 :             *_Dest = _Ch;

  0001d	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00021	51		 push	 ecx
  00022	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00025	e8 00 00 00 00	 call	 ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
  0002a	8b c8		 mov	 ecx, eax
  0002c	e8 00 00 00 00	 call	 ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
  00031	90		 npad	 1

; 1640 :         }

  00032	eb d1		 jmp	 SHORT $LN2@Rep
$LN3@Rep:

; 1641 : 
; 1642 :         return _Dest;

  00034	8b 55 0c	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00037	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003a	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  0003d	89 02		 mov	 DWORD PTR [edx], eax
  0003f	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00042	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1643 :     }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z
_TEXT	SEGMENT
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Ptr$ = 24						; size = 4
__Count$ = 28						; size = 4
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put, COMDAT

; 1629 :         _OutIt _Dest, const _Elem* _Ptr, size_t _Count) const { // put [_Ptr, _Ptr + _Count) to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1630 :         for (; 0 < _Count; --_Count, (void) ++_Dest, ++_Ptr) {

  00003	eb 1a		 jmp	 SHORT $LN4@Put
$LN2@Put:
  00005	8b 45 1c	 mov	 eax, DWORD PTR __Count$[ebp]
  00008	83 e8 01	 sub	 eax, 1
  0000b	89 45 1c	 mov	 DWORD PTR __Count$[ebp], eax
  0000e	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00011	e8 00 00 00 00	 call	 ??E?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator++
  00016	8b 4d 18	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00019	83 c1 01	 add	 ecx, 1
  0001c	89 4d 18	 mov	 DWORD PTR __Ptr$[ebp], ecx
$LN4@Put:
  0001f	83 7d 1c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00023	76 19		 jbe	 SHORT $LN3@Put

; 1631 :             *_Dest = *_Ptr;

  00025	8b 55 18	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00028	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002b	50		 push	 eax
  0002c	8d 4d 10	 lea	 ecx, DWORD PTR __Dest$[ebp]
  0002f	e8 00 00 00 00	 call	 ??D?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@XZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator*
  00034	8b c8		 mov	 ecx, eax
  00036	e8 00 00 00 00	 call	 ??4?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAEAAV01@D@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::operator=
  0003b	90		 npad	 1

; 1632 :         }

  0003c	eb c7		 jmp	 SHORT $LN2@Put
$LN3@Put:

; 1633 : 
; 1634 :         return _Dest;

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00041	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00044	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00047	89 11		 mov	 DWORD PTR [ecx], edx
  00049	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0004c	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1635 :     }

  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
_TEXT	SEGMENT
$T2 = -184						; size = 8
$T3 = -176						; size = 8
$T4 = -168						; size = 8
$T5 = -160						; size = 8
$T6 = -152						; size = 8
$T7 = -144						; size = 8
$T8 = -136						; size = 8
$T9 = -128						; size = 8
tv318 = -120						; size = 8
tv266 = -112						; size = 4
tv131 = -108						; size = 4
__Ctype_fac$ = -104					; size = 4
tv263 = -100						; size = 4
tv270 = -96						; size = 4
__Punct_fac$ = -92					; size = 4
tv69 = -88						; size = 4
__Adjustfield$ = -84					; size = 4
__Fillcount$ = -80					; size = 4
__Kseparator$10 = -73					; size = 1
__Pg$ = -72						; size = 4
__Prefix$ = -68						; size = 4
__Grouping$ = -64					; size = 24
__Groupstring$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_this$ = 8						; size = 4
___$ReturnUdt$ = 12					; size = 4
__Dest$ = 16						; size = 8
__Iosbase$ = 24						; size = 4
__Fill$ = 28						; size = 1
__Buf$ = 32						; size = 4
__Count$ = 36						; size = 4
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput, COMDAT

; 1575 :         size_t _Count) const { // put formatted integer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec ac 00 00
	00		 sub	 esp, 172		; 000000acH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 1576 :         auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));

  0002b	83 7d 24 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0002f	76 1f		 jbe	 SHORT $LN17@Iput
  00031	8b 45 20	 mov	 eax, DWORD PTR __Buf$[ebp]
  00034	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00037	83 f9 2b	 cmp	 ecx, 43			; 0000002bH
  0003a	74 0b		 je	 SHORT $LN16@Iput
  0003c	8b 55 20	 mov	 edx, DWORD PTR __Buf$[ebp]
  0003f	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00042	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00045	75 09		 jne	 SHORT $LN17@Iput
$LN16@Iput:
  00047	c7 45 a8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0004e	eb 07		 jmp	 SHORT $LN18@Iput
$LN17@Iput:
  00050	c7 45 a8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN18@Iput:
  00057	8b 4d a8	 mov	 ecx, DWORD PTR tv69[ebp]
  0005a	89 4d bc	 mov	 DWORD PTR __Prefix$[ebp], ecx

; 1577 :         if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
; 1578 :             && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X')) {

  0005d	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00060	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00065	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  0006a	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  0006f	75 40		 jne	 SHORT $LN4@Iput
  00071	8b 55 bc	 mov	 edx, DWORD PTR __Prefix$[ebp]
  00074	83 c2 02	 add	 edx, 2
  00077	3b 55 24	 cmp	 edx, DWORD PTR __Count$[ebp]
  0007a	77 35		 ja	 SHORT $LN4@Iput
  0007c	8b 45 20	 mov	 eax, DWORD PTR __Buf$[ebp]
  0007f	03 45 bc	 add	 eax, DWORD PTR __Prefix$[ebp]
  00082	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00085	83 f9 30	 cmp	 ecx, 48			; 00000030H
  00088	75 27		 jne	 SHORT $LN4@Iput
  0008a	8b 55 20	 mov	 edx, DWORD PTR __Buf$[ebp]
  0008d	03 55 bc	 add	 edx, DWORD PTR __Prefix$[ebp]
  00090	0f be 42 01	 movsx	 eax, BYTE PTR [edx+1]
  00094	83 f8 78	 cmp	 eax, 120		; 00000078H
  00097	74 0f		 je	 SHORT $LN5@Iput
  00099	8b 4d 20	 mov	 ecx, DWORD PTR __Buf$[ebp]
  0009c	03 4d bc	 add	 ecx, DWORD PTR __Prefix$[ebp]
  0009f	0f be 51 01	 movsx	 edx, BYTE PTR [ecx+1]
  000a3	83 fa 58	 cmp	 edx, 88			; 00000058H
  000a6	75 09		 jne	 SHORT $LN4@Iput
$LN5@Iput:

; 1579 :             _Prefix += 2;

  000a8	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  000ab	83 c0 02	 add	 eax, 2
  000ae	89 45 bc	 mov	 DWORD PTR __Prefix$[ebp], eax
$LN4@Iput:

; 1580 :         }
; 1581 : 
; 1582 :         const ctype<_Elem>& _Ctype_fac = _STD use_facet<ctype<_Elem>>(_Iosbase.getloc());

  000b1	8d 4d 80	 lea	 ecx, DWORD PTR $T9[ebp]
  000b4	51		 push	 ecx
  000b5	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  000b8	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000bd	89 45 a0	 mov	 DWORD PTR tv270[ebp], eax
  000c0	8b 55 a0	 mov	 edx, DWORD PTR tv270[ebp]
  000c3	89 55 9c	 mov	 DWORD PTR tv263[ebp], edx
  000c6	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000cd	8b 45 9c	 mov	 eax, DWORD PTR tv263[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000d6	83 c4 04	 add	 esp, 4
  000d9	89 45 98	 mov	 DWORD PTR __Ctype_fac$[ebp], eax
  000dc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e3	8d 4d 80	 lea	 ecx, DWORD PTR $T9[ebp]
  000e6	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  000eb	90		 npad	 1

; 1583 :         basic_string<_Elem> _Groupstring(_Count, _Elem(0)); // reserve space

  000ec	6a 00		 push	 0
  000ee	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  000f1	51		 push	 ecx
  000f2	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  000f5	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000fa	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1584 :         _Ctype_fac.widen(_Buf, _Buf + _Count, &_Groupstring[0]);

  00101	6a 00		 push	 0
  00103	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00106	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0010b	50		 push	 eax
  0010c	8b 55 20	 mov	 edx, DWORD PTR __Buf$[ebp]
  0010f	03 55 24	 add	 edx, DWORD PTR __Count$[ebp]
  00112	52		 push	 edx
  00113	8b 45 20	 mov	 eax, DWORD PTR __Buf$[ebp]
  00116	50		 push	 eax
  00117	8b 4d 98	 mov	 ecx, DWORD PTR __Ctype_fac$[ebp]
  0011a	e8 00 00 00 00	 call	 ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ; std::ctype<char>::widen
  0011f	90		 npad	 1

; 1585 : 
; 1586 :         const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00120	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00126	51		 push	 ecx
  00127	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0012a	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  0012f	89 45 94	 mov	 DWORD PTR tv131[ebp], eax
  00132	8b 55 94	 mov	 edx, DWORD PTR tv131[ebp]
  00135	89 55 90	 mov	 DWORD PTR tv266[ebp], edx
  00138	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  0013c	8b 45 90	 mov	 eax, DWORD PTR tv266[ebp]
  0013f	50		 push	 eax
  00140	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  00145	83 c4 04	 add	 esp, 4
  00148	89 45 a4	 mov	 DWORD PTR __Punct_fac$[ebp], eax
  0014b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0014f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00155	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0015a	90		 npad	 1

; 1587 :         const string _Grouping = _Punct_fac.grouping();

  0015b	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0015e	51		 push	 ecx
  0015f	8b 4d a4	 mov	 ecx, DWORD PTR __Punct_fac$[ebp]
  00162	e8 00 00 00 00	 call	 ?grouping@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::grouping
  00167	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3

; 1588 :         const char* _Pg        = &_Grouping[0];

  0016b	6a 00		 push	 0
  0016d	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  00170	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00175	89 45 b8	 mov	 DWORD PTR __Pg$[ebp], eax

; 1589 :         if (*_Pg != CHAR_MAX && '\0' < *_Pg) { // grouping specified, add thousands separators

  00178	8b 55 b8	 mov	 edx, DWORD PTR __Pg$[ebp]
  0017b	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0017e	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  00181	74 7a		 je	 SHORT $LN3@Iput
  00183	8b 4d b8	 mov	 ecx, DWORD PTR __Pg$[ebp]
  00186	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00189	85 d2		 test	 edx, edx
  0018b	7e 70		 jle	 SHORT $LN3@Iput

; 1590 :             const _Elem _Kseparator = _Punct_fac.thousands_sep();

  0018d	8b 4d a4	 mov	 ecx, DWORD PTR __Punct_fac$[ebp]
  00190	e8 00 00 00 00	 call	 ?thousands_sep@?$numpunct@D@std@@QBEDXZ ; std::numpunct<char>::thousands_sep
  00195	88 45 b7	 mov	 BYTE PTR __Kseparator$10[ebp], al
$LN2@Iput:

; 1591 :             while (*_Pg != CHAR_MAX && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix) {

  00198	8b 45 b8	 mov	 eax, DWORD PTR __Pg$[ebp]
  0019b	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0019e	83 f9 7f	 cmp	 ecx, 127		; 0000007fH
  001a1	74 5a		 je	 SHORT $LN3@Iput
  001a3	8b 55 b8	 mov	 edx, DWORD PTR __Pg$[ebp]
  001a6	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001a9	85 c0		 test	 eax, eax
  001ab	7e 50		 jle	 SHORT $LN3@Iput
  001ad	8b 4d b8	 mov	 ecx, DWORD PTR __Pg$[ebp]
  001b0	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001b3	8b 45 24	 mov	 eax, DWORD PTR __Count$[ebp]
  001b6	2b 45 bc	 sub	 eax, DWORD PTR __Prefix$[ebp]
  001b9	3b d0		 cmp	 edx, eax
  001bb	73 40		 jae	 SHORT $LN3@Iput

; 1592 :                 // insert thousands separator
; 1593 :                 _Count -= *_Pg;

  001bd	8b 4d b8	 mov	 ecx, DWORD PTR __Pg$[ebp]
  001c0	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001c3	8b 45 24	 mov	 eax, DWORD PTR __Count$[ebp]
  001c6	2b c2		 sub	 eax, edx
  001c8	89 45 24	 mov	 DWORD PTR __Count$[ebp], eax

; 1594 :                 _Groupstring.insert(_Count, 1, _Kseparator);

  001cb	0f b6 4d b7	 movzx	 ecx, BYTE PTR __Kseparator$10[ebp]
  001cf	51		 push	 ecx
  001d0	6a 01		 push	 1
  001d2	8b 55 24	 mov	 edx, DWORD PTR __Count$[ebp]
  001d5	52		 push	 edx
  001d6	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  001d9	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  001de	90		 npad	 1

; 1595 :                 if ('\0' < _Pg[1]) {

  001df	b8 01 00 00 00	 mov	 eax, 1
  001e4	c1 e0 00	 shl	 eax, 0
  001e7	8b 4d b8	 mov	 ecx, DWORD PTR __Pg$[ebp]
  001ea	0f be 14 01	 movsx	 edx, BYTE PTR [ecx+eax]
  001ee	85 d2		 test	 edx, edx
  001f0	7e 09		 jle	 SHORT $LN7@Iput

; 1596 :                     ++_Pg; // not last group, advance

  001f2	8b 45 b8	 mov	 eax, DWORD PTR __Pg$[ebp]
  001f5	83 c0 01	 add	 eax, 1
  001f8	89 45 b8	 mov	 DWORD PTR __Pg$[ebp], eax
$LN7@Iput:

; 1597 :                 }
; 1598 :             }

  001fb	eb 9b		 jmp	 SHORT $LN2@Iput
$LN3@Iput:

; 1599 :         }
; 1600 : 
; 1601 :         _Count = _Groupstring.size();

  001fd	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00200	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00205	89 45 24	 mov	 DWORD PTR __Count$[ebp], eax

; 1602 : 
; 1603 :         size_t _Fillcount;
; 1604 :         if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count) {

  00208	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0020b	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00210	89 45 88	 mov	 DWORD PTR tv318[ebp], eax
  00213	89 55 8c	 mov	 DWORD PTR tv318[ebp+4], edx
  00216	83 7d 8c 00	 cmp	 DWORD PTR tv318[ebp+4], 0
  0021a	7c 15		 jl	 SHORT $LN10@Iput
  0021c	7f 06		 jg	 SHORT $LN23@Iput
  0021e	83 7d 88 00	 cmp	 DWORD PTR tv318[ebp], 0
  00222	76 0d		 jbe	 SHORT $LN10@Iput
$LN23@Iput:
  00224	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00227	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  0022c	3b 45 24	 cmp	 eax, DWORD PTR __Count$[ebp]
  0022f	77 09		 ja	 SHORT $LN8@Iput
$LN10@Iput:

; 1605 :             _Fillcount = 0;

  00231	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1606 :         } else {

  00238	eb 0e		 jmp	 SHORT $LN9@Iput
$LN8@Iput:

; 1607 :             _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;

  0023a	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0023d	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00242	2b 45 24	 sub	 eax, DWORD PTR __Count$[ebp]
  00245	89 45 b0	 mov	 DWORD PTR __Fillcount$[ebp], eax
$LN9@Iput:

; 1608 :         }
; 1609 : 
; 1610 :         ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;

  00248	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0024b	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00250	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00255	89 45 ac	 mov	 DWORD PTR __Adjustfield$[ebp], eax

; 1611 :         if (_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal) { // put leading fill

  00258	83 7d ac 40	 cmp	 DWORD PTR __Adjustfield$[ebp], 64 ; 00000040H
  0025c	74 79		 je	 SHORT $LN11@Iput
  0025e	81 7d ac 00 01
	00 00		 cmp	 DWORD PTR __Adjustfield$[ebp], 256 ; 00000100H
  00265	74 70		 je	 SHORT $LN11@Iput

; 1612 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  00267	8b 4d b0	 mov	 ecx, DWORD PTR __Fillcount$[ebp]
  0026a	51		 push	 ecx
  0026b	0f b6 55 1c	 movzx	 edx, BYTE PTR __Fill$[ebp]
  0026f	52		 push	 edx
  00270	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00273	50		 push	 eax
  00274	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00277	51		 push	 ecx
  00278	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0027e	52		 push	 edx
  0027f	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  00282	50		 push	 eax
  00283	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00288	83 c4 18	 add	 esp, 24			; 00000018H
  0028b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0028d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00290	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00293	89 55 14	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1613 :             _Fillcount = 0;

  00296	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1614 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  0029d	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  002a0	50		 push	 eax
  002a1	6a 00		 push	 0
  002a3	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  002a6	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  002ab	50		 push	 eax
  002ac	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  002af	51		 push	 ecx
  002b0	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  002b3	52		 push	 edx
  002b4	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  002ba	50		 push	 eax
  002bb	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  002be	51		 push	 ecx
  002bf	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  002c4	83 c4 18	 add	 esp, 24			; 00000018H
  002c7	8b 10		 mov	 edx, DWORD PTR [eax]
  002c9	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  002cc	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  002cf	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
  002d2	e9 ab 00 00 00	 jmp	 $LN14@Iput
$LN11@Iput:

; 1615 :         } else if (_Adjustfield == ios_base::internal) { // put internal fill

  002d7	81 7d ac 00 01
	00 00		 cmp	 DWORD PTR __Adjustfield$[ebp], 256 ; 00000100H
  002de	75 6d		 jne	 SHORT $LN13@Iput

; 1616 :             _Dest      = _Put(_Dest, &_Groupstring[0], _Prefix);

  002e0	8b 4d bc	 mov	 ecx, DWORD PTR __Prefix$[ebp]
  002e3	51		 push	 ecx
  002e4	6a 00		 push	 0
  002e6	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  002e9	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  002ee	50		 push	 eax
  002ef	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  002f2	52		 push	 edx
  002f3	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  002f6	50		 push	 eax
  002f7	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002fd	51		 push	 ecx
  002fe	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00307	83 c4 18	 add	 esp, 24			; 00000018H
  0030a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0030c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0030f	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00312	89 55 14	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1617 :             _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  00315	8b 45 b0	 mov	 eax, DWORD PTR __Fillcount$[ebp]
  00318	50		 push	 eax
  00319	0f b6 4d 1c	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  0031d	51		 push	 ecx
  0031e	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00321	52		 push	 edx
  00322	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00325	50		 push	 eax
  00326	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0032c	51		 push	 ecx
  0032d	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  00330	52		 push	 edx
  00331	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00336	83 c4 18	 add	 esp, 24			; 00000018H
  00339	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0033e	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00341	89 55 14	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1618 :             _Fillcount = 0;

  00344	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __Fillcount$[ebp], 0

; 1619 :         } else {

  0034b	eb 35		 jmp	 SHORT $LN14@Iput
$LN13@Iput:

; 1620 :             _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

  0034d	8b 45 bc	 mov	 eax, DWORD PTR __Prefix$[ebp]
  00350	50		 push	 eax
  00351	6a 00		 push	 0
  00353	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00356	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  0035b	50		 push	 eax
  0035c	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  0035f	51		 push	 ecx
  00360	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  00363	52		 push	 edx
  00364	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0036a	50		 push	 eax
  0036b	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  0036e	51		 push	 ecx
  0036f	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  00374	83 c4 18	 add	 esp, 24			; 00000018H
  00377	8b 10		 mov	 edx, DWORD PTR [eax]
  00379	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0037c	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx
  0037f	89 45 14	 mov	 DWORD PTR __Dest$[ebp+4], eax
$LN14@Iput:

; 1621 :         }
; 1622 : 
; 1623 :         _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);

  00382	8b 4d 24	 mov	 ecx, DWORD PTR __Count$[ebp]
  00385	2b 4d bc	 sub	 ecx, DWORD PTR __Prefix$[ebp]
  00388	51		 push	 ecx
  00389	8b 55 bc	 mov	 edx, DWORD PTR __Prefix$[ebp]
  0038c	52		 push	 edx
  0038d	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  00390	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  00395	50		 push	 eax
  00396	8b 45 14	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00399	50		 push	 eax
  0039a	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0039d	51		 push	 ecx
  0039e	8d 95 48 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  003a4	52		 push	 edx
  003a5	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  003a8	50		 push	 eax
  003a9	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  003ae	83 c4 18	 add	 esp, 24			; 00000018H
  003b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b3	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  003b6	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  003b9	89 55 14	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1624 :         _Iosbase.width(0);

  003bc	6a 00		 push	 0
  003be	6a 00		 push	 0
  003c0	8b 4d 18	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  003c3	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width

; 1625 :         return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  003c8	8b 45 b0	 mov	 eax, DWORD PTR __Fillcount$[ebp]
  003cb	50		 push	 eax
  003cc	0f b6 4d 1c	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  003d0	51		 push	 ecx
  003d1	8b 55 14	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  003d4	52		 push	 edx
  003d5	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  003d8	50		 push	 eax
  003d9	8b 4d 0c	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  003dc	51		 push	 ecx
  003dd	8b 55 08	 mov	 edx, DWORD PTR _this$[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  003e6	83 c4 18	 add	 esp, 24			; 00000018H
  003e9	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  003ed	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  003f0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  003f5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003fc	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  003ff	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00404	8b 45 0c	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1626 :     }

  00407	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0040a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00411	59		 pop	 ecx
  00412	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00415	33 cd		 xor	 ecx, ebp
  00417	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0041c	8b e5		 mov	 esp, ebp
  0041e	5d		 pop	 ebp
  0041f	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$0:
  00000	8d 4d 80	 lea	 ecx, DWORD PTR $T9[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR __Groupstring$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$2:
  00010	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z$3:
  0001b	8d 4d c0	 lea	 ecx, DWORD PTR __Grouping$[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00023	cc		 int	 3
  00024	cc		 int	 3
  00025	cc		 int	 3
  00026	cc		 int	 3
  00027	cc		 int	 3
__ehhandler$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z:
  00028	90		 npad	 1
  00029	90		 npad	 1
  0002a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0002e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00031	8b 8a 50 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-176]
  00037	33 c8		 xor	 ecx, eax
  00039	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00041	33 c8		 xor	 ecx, eax
  00043	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00048	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z
  0004d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z
_TEXT	SEGMENT
__Basefield$ = -12					; size = 4
__Ptr$ = -8						; size = 4
tv91 = -3						; size = 1
tv90 = -2						; size = 1
tv89 = -1						; size = 1
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 4
__Flags$ = 20						; size = 4
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt, COMDAT

; 1545 :         char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for integer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1546 :         char* _Ptr = _Fmt;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Fmt$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1547 :         *_Ptr++    = '%';

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	c6 01 25	 mov	 BYTE PTR [ecx], 37	; 00000025H
  00012	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00015	83 c2 01	 add	 edx, 1
  00018	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx

; 1548 : 
; 1549 :         if (_Flags & ios_base::showpos) {

  0001b	8b 45 14	 mov	 eax, DWORD PTR __Flags$[ebp]
  0001e	83 e0 20	 and	 eax, 32			; 00000020H
  00021	74 0f		 je	 SHORT $LN2@Ifmt

; 1550 :             *_Ptr++ = '+';

  00023	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	c6 01 2b	 mov	 BYTE PTR [ecx], 43	; 0000002bH
  00029	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	83 c2 01	 add	 edx, 1
  0002f	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN2@Ifmt:

; 1551 :         }
; 1552 : 
; 1553 :         if (_Flags & ios_base::showbase) {

  00032	8b 45 14	 mov	 eax, DWORD PTR __Flags$[ebp]
  00035	83 e0 08	 and	 eax, 8
  00038	74 0f		 je	 SHORT $LN3@Ifmt

; 1554 :             *_Ptr++ = '#';

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003d	c6 01 23	 mov	 BYTE PTR [ecx], 35	; 00000023H
  00040	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00043	83 c2 01	 add	 edx, 1
  00046	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN3@Ifmt:

; 1555 :         }
; 1556 : 
; 1557 :         if (_Spec[0] != 'L') {

  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	6b c8 00	 imul	 ecx, eax, 0
  00051	8b 55 10	 mov	 edx, DWORD PTR __Spec$[ebp]
  00054	0f be 04 0a	 movsx	 eax, BYTE PTR [edx+ecx]
  00058	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  0005b	74 1e		 je	 SHORT $LN4@Ifmt

; 1558 :             *_Ptr++ = _Spec[0]; // qualifier

  0005d	b9 01 00 00 00	 mov	 ecx, 1
  00062	6b d1 00	 imul	 edx, ecx, 0
  00065	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00068	8b 4d 10	 mov	 ecx, DWORD PTR __Spec$[ebp]
  0006b	8a 14 11	 mov	 dl, BYTE PTR [ecx+edx]
  0006e	88 10		 mov	 BYTE PTR [eax], dl
  00070	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00073	83 c0 01	 add	 eax, 1
  00076	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1559 :         } else { // change L to I64

  00079	eb 2d		 jmp	 SHORT $LN5@Ifmt
$LN4@Ifmt:

; 1560 :             *_Ptr++ = 'I';

  0007b	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0007e	c6 01 49	 mov	 BYTE PTR [ecx], 73	; 00000049H
  00081	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00084	83 c2 01	 add	 edx, 1
  00087	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx

; 1561 :             *_Ptr++ = '6';

  0008a	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0008d	c6 00 36	 mov	 BYTE PTR [eax], 54	; 00000036H
  00090	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00093	83 c1 01	 add	 ecx, 1
  00096	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 1562 :             *_Ptr++ = '4';

  00099	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0009c	c6 02 34	 mov	 BYTE PTR [edx], 52	; 00000034H
  0009f	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a2	83 c0 01	 add	 eax, 1
  000a5	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax
$LN5@Ifmt:

; 1563 :         }
; 1564 : 
; 1565 :         ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;

  000a8	8b 4d 14	 mov	 ecx, DWORD PTR __Flags$[ebp]
  000ab	81 e1 00 0e 00
	00		 and	 ecx, 3584		; 00000e00H
  000b1	89 4d f4	 mov	 DWORD PTR __Basefield$[ebp], ecx

; 1566 :         *_Ptr++                       = _Basefield == ios_base::oct  ? 'o'

  000b4	81 7d f4 00 04
	00 00		 cmp	 DWORD PTR __Basefield$[ebp], 1024 ; 00000400H
  000bb	75 06		 jne	 SHORT $LN11@Ifmt
  000bd	c6 45 fd 6f	 mov	 BYTE PTR tv91[ebp], 111	; 0000006fH
  000c1	eb 3a		 jmp	 SHORT $LN12@Ifmt
$LN11@Ifmt:
  000c3	81 7d f4 00 08
	00 00		 cmp	 DWORD PTR __Basefield$[ebp], 2048 ; 00000800H
  000ca	74 13		 je	 SHORT $LN9@Ifmt
  000cc	ba 01 00 00 00	 mov	 edx, 1
  000d1	c1 e2 00	 shl	 edx, 0
  000d4	8b 45 10	 mov	 eax, DWORD PTR __Spec$[ebp]
  000d7	8a 0c 10	 mov	 cl, BYTE PTR [eax+edx]
  000da	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000dd	eb 18		 jmp	 SHORT $LN10@Ifmt
$LN9@Ifmt:
  000df	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  000e2	83 e2 04	 and	 edx, 4
  000e5	74 06		 je	 SHORT $LN7@Ifmt
  000e7	c6 45 ff 58	 mov	 BYTE PTR tv89[ebp], 88	; 00000058H
  000eb	eb 04		 jmp	 SHORT $LN8@Ifmt
$LN7@Ifmt:
  000ed	c6 45 ff 78	 mov	 BYTE PTR tv89[ebp], 120	; 00000078H
$LN8@Ifmt:
  000f1	8a 45 ff	 mov	 al, BYTE PTR tv89[ebp]
  000f4	88 45 fe	 mov	 BYTE PTR tv90[ebp], al
$LN10@Ifmt:
  000f7	8a 4d fe	 mov	 cl, BYTE PTR tv90[ebp]
  000fa	88 4d fd	 mov	 BYTE PTR tv91[ebp], cl
$LN12@Ifmt:
  000fd	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00100	0f b6 45 fd	 movzx	 eax, BYTE PTR tv91[ebp]
  00104	88 02		 mov	 BYTE PTR [edx], al
  00106	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00109	83 c1 01	 add	 ecx, 1
  0010c	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 1567 :                                       : _Basefield != ios_base::hex  ? _Spec[1] // 'd' or 'u'
; 1568 :                                       : _Flags & ios_base::uppercase ? 'X'
; 1569 :                                                                      : 'x';
; 1570 :         *_Ptr                         = '\0';

  0010f	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00112	c6 02 00	 mov	 BYTE PTR [edx], 0

; 1571 :         return _Fmt;

  00115	8b 45 0c	 mov	 eax, DWORD PTR __Fmt$[ebp]

; 1572 :     }

  00118	8b e5		 mov	 esp, ebp
  0011a	5d		 pop	 ebp
  0011b	c3		 ret	 0
?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z
_TEXT	SEGMENT
__Ffl$ = -12						; size = 4
__Ptr$ = -8						; size = 4
__Ch$ = -1						; size = 1
_this$ = 8						; size = 4
__Fmt$ = 12						; size = 4
__Spec$ = 16						; size = 1
__Flags$ = 20						; size = 4
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt, COMDAT

; 1422 :         char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const { // generate sprintf format for floating-point

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1423 :         char* _Ptr = _Fmt;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Fmt$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1424 :         *_Ptr++    = '%';

  0000c	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000f	c6 01 25	 mov	 BYTE PTR [ecx], 37	; 00000025H
  00012	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00015	83 c2 01	 add	 edx, 1
  00018	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx

; 1425 : 
; 1426 :         if (_Flags & ios_base::showpos) {

  0001b	8b 45 14	 mov	 eax, DWORD PTR __Flags$[ebp]
  0001e	83 e0 20	 and	 eax, 32			; 00000020H
  00021	74 0f		 je	 SHORT $LN2@Ffmt

; 1427 :             *_Ptr++ = '+';

  00023	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	c6 01 2b	 mov	 BYTE PTR [ecx], 43	; 0000002bH
  00029	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	83 c2 01	 add	 edx, 1
  0002f	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN2@Ffmt:

; 1428 :         }
; 1429 : 
; 1430 :         if (_Flags & ios_base::showpoint) {

  00032	8b 45 14	 mov	 eax, DWORD PTR __Flags$[ebp]
  00035	83 e0 10	 and	 eax, 16			; 00000010H
  00038	74 0f		 je	 SHORT $LN3@Ffmt

; 1431 :             *_Ptr++ = '#';

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003d	c6 01 23	 mov	 BYTE PTR [ecx], 35	; 00000023H
  00040	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00043	83 c2 01	 add	 edx, 1
  00046	89 55 f8	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN3@Ffmt:

; 1432 :         }
; 1433 : 
; 1434 :         *_Ptr++ = '.';

  00049	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0004c	c6 00 2e	 mov	 BYTE PTR [eax], 46	; 0000002eH
  0004f	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00052	83 c1 01	 add	 ecx, 1
  00055	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx

; 1435 :         *_Ptr++ = '*'; // for precision argument

  00058	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0005b	c6 02 2a	 mov	 BYTE PTR [edx], 42	; 0000002aH
  0005e	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00061	83 c0 01	 add	 eax, 1
  00064	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1436 :         if (_Spec != '\0') {

  00067	0f be 4d 10	 movsx	 ecx, BYTE PTR __Spec$[ebp]
  0006b	85 c9		 test	 ecx, ecx
  0006d	74 11		 je	 SHORT $LN4@Ffmt

; 1437 :             *_Ptr++ = _Spec; // 'L' qualifier for long double only

  0006f	8b 55 f8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00072	8a 45 10	 mov	 al, BYTE PTR __Spec$[ebp]
  00075	88 02		 mov	 BYTE PTR [edx], al
  00077	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0007a	83 c1 01	 add	 ecx, 1
  0007d	89 4d f8	 mov	 DWORD PTR __Ptr$[ebp], ecx
$LN4@Ffmt:

; 1438 :         }
; 1439 : 
; 1440 :         char _Ch; // specifier
; 1441 :         ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;

  00080	8b 55 14	 mov	 edx, DWORD PTR __Flags$[ebp]
  00083	81 e2 00 30 00
	00		 and	 edx, 12288		; 00003000H
  00089	89 55 f4	 mov	 DWORD PTR __Ffl$[ebp], edx

; 1442 :         if (_Flags & ios_base::uppercase) {

  0008c	8b 45 14	 mov	 eax, DWORD PTR __Flags$[ebp]
  0008f	83 e0 04	 and	 eax, 4
  00092	74 33		 je	 SHORT $LN5@Ffmt

; 1443 :             if (_Ffl == ios_base::fixed) {

  00094	81 7d f4 00 20
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 8192 ; 00002000H
  0009b	75 06		 jne	 SHORT $LN7@Ffmt

; 1444 :                 _Ch = 'f';

  0009d	c6 45 ff 66	 mov	 BYTE PTR __Ch$[ebp], 102 ; 00000066H
  000a1	eb 22		 jmp	 SHORT $LN12@Ffmt
$LN7@Ffmt:

; 1445 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

  000a3	81 7d f4 00 30
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 12288 ; 00003000H
  000aa	75 06		 jne	 SHORT $LN9@Ffmt

; 1446 :                 _Ch = 'A';

  000ac	c6 45 ff 41	 mov	 BYTE PTR __Ch$[ebp], 65	; 00000041H
  000b0	eb 13		 jmp	 SHORT $LN12@Ffmt
$LN9@Ffmt:

; 1447 :             } else if (_Ffl == ios_base::scientific) {

  000b2	81 7d f4 00 10
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 4096 ; 00001000H
  000b9	75 06		 jne	 SHORT $LN11@Ffmt

; 1448 :                 _Ch = 'E';

  000bb	c6 45 ff 45	 mov	 BYTE PTR __Ch$[ebp], 69	; 00000045H

; 1449 :             } else {

  000bf	eb 04		 jmp	 SHORT $LN12@Ffmt
$LN11@Ffmt:

; 1450 :                 _Ch = 'G';

  000c1	c6 45 ff 47	 mov	 BYTE PTR __Ch$[ebp], 71	; 00000047H
$LN12@Ffmt:

; 1451 :             }
; 1452 :         } else {

  000c5	eb 31		 jmp	 SHORT $LN18@Ffmt
$LN5@Ffmt:

; 1453 :             if (_Ffl == ios_base::fixed) {

  000c7	81 7d f4 00 20
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 8192 ; 00002000H
  000ce	75 06		 jne	 SHORT $LN13@Ffmt

; 1454 :                 _Ch = 'f';

  000d0	c6 45 ff 66	 mov	 BYTE PTR __Ch$[ebp], 102 ; 00000066H
  000d4	eb 22		 jmp	 SHORT $LN18@Ffmt
$LN13@Ffmt:

; 1455 :             } else if (_Ffl == (ios_base::scientific | ios_base::fixed)) {

  000d6	81 7d f4 00 30
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 12288 ; 00003000H
  000dd	75 06		 jne	 SHORT $LN15@Ffmt

; 1456 :                 _Ch = 'a';

  000df	c6 45 ff 61	 mov	 BYTE PTR __Ch$[ebp], 97	; 00000061H
  000e3	eb 13		 jmp	 SHORT $LN18@Ffmt
$LN15@Ffmt:

; 1457 :             } else if (_Ffl == ios_base::scientific) {

  000e5	81 7d f4 00 10
	00 00		 cmp	 DWORD PTR __Ffl$[ebp], 4096 ; 00001000H
  000ec	75 06		 jne	 SHORT $LN17@Ffmt

; 1458 :                 _Ch = 'e';

  000ee	c6 45 ff 65	 mov	 BYTE PTR __Ch$[ebp], 101 ; 00000065H

; 1459 :             } else {

  000f2	eb 04		 jmp	 SHORT $LN18@Ffmt
$LN17@Ffmt:

; 1460 :                 _Ch = 'g';

  000f4	c6 45 ff 67	 mov	 BYTE PTR __Ch$[ebp], 103 ; 00000067H
$LN18@Ffmt:

; 1461 :             }
; 1462 :         }
; 1463 :         *_Ptr++ = _Ch;

  000f8	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000fb	8a 55 ff	 mov	 dl, BYTE PTR __Ch$[ebp]
  000fe	88 11		 mov	 BYTE PTR [ecx], dl
  00100	8b 45 f8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00103	83 c0 01	 add	 eax, 1
  00106	89 45 f8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 1464 : 
; 1465 :         *_Ptr = '\0';

  00109	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0010c	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 1466 :         return _Fmt;

  0010f	8b 45 0c	 mov	 eax, DWORD PTR __Fmt$[ebp]

; 1467 :     }

  00112	8b e5		 mov	 esp, ebp
  00114	5d		 pop	 ebp
  00115	c3		 ret	 0
?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
__Buf$ = -68						; size = 64
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1413 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const { // put formatted void pointer to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 1414 :         char _Buf[2 * _Max_int_dig];
; 1415 : 
; 1416 :         return _Iput(

  00013	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_02BBAHNLBA@?$CFp@
  0001c	6a 40		 push	 64			; 00000040H
  0001e	8d 4d bc	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 _sprintf_s
  00027	83 c4 10	 add	 esp, 16			; 00000010H
  0002a	50		 push	 eax
  0002b	8d 55 bc	 lea	 edx, DWORD PTR __Buf$[ebp]
  0002e	52		 push	 edx
  0002f	0f b6 45 18	 movzx	 eax, BYTE PTR __Fill$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  0003b	52		 push	 edx
  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  0003f	50		 push	 eax
  00040	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00043	51		 push	 ecx
  00044	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
  0004d	83 c4 20	 add	 esp, 32			; 00000020H
  00050	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1417 :             _Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
; 1418 :     }

  00053	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00056	33 cd		 xor	 ecx, ebp
  00058	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPBX@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
_TEXT	SEGMENT
tv196 = -112						; size = 8
__Ngen$ = -104						; size = 4
__Adjusted_flags$ = -100				; size = 4
__Ptwo$2 = -96						; size = 4
__Desired_precision$ = -92				; size = 4
__Precision$ = -88					; size = 8
tv78 = -80						; size = 8
_this$ = -72						; size = 4
tv139 = -68						; size = 4
__Bufsize$ = -64					; size = 4
__Float_flags$ = -60					; size = 4
__Is_fixed$ = -53					; size = 1
__Is_hex$ = -52						; size = 1
__Is_finite$ = -51					; size = 1
tv73 = -50						; size = 1
tv71 = -49						; size = 1
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1385 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const { // put formatted long double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 1386 :         string _Buf;

  0002b	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1387 :         char _Fmt[8];
; 1388 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0003d	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00042	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00047	89 45 c4	 mov	 DWORD PTR __Float_flags$[ebp], eax

; 1389 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

  0004a	81 7d c4 00 20
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 8192 ; 00002000H
  00051	75 06		 jne	 SHORT $LN4@do_put
  00053	c6 45 cf 01	 mov	 BYTE PTR tv71[ebp], 1
  00057	eb 04		 jmp	 SHORT $LN5@do_put
$LN4@do_put:
  00059	c6 45 cf 00	 mov	 BYTE PTR tv71[ebp], 0
$LN5@do_put:
  0005d	8a 45 cf	 mov	 al, BYTE PTR tv71[ebp]
  00060	88 45 cb	 mov	 BYTE PTR __Is_fixed$[ebp], al

; 1390 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00063	81 7d c4 00 30
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 12288 ; 00003000H
  0006a	75 06		 jne	 SHORT $LN6@do_put
  0006c	c6 45 ce 01	 mov	 BYTE PTR tv73[ebp], 1
  00070	eb 04		 jmp	 SHORT $LN7@do_put
$LN6@do_put:
  00072	c6 45 ce 00	 mov	 BYTE PTR tv73[ebp], 0
$LN7@do_put:
  00076	8a 4d ce	 mov	 cl, BYTE PTR tv73[ebp]
  00079	88 4d cc	 mov	 BYTE PTR __Is_hex$[ebp], cl

; 1391 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  0007c	0f b6 55 cc	 movzx	 edx, BYTE PTR __Is_hex$[ebp]
  00080	85 d2		 test	 edx, edx
  00082	74 0f		 je	 SHORT $LN8@do_put
  00084	83 c8 ff	 or	 eax, -1
  00087	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
  0008e	89 45 b4	 mov	 DWORD PTR tv78[ebp+4], eax
  00091	eb 0e		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  00093	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00096	e8 00 00 00 00	 call	 ?precision@ios_base@std@@QBE_JXZ ; std::ios_base::precision
  0009b	89 45 b0	 mov	 DWORD PTR tv78[ebp], eax
  0009e	89 55 b4	 mov	 DWORD PTR tv78[ebp+4], edx
$LN9@do_put:
  000a1	8b 4d b0	 mov	 ecx, DWORD PTR tv78[ebp]
  000a4	8b 55 b4	 mov	 edx, DWORD PTR tv78[ebp+4]
  000a7	89 4d a8	 mov	 DWORD PTR __Precision$[ebp], ecx
  000aa	89 55 ac	 mov	 DWORD PTR __Precision$[ebp+4], edx

; 1392 :         const int _Desired_precision =

  000ad	8b 45 c4	 mov	 eax, DWORD PTR __Float_flags$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d ac	 mov	 ecx, DWORD PTR __Precision$[ebp+4]
  000b4	51		 push	 ecx
  000b5	8b 55 a8	 mov	 edx, DWORD PTR __Precision$[ebp]
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@O@std@@YAH_JH@Z ; std::_Float_put_desired_precision<long double>
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 45 a4	 mov	 DWORD PTR __Desired_precision$[ebp], eax

; 1393 :             _Float_put_desired_precision<long double>(_Precision, _Float_flags); // desired precision
; 1394 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  000c4	8b 45 a4	 mov	 eax, DWORD PTR __Desired_precision$[ebp]
  000c7	89 45 c0	 mov	 DWORD PTR __Bufsize$[ebp], eax

; 1395 :         if (_Is_fixed && 1e10 < _CSTD fabsl(_Val)) { // f or F format

  000ca	0f b6 4d cb	 movzx	 ecx, BYTE PTR __Is_fixed$[ebp]
  000ce	85 c9		 test	 ecx, ecx
  000d0	74 62		 je	 SHORT $LN2@do_put
  000d2	83 ec 08	 sub	 esp, 8
  000d5	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  000da	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000df	e8 00 00 00 00	 call	 _fabsl
  000e4	83 c4 08	 add	 esp, 8
  000e7	dd 5d 90	 fstp	 QWORD PTR tv196[ebp]
  000ea	f2 0f 10 45 90	 movsd	 xmm0, QWORD PTR tv196[ebp]
  000ef	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000f7	76 3b		 jbe	 SHORT $LN2@do_put

; 1396 :             int _Ptwo;
; 1397 :             (void) _CSTD frexpl(_Val, &_Ptwo);

  000f9	8d 55 a0	 lea	 edx, DWORD PTR __Ptwo$2[ebp]
  000fc	52		 push	 edx
  000fd	83 ec 08	 sub	 esp, 8
  00100	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  00105	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010a	e8 00 00 00 00	 call	 _frexpl
  0010f	dd d8		 fstp	 ST(0)
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1398 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  00114	8b 45 a0	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _abs
  0011d	83 c4 04	 add	 esp, 4
  00120	69 c0 97 75 00
	00		 imul	 eax, eax, 30103
  00126	99		 cdq
  00127	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0012c	f7 f9		 idiv	 ecx
  0012e	03 45 c0	 add	 eax, DWORD PTR __Bufsize$[ebp]
  00131	89 45 c0	 mov	 DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1399 :         }
; 1400 : 
; 1401 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  00134	6a 00		 push	 0
  00136	8b 55 c0	 mov	 edx, DWORD PTR __Bufsize$[ebp]
  00139	83 c2 32	 add	 edx, 50			; 00000032H
  0013c	52		 push	 edx
  0013d	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00140	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1402 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  00145	83 ec 08	 sub	 esp, 8
  00148	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0014d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00152	e8 00 00 00 00	 call	 ??$isfinite@O@@YA_NO@Z	; isfinite<long double>
  00157	83 c4 08	 add	 esp, 8
  0015a	88 45 cd	 mov	 BYTE PTR __Is_finite$[ebp], al

; 1403 :         const auto _Adjusted_flags = // TRANSITION, DevCom-10519861

  0015d	0f b6 45 cd	 movzx	 eax, BYTE PTR __Is_finite$[ebp]
  00161	85 c0		 test	 eax, eax
  00163	74 0d		 je	 SHORT $LN10@do_put
  00165	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00168	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0016d	89 45 bc	 mov	 DWORD PTR tv139[ebp], eax
  00170	eb 0e		 jmp	 SHORT $LN11@do_put
$LN10@do_put:
  00172	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00175	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0017a	83 e0 ef	 and	 eax, -17		; ffffffefH
  0017d	89 45 bc	 mov	 DWORD PTR tv139[ebp], eax
$LN11@do_put:
  00180	8b 4d bc	 mov	 ecx, DWORD PTR tv139[ebp]
  00183	89 4d 9c	 mov	 DWORD PTR __Adjusted_flags$[ebp], ecx

; 1404 :             _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
; 1405 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00186	83 ec 08	 sub	 esp, 8
  00189	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0018e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00193	8b 55 a8	 mov	 edx, DWORD PTR __Precision$[ebp]
  00196	52		 push	 edx
  00197	8b 45 9c	 mov	 eax, DWORD PTR __Adjusted_flags$[ebp]
  0019a	50		 push	 eax
  0019b	6a 4c		 push	 76			; 0000004cH
  0019d	8d 4d e8	 lea	 ecx, DWORD PTR __Fmt$[ebp]
  001a0	51		 push	 ecx
  001a1	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  001aa	83 c4 10	 add	 esp, 16			; 00000010H
  001ad	50		 push	 eax
  001ae	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001b1	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  001b6	50		 push	 eax
  001b7	6a 00		 push	 0
  001b9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001bc	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _sprintf_s
  001c7	83 c4 18	 add	 esp, 24			; 00000018H
  001ca	89 45 98	 mov	 DWORD PTR __Ngen$[ebp], eax

; 1406 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Adjusted_flags), static_cast<int>(_Precision), _Val));
; 1407 : 
; 1408 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  001cd	0f b6 45 cd	 movzx	 eax, BYTE PTR __Is_finite$[ebp]
  001d1	50		 push	 eax
  001d2	8b 4d 98	 mov	 ecx, DWORD PTR __Ngen$[ebp]
  001d5	51		 push	 ecx
  001d6	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001d9	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001de	50		 push	 eax
  001df	0f b6 55 18	 movzx	 edx, BYTE PTR __Fill$[ebp]
  001e3	52		 push	 edx
  001e4	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  001eb	51		 push	 ecx
  001ec	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  001ef	52		 push	 edx
  001f0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001f3	50		 push	 eax
  001f4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	e8 00 00 00 00	 call	 ??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
  001fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00203	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00206	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0020b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1409 :     }

  0020e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00211	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00218	59		 pop	 ecx
  00219	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021c	33 cd		 xor	 ecx, ebp
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DO@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
_TEXT	SEGMENT
tv196 = -112						; size = 8
__Ngen$ = -104						; size = 4
__Adjusted_flags$ = -100				; size = 4
__Ptwo$2 = -96						; size = 4
__Desired_precision$ = -92				; size = 4
__Precision$ = -88					; size = 8
tv78 = -80						; size = 8
_this$ = -72						; size = 4
tv139 = -68						; size = 4
__Bufsize$ = -64					; size = 4
__Float_flags$ = -60					; size = 4
__Is_fixed$ = -53					; size = 1
__Is_hex$ = -52						; size = 1
__Is_finite$ = -51					; size = 1
tv73 = -50						; size = 1
tv71 = -49						; size = 1
__Buf$ = -48						; size = 24
__Fmt$ = -24						; size = 8
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1358 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const { // put formatted double to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 64	 sub	 esp, 100		; 00000064H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d b8	 mov	 DWORD PTR _this$[ebp], ecx

; 1359 :         string _Buf;

  0002b	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00033	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1360 :         char _Fmt[8];
; 1361 :         const auto _Float_flags     = _Iosbase.flags() & ios_base::floatfield;

  0003a	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0003d	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00042	25 00 30 00 00	 and	 eax, 12288		; 00003000H
  00047	89 45 c4	 mov	 DWORD PTR __Float_flags$[ebp], eax

; 1362 :         const bool _Is_fixed        = _Float_flags == ios_base::fixed;

  0004a	81 7d c4 00 20
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 8192 ; 00002000H
  00051	75 06		 jne	 SHORT $LN4@do_put
  00053	c6 45 cf 01	 mov	 BYTE PTR tv71[ebp], 1
  00057	eb 04		 jmp	 SHORT $LN5@do_put
$LN4@do_put:
  00059	c6 45 cf 00	 mov	 BYTE PTR tv71[ebp], 0
$LN5@do_put:
  0005d	8a 45 cf	 mov	 al, BYTE PTR tv71[ebp]
  00060	88 45 cb	 mov	 BYTE PTR __Is_fixed$[ebp], al

; 1363 :         const bool _Is_hex          = _Float_flags == (ios_base::fixed | ios_base::scientific);

  00063	81 7d c4 00 30
	00 00		 cmp	 DWORD PTR __Float_flags$[ebp], 12288 ; 00003000H
  0006a	75 06		 jne	 SHORT $LN6@do_put
  0006c	c6 45 ce 01	 mov	 BYTE PTR tv73[ebp], 1
  00070	eb 04		 jmp	 SHORT $LN7@do_put
$LN6@do_put:
  00072	c6 45 ce 00	 mov	 BYTE PTR tv73[ebp], 0
$LN7@do_put:
  00076	8a 4d ce	 mov	 cl, BYTE PTR tv73[ebp]
  00079	88 4d cc	 mov	 BYTE PTR __Is_hex$[ebp], cl

; 1364 :         const streamsize _Precision = _Is_hex ? -1 : _Iosbase.precision(); // precision setting

  0007c	0f b6 55 cc	 movzx	 edx, BYTE PTR __Is_hex$[ebp]
  00080	85 d2		 test	 edx, edx
  00082	74 0f		 je	 SHORT $LN8@do_put
  00084	83 c8 ff	 or	 eax, -1
  00087	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
  0008e	89 45 b4	 mov	 DWORD PTR tv78[ebp+4], eax
  00091	eb 0e		 jmp	 SHORT $LN9@do_put
$LN8@do_put:
  00093	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00096	e8 00 00 00 00	 call	 ?precision@ios_base@std@@QBE_JXZ ; std::ios_base::precision
  0009b	89 45 b0	 mov	 DWORD PTR tv78[ebp], eax
  0009e	89 55 b4	 mov	 DWORD PTR tv78[ebp+4], edx
$LN9@do_put:
  000a1	8b 4d b0	 mov	 ecx, DWORD PTR tv78[ebp]
  000a4	8b 55 b4	 mov	 edx, DWORD PTR tv78[ebp+4]
  000a7	89 4d a8	 mov	 DWORD PTR __Precision$[ebp], ecx
  000aa	89 55 ac	 mov	 DWORD PTR __Precision$[ebp+4], edx

; 1365 :         const int _Desired_precision =

  000ad	8b 45 c4	 mov	 eax, DWORD PTR __Float_flags$[ebp]
  000b0	50		 push	 eax
  000b1	8b 4d ac	 mov	 ecx, DWORD PTR __Precision$[ebp+4]
  000b4	51		 push	 ecx
  000b5	8b 55 a8	 mov	 edx, DWORD PTR __Precision$[ebp]
  000b8	52		 push	 edx
  000b9	e8 00 00 00 00	 call	 ??$_Float_put_desired_precision@N@std@@YAH_JH@Z ; std::_Float_put_desired_precision<double>
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 45 a4	 mov	 DWORD PTR __Desired_precision$[ebp], eax

; 1366 :             _Float_put_desired_precision<double>(_Precision, _Float_flags); // desired precision
; 1367 :         size_t _Bufsize = static_cast<size_t>(_Desired_precision);

  000c4	8b 45 a4	 mov	 eax, DWORD PTR __Desired_precision$[ebp]
  000c7	89 45 c0	 mov	 DWORD PTR __Bufsize$[ebp], eax

; 1368 :         if (_Is_fixed && 1e10 < _CSTD fabs(_Val)) { // f or F format

  000ca	0f b6 4d cb	 movzx	 ecx, BYTE PTR __Is_fixed$[ebp]
  000ce	85 c9		 test	 ecx, ecx
  000d0	74 62		 je	 SHORT $LN2@do_put
  000d2	83 ec 08	 sub	 esp, 8
  000d5	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  000da	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  000df	e8 00 00 00 00	 call	 _fabs
  000e4	83 c4 08	 add	 esp, 8
  000e7	dd 5d 90	 fstp	 QWORD PTR tv196[ebp]
  000ea	f2 0f 10 45 90	 movsd	 xmm0, QWORD PTR tv196[ebp]
  000ef	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4202a05f20000000
  000f7	76 3b		 jbe	 SHORT $LN2@do_put

; 1369 :             int _Ptwo;
; 1370 :             (void) _CSTD frexp(_Val, &_Ptwo);

  000f9	8d 55 a0	 lea	 edx, DWORD PTR __Ptwo$2[ebp]
  000fc	52		 push	 edx
  000fd	83 ec 08	 sub	 esp, 8
  00100	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  00105	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  0010a	e8 00 00 00 00	 call	 _frexp
  0010f	dd d8		 fstp	 ST(0)
  00111	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1371 :             _Bufsize += _CSTD abs(_Ptwo) * 30103L / 100000L;

  00114	8b 45 a0	 mov	 eax, DWORD PTR __Ptwo$2[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _abs
  0011d	83 c4 04	 add	 esp, 4
  00120	69 c0 97 75 00
	00		 imul	 eax, eax, 30103
  00126	99		 cdq
  00127	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  0012c	f7 f9		 idiv	 ecx
  0012e	03 45 c0	 add	 eax, DWORD PTR __Bufsize$[ebp]
  00131	89 45 c0	 mov	 DWORD PTR __Bufsize$[ebp], eax
$LN2@do_put:

; 1372 :         }
; 1373 : 
; 1374 :         _Buf.resize(_Bufsize + 50); // add fudge factor

  00134	6a 00		 push	 0
  00136	8b 55 c0	 mov	 edx, DWORD PTR __Bufsize$[ebp]
  00139	83 c2 32	 add	 edx, 50			; 00000032H
  0013c	52		 push	 edx
  0013d	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00140	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 1375 :         const bool _Is_finite      = (_STD isfinite)(_Val);

  00145	83 ec 08	 sub	 esp, 8
  00148	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0014d	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00152	e8 00 00 00 00	 call	 ??$isfinite@N@@YA_NN@Z	; isfinite<double>
  00157	83 c4 08	 add	 esp, 8
  0015a	88 45 cd	 mov	 BYTE PTR __Is_finite$[ebp], al

; 1376 :         const auto _Adjusted_flags = // TRANSITION, DevCom-10519861

  0015d	0f b6 45 cd	 movzx	 eax, BYTE PTR __Is_finite$[ebp]
  00161	85 c0		 test	 eax, eax
  00163	74 0d		 je	 SHORT $LN10@do_put
  00165	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00168	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0016d	89 45 bc	 mov	 DWORD PTR tv139[ebp], eax
  00170	eb 0e		 jmp	 SHORT $LN11@do_put
$LN10@do_put:
  00172	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00175	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0017a	83 e0 ef	 and	 eax, -17		; ffffffefH
  0017d	89 45 bc	 mov	 DWORD PTR tv139[ebp], eax
$LN11@do_put:
  00180	8b 4d bc	 mov	 ecx, DWORD PTR tv139[ebp]
  00183	89 4d 9c	 mov	 DWORD PTR __Adjusted_flags$[ebp], ecx

; 1377 :             _Is_finite ? _Iosbase.flags() : _Iosbase.flags() & ~ios_base::showpoint;
; 1378 :         const auto _Ngen = static_cast<size_t>(_CSTD sprintf_s(

  00186	83 ec 08	 sub	 esp, 8
  00189	f2 0f 10 45 1c	 movsd	 xmm0, QWORD PTR __Val$[ebp]
  0018e	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00193	8b 55 a8	 mov	 edx, DWORD PTR __Precision$[ebp]
  00196	52		 push	 edx
  00197	8b 45 9c	 mov	 eax, DWORD PTR __Adjusted_flags$[ebp]
  0019a	50		 push	 eax
  0019b	6a 00		 push	 0
  0019d	8d 4d e8	 lea	 ecx, DWORD PTR __Fmt$[ebp]
  001a0	51		 push	 ecx
  001a1	8b 55 b8	 mov	 edx, DWORD PTR _this$[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ?_Ffmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ffmt
  001aa	83 c4 10	 add	 esp, 16			; 00000010H
  001ad	50		 push	 eax
  001ae	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001b1	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  001b6	50		 push	 eax
  001b7	6a 00		 push	 0
  001b9	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001bc	e8 00 00 00 00	 call	 ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
  001c1	50		 push	 eax
  001c2	e8 00 00 00 00	 call	 _sprintf_s
  001c7	83 c4 18	 add	 esp, 24			; 00000018H
  001ca	89 45 98	 mov	 DWORD PTR __Ngen$[ebp], eax

; 1379 :             &_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Adjusted_flags), static_cast<int>(_Precision), _Val));
; 1380 : 
; 1381 :         return _Fput_v3(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen, _Is_finite);

  001cd	0f b6 45 cd	 movzx	 eax, BYTE PTR __Is_finite$[ebp]
  001d1	50		 push	 eax
  001d2	8b 4d 98	 mov	 ecx, DWORD PTR __Ngen$[ebp]
  001d5	51		 push	 ecx
  001d6	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  001d9	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001de	50		 push	 eax
  001df	0f b6 55 18	 movzx	 edx, BYTE PTR __Fill$[ebp]
  001e3	52		 push	 edx
  001e4	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  001e7	50		 push	 eax
  001e8	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  001eb	51		 push	 ecx
  001ec	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  001ef	52		 push	 edx
  001f0	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  001f3	50		 push	 eax
  001f4	8b 4d b8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f7	e8 00 00 00 00	 call	 ??$_Fput_v3@$0A@@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@1@V21@AAVios_base@1@DPBDI_N@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Fput_v3<0>
  001fc	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00203	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00206	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0020b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1382 :     }

  0020e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00211	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00218	59		 pop	 ecx
  00219	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0021c	33 cd		 xor	 ecx, ebp
  0021e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00223	8b e5		 mov	 esp, ebp
  00225	5d		 pop	 ebp
  00226	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 98	 mov	 ecx, DWORD PTR [edx-104]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DN@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1349 :         unsigned long long _Val) const { // put formatted unsigned long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1350 :         char _Buf[2 * _Max_int_dig];
; 1351 :         char _Fmt[8];
; 1352 : 
; 1353 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00013	8b 45 20	 mov	 eax, DWORD PTR __Val$[ebp+4]
  00016	50		 push	 eax
  00017	8b 4d 1c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0001e	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02CLHGNPPK@Lu@
  00029	8d 55 f4	 lea	 edx, DWORD PTR __Fmt$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	50		 push	 eax
  0003a	6a 40		 push	 64			; 00000040H
  0003c	8d 4d b4	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _sprintf_s
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	50		 push	 eax
  00049	8d 55 b4	 lea	 edx, DWORD PTR __Buf$[ebp]
  0004c	52		 push	 edx
  0004d	0f b6 45 18	 movzx	 eax, BYTE PTR __Fill$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00059	52		 push	 edx
  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
  0006b	83 c4 20	 add	 esp, 32			; 00000020H
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1354 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
; 1355 :     }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_K@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 8
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 8
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1340 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const { // put formatted long long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1341 :         char _Buf[2 * _Max_int_dig];
; 1342 :         char _Fmt[8];
; 1343 : 
; 1344 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00013	8b 45 20	 mov	 eax, DWORD PTR __Val$[ebp+4]
  00016	50		 push	 eax
  00017	8b 4d 1c	 mov	 ecx, DWORD PTR __Val$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0001e	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00023	50		 push	 eax
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02HIKPPMOK@Ld@
  00029	8d 55 f4	 lea	 edx, DWORD PTR __Fmt$[ebp]
  0002c	52		 push	 edx
  0002d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00036	83 c4 10	 add	 esp, 16			; 00000010H
  00039	50		 push	 eax
  0003a	6a 40		 push	 64			; 00000040H
  0003c	8d 4d b4	 lea	 ecx, DWORD PTR __Buf$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 _sprintf_s
  00045	83 c4 14	 add	 esp, 20			; 00000014H
  00048	50		 push	 eax
  00049	8d 55 b4	 lea	 edx, DWORD PTR __Buf$[ebp]
  0004c	52		 push	 edx
  0004d	0f b6 45 18	 movzx	 eax, BYTE PTR __Fill$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00055	51		 push	 ecx
  00056	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00059	52		 push	 edx
  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00061	51		 push	 ecx
  00062	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
  0006b	83 c4 20	 add	 esp, 32			; 00000020H
  0006e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1345 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
; 1346 :     }

  00071	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00074	33 cd		 xor	 ecx, ebp
  00076	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 1c 00	 ret	 28			; 0000001cH
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_J@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1331 :         unsigned long _Val) const { // put formatted unsigned long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1332 :         char _Buf[2 * _Max_int_dig];
; 1333 :         char _Fmt[6];
; 1334 : 
; 1335 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00013	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0001a	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_02BDDLJJBK@lu@
  00025	8d 4d f4	 lea	 ecx, DWORD PTR __Fmt$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	50		 push	 eax
  00036	6a 40		 push	 64			; 00000040H
  00038	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _sprintf_s
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	50		 push	 eax
  00045	8d 4d b4	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00048	51		 push	 ecx
  00049	0f b6 55 18	 movzx	 edx, BYTE PTR __Fill$[ebp]
  0004d	52		 push	 edx
  0004e	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  00055	51		 push	 ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
  00067	83 c4 20	 add	 esp, 32			; 00000020H
  0006a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1336 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
; 1337 :     }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DK@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
_this$ = -80						; size = 4
__Buf$ = -76						; size = 64
__Fmt$ = -12						; size = 6
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1322 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx

; 1323 :         char _Buf[2 * _Max_int_dig];
; 1324 :         char _Fmt[6];
; 1325 : 
; 1326 :         return _Iput(_Dest, _Iosbase, _Fill, _Buf,

  00013	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0001a	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET ??_C@_02EAOCLKAK@ld@
  00025	8d 4d f4	 lea	 ecx, DWORD PTR __Fmt$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?_Ifmt@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABAPADPADPBDH@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Ifmt
  00032	83 c4 10	 add	 esp, 16			; 00000010H
  00035	50		 push	 eax
  00036	6a 40		 push	 64			; 00000040H
  00038	8d 45 b4	 lea	 eax, DWORD PTR __Buf$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _sprintf_s
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	50		 push	 eax
  00045	8d 4d b4	 lea	 ecx, DWORD PTR __Buf$[ebp]
  00048	51		 push	 ecx
  00049	0f b6 55 18	 movzx	 edx, BYTE PTR __Fill$[ebp]
  0004d	52		 push	 edx
  0004e	8b 45 14	 mov	 eax, DWORD PTR __Iosbase$[ebp]
  00051	50		 push	 eax
  00052	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp+4]
  00055	51		 push	 ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Dest$[ebp]
  00059	52		 push	 edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ?_Iput@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DPADI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Iput
  00067	83 c4 20	 add	 esp, 32			; 00000020H
  0006a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1327 :             static_cast<size_t>(_CSTD sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
; 1328 :     }

  0006d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00070	33 cd		 xor	 ecx, ebp
  00072	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 18 00	 ret	 24			; 00000018H
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
_TEXT	SEGMENT
$T2 = -148						; size = 8
$T3 = -140						; size = 8
$T4 = -132						; size = 8
tv219 = -124						; size = 8
tv185 = -116						; size = 4
tv183 = -112						; size = 4
tv180 = -108						; size = 4
tv187 = -104						; size = 4
__Punct_fac$5 = -100					; size = 4
__Fillcount$6 = -96					; size = 4
_this$ = -92						; size = 4
$T7 = -88						; size = 24
$T8 = -64						; size = 24
__Str$9 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 1
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put, COMDAT
; _this$ = ecx

; 1290 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const { // put formatted bool to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	56		 push	 esi
  00022	50		 push	 eax
  00023	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00026	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002c	89 4d a4	 mov	 DWORD PTR _this$[ebp], ecx

; 1291 :         if (!(_Iosbase.flags() & ios_base::boolalpha)) {

  0002f	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00032	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00037	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  0003c	75 34		 jne	 SHORT $LN2@do_put

; 1292 :             return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));

  0003e	0f b6 45 1c	 movzx	 eax, BYTE PTR __Val$[ebp]
  00042	50		 push	 eax
  00043	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 14	 mov	 edx, DWORD PTR __Iosbase$[ebp]
  0004b	52		 push	 edx
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00053	51		 push	 ecx
  00054	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00057	52		 push	 edx
  00058	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 10		 mov	 edx, DWORD PTR [eax]
  0005d	8b 4d a4	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  00063	ff d0		 call	 eax
  00065	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00068	e9 b8 01 00 00	 jmp	 $LN3@do_put

; 1293 :         } else { // put "false" or "true"

  0006d	e9 b3 01 00 00	 jmp	 $LN3@do_put
$LN2@do_put:

; 1294 :             const auto& _Punct_fac = _STD use_facet<numpunct<_Elem>>(_Iosbase.getloc());

  00072	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00078	51		 push	 ecx
  00079	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  0007c	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00081	89 45 98	 mov	 DWORD PTR tv187[ebp], eax
  00084	8b 55 98	 mov	 edx, DWORD PTR tv187[ebp]
  00087	89 55 94	 mov	 DWORD PTR tv180[ebp], edx
  0008a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00091	8b 45 94	 mov	 eax, DWORD PTR tv180[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ??$use_facet@V?$numpunct@D@std@@@std@@YAABV?$numpunct@D@0@ABVlocale@0@@Z ; std::use_facet<std::numpunct<char> >
  0009a	83 c4 04	 add	 esp, 4
  0009d	89 45 9c	 mov	 DWORD PTR __Punct_fac$5[ebp], eax
  000a0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a7	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  000ad	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  000b2	90		 npad	 1

; 1295 :             basic_string<_Elem> _Str;

  000b3	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  000b6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000bb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1

; 1296 :             if (_Val) {

  000c2	0f b6 4d 1c	 movzx	 ecx, BYTE PTR __Val$[ebp]
  000c6	85 c9		 test	 ecx, ecx
  000c8	74 26		 je	 SHORT $LN4@do_put

; 1297 :                 _Str.assign(_Punct_fac.truename());

  000ca	8d 55 c0	 lea	 edx, DWORD PTR $T8[ebp]
  000cd	52		 push	 edx
  000ce	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$5[ebp]
  000d1	e8 00 00 00 00	 call	 ?truename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::truename
  000d6	89 45 90	 mov	 DWORD PTR tv183[ebp], eax
  000d9	8b 45 90	 mov	 eax, DWORD PTR tv183[ebp]
  000dc	50		 push	 eax
  000dd	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  000e0	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  000e5	8d 4d c0	 lea	 ecx, DWORD PTR $T8[ebp]
  000e8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000ed	90		 npad	 1

; 1298 :             } else {

  000ee	eb 24		 jmp	 SHORT $LN5@do_put
$LN4@do_put:

; 1299 :                 _Str.assign(_Punct_fac.falsename());

  000f0	8d 4d a8	 lea	 ecx, DWORD PTR $T7[ebp]
  000f3	51		 push	 ecx
  000f4	8b 4d 9c	 mov	 ecx, DWORD PTR __Punct_fac$5[ebp]
  000f7	e8 00 00 00 00	 call	 ?falsename@?$numpunct@D@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::numpunct<char>::falsename
  000fc	89 45 8c	 mov	 DWORD PTR tv185[ebp], eax
  000ff	8b 55 8c	 mov	 edx, DWORD PTR tv185[ebp]
  00102	52		 push	 edx
  00103	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  00106	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0010b	8d 4d a8	 lea	 ecx, DWORD PTR $T7[ebp]
  0010e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00113	90		 npad	 1
$LN5@do_put:

; 1300 :             }
; 1301 : 
; 1302 :             size_t _Fillcount;
; 1303 :             if (_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size()) {

  00114	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00117	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  0011c	89 45 84	 mov	 DWORD PTR tv219[ebp], eax
  0011f	89 55 88	 mov	 DWORD PTR tv219[ebp+4], edx
  00122	83 7d 88 00	 cmp	 DWORD PTR tv219[ebp+4], 0
  00126	7c 1e		 jl	 SHORT $LN8@do_put
  00128	7f 06		 jg	 SHORT $LN15@do_put
  0012a	83 7d 84 00	 cmp	 DWORD PTR tv219[ebp], 0
  0012e	76 16		 jbe	 SHORT $LN8@do_put
$LN15@do_put:
  00130	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00133	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00138	8b f0		 mov	 esi, eax
  0013a	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  0013d	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00142	3b f0		 cmp	 esi, eax
  00144	77 09		 ja	 SHORT $LN6@do_put
$LN8@do_put:

; 1304 :                 _Fillcount = 0;

  00146	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __Fillcount$6[ebp], 0

; 1305 :             } else {

  0014d	eb 17		 jmp	 SHORT $LN7@do_put
$LN6@do_put:

; 1306 :                 _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();

  0014f	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00152	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00157	8b f0		 mov	 esi, eax
  00159	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  0015c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00161	2b f0		 sub	 esi, eax
  00163	89 75 a0	 mov	 DWORD PTR __Fillcount$6[ebp], esi
$LN7@do_put:

; 1307 :             }
; 1308 : 
; 1309 :             if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left) { // put leading fill

  00166	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  00169	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0016e	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00173	83 f8 40	 cmp	 eax, 64			; 00000040H
  00176	74 36		 je	 SHORT $LN9@do_put

; 1310 :                 _Dest      = _Rep(_Dest, _Fill, _Fillcount);

  00178	8b 45 a0	 mov	 eax, DWORD PTR __Fillcount$6[ebp]
  0017b	50		 push	 eax
  0017c	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  00180	51		 push	 ecx
  00181	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  00184	52		 push	 edx
  00185	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  00188	50		 push	 eax
  00189	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0018f	51		 push	 ecx
  00190	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00199	83 c4 18	 add	 esp, 24			; 00000018H
  0019c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0019e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001a1	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001a4	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1311 :                 _Fillcount = 0;

  001a7	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __Fillcount$6[ebp], 0
$LN9@do_put:

; 1312 :             }
; 1313 :             _Dest = _Put(_Dest, _Str.c_str(), _Str.size()); // put field

  001ae	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  001b1	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  001b6	50		 push	 eax
  001b7	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  001ba	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  001bf	50		 push	 eax
  001c0	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  001c3	50		 push	 eax
  001c4	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
  001c7	51		 push	 ecx
  001c8	8d 95 6c ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001ce	52		 push	 edx
  001cf	8b 45 a4	 mov	 eax, DWORD PTR _this$[ebp]
  001d2	50		 push	 eax
  001d3	e8 00 00 00 00	 call	 ?_Put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@PBDI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Put
  001d8	83 c4 18	 add	 esp, 24			; 00000018H
  001db	8b 08		 mov	 ecx, DWORD PTR [eax]
  001dd	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001e0	89 4d 0c	 mov	 DWORD PTR __Dest$[ebp], ecx
  001e3	89 55 10	 mov	 DWORD PTR __Dest$[ebp+4], edx

; 1314 :             _Iosbase.width(0);

  001e6	6a 00		 push	 0
  001e8	6a 00		 push	 0
  001ea	8b 4d 14	 mov	 ecx, DWORD PTR __Iosbase$[ebp]
  001ed	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width

; 1315 :             return _Rep(_Dest, _Fill, _Fillcount); // put trailing fill

  001f2	8b 45 a0	 mov	 eax, DWORD PTR __Fillcount$6[ebp]
  001f5	50		 push	 eax
  001f6	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  001fa	51		 push	 ecx
  001fb	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp+4]
  001fe	52		 push	 edx
  001ff	8b 45 0c	 mov	 eax, DWORD PTR __Dest$[ebp]
  00202	50		 push	 eax
  00203	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00206	51		 push	 ecx
  00207	8b 55 a4	 mov	 edx, DWORD PTR _this$[ebp]
  0020a	52		 push	 edx
  0020b	e8 00 00 00 00	 call	 ?_Rep@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@ABA?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@DI@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Rep
  00210	83 c4 18	 add	 esp, 24			; 00000018H
  00213	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0021a	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  0021d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00222	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@do_put:

; 1316 :         }
; 1317 :     }

  00225	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00228	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0022f	59		 pop	 ecx
  00230	5e		 pop	 esi
  00231	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00234	33 cd		 xor	 ecx, ebp
  00236	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0023b	8b e5		 mov	 esp, ebp
  0023d	5d		 pop	 ebp
  0023e	c2 18 00	 ret	 24			; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$0:
  00000	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z$1:
  0000b	8d 4d d8	 lea	 ecx, DWORD PTR __Str$9[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 8a 70 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-144]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?do_put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@D_N@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::do_put
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Dest$ = 12						; size = 8
__Iosbase$ = 20						; size = 4
__Fill$ = 24						; size = 1
__Val$ = 28						; size = 4
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put, COMDAT
; _this$ = ecx

; 1254 :         _OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const { // put formatted long to _Dest

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1255 :         return do_put(_Dest, _Iosbase, _Fill, _Val);

  00007	8b 45 1c	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	0f b6 4d 18	 movzx	 ecx, BYTE PTR __Fill$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 14	 mov	 edx, DWORD PTR __Iosbase$[ebp]
  00013	52		 push	 edx
  00014	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp+4]
  00017	50		 push	 eax
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  0002b	ff d0		 call	 eax
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1256 :     }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 18 00	 ret	 24			; 00000018H
?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1241 :     __CLR_OR_THIS_CALL num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@

; 1242 :         _Init(_Lobj);

  00042	8b 55 08	 mov	 edx, DWORD PTR __Lobj$[ebp]
  00045	52		 push	 edx
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
  0004e	90		 npad	 1

; 1243 :     }

  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init, COMDAT
; _this$ = ecx

; 1232 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo&) {} // initialize from _Locinfo object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Init@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEXABV_Locinfo@2@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >, COMDAT
; _this$ = ecx

; 1230 :     __CLR_OR_THIS_CALL ~num_put() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00018	90		 npad	 1
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@MAE@XZ ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocnum
;	COMDAT ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv128 = -32						; size = 4
tv131 = -28						; size = 4
tv89 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat, COMDAT

; 1218 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 1219 :         // return locale category mask and construct standard facet
; 1220 :         if (_Ppf && !*_Ppf) {

  0002c	83 7d 08 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00030	0f 84 98 00 00
	00		 je	 $LN9@Getcat
  00036	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	0f 85 8c 00 00
	00		 jne	 $LN9@Getcat

; 1221 :             *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->_C_str()));

  00042	6a 08		 push	 8
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	83 7d ec 00	 cmp	 DWORD PTR $T4[ebp], 0
  0005a	74 3a		 je	 SHORT $LN4@Getcat
  0005c	6a 00		 push	 0
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00061	e8 00 00 00 00	 call	 ?_C_str@locale@std@@QBEPBDXZ ; std::locale::_C_str
  00066	50		 push	 eax
  00067	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  0006f	89 45 e4	 mov	 DWORD PTR tv131[ebp], eax
  00072	8b 4d e4	 mov	 ecx, DWORD PTR tv131[ebp]
  00075	89 4d e0	 mov	 DWORD PTR tv128[ebp], ecx
  00078	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0007c	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp]
  0007f	83 ca 01	 or	 edx, 1
  00082	89 55 f0	 mov	 DWORD PTR $T5[ebp], edx
  00085	8b 45 e0	 mov	 eax, DWORD PTR tv128[ebp]
  00088	50		 push	 eax
  00089	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  0008c	e8 00 00 00 00	 call	 ??0?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QAE@ABV_Locinfo@1@I@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >
  00091	89 45 e8	 mov	 DWORD PTR tv89[ebp], eax
  00094	eb 07		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00096	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN5@Getcat:
  0009d	8b 4d e8	 mov	 ecx, DWORD PTR tv89[ebp]
  000a0	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx
  000a3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000aa	8b 55 08	 mov	 edx, DWORD PTR __Ppf$[ebp]
  000ad	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  000b0	89 02		 mov	 DWORD PTR [edx], eax
  000b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR $T5[ebp]
  000bc	83 e1 01	 and	 ecx, 1
  000bf	74 0d		 je	 SHORT $LN9@Getcat
  000c1	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  000c5	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000c8	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
  000cd	90		 npad	 1
$LN9@Getcat:

; 1222 :         }
; 1223 : 
; 1224 :         return _X_NUMERIC;

  000ce	b8 04 00 00 00	 mov	 eax, 4

; 1225 :     }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 08		 push	 8
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  0001f	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
__Lock$3 = -36						; size = 4
__Id$4 = -32						; size = 4
__Psave_guard$5 = -28					; size = 4
__Pf$6 = -24						; size = 4
__Pfmod$7 = -20						; size = 4
__Psave$8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z PROC ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >, COMDAT

; 420  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 421  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00025	6a 00		 push	 0
  00027	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 422  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave
  0003b	89 45 f0	 mov	 DWORD PTR __Psave$8[ebp], eax

; 423  : 
; 424  :     const size_t _Id         = _Facet::id;

  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@2V0locale@2@A ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::id
  00043	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00048	89 45 e0	 mov	 DWORD PTR __Id$4[ebp], eax

; 425  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004b	8b 4d e0	 mov	 ecx, DWORD PTR __Id$4[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$6[ebp], eax

; 426  : 
; 427  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$6[ebp], 0
  0005e	75 7d		 jne	 SHORT $LN6@use_facet

; 428  :         if (_Psave) {

  00060	83 7d f0 00	 cmp	 DWORD PTR __Psave$8[ebp], 0
  00064	74 08		 je	 SHORT $LN3@use_facet

; 429  :             _Pf = _Psave; // lazy facet already allocated

  00066	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  00069	89 55 e8	 mov	 DWORD PTR __Pf$6[ebp], edx
  0006c	eb 6f		 jmp	 SHORT $LN6@use_facet
$LN3@use_facet:

; 430  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0006e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00071	50		 push	 eax
  00072	8d 4d f0	 lea	 ecx, DWORD PTR __Psave$8[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Getcat@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::_Getcat
  0007b	83 c4 08	 add	 esp, 8
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	75 08		 jne	 SHORT $LN5@use_facet

; 431  : #if _HAS_EXCEPTIONS
; 432  :             _Throw_bad_cast(); // lazy disallowed

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  00088	90		 npad	 1

; 433  : #else
; 434  :             _CSTD abort(); // lazy disallowed
; 435  : #endif
; 436  :         } else { // queue up lazy facet for destruction

  00089	eb 52		 jmp	 SHORT $LN6@use_facet
$LN5@use_facet:

; 437  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008b	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  0008e	89 55 ec	 mov	 DWORD PTR __Pfmod$7[ebp], edx

; 438  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00091	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$7[ebp]
  00094	50		 push	 eax
  00095	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  00098	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  0009d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 439  : 
; 440  : #if defined(_M_CEE)
; 441  :             _Facet_Register_m(_Pfmod);
; 442  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 443  :             _Facet_Register(_Pfmod);

  000a1	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000aa	83 c4 04	 add	 esp, 4

; 444  : #endif // ^^^ !defined(_M_CEE) ^^^
; 445  : 
; 446  :             _Pfmod->_Incref();

  000ad	8b 55 ec	 mov	 edx, DWORD PTR __Pfmod$7[ebp]
  000b0	8b 02		 mov	 eax, DWORD PTR [edx]
  000b2	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000b5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b8	ff d2		 call	 edx

; 447  :             _Facetptr<_Facet>::_Psave = _Psave;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR __Psave$8[ebp]
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >::_Psave

; 448  :             _Pf                       = _Psave;

  000c2	8b 4d f0	 mov	 ecx, DWORD PTR __Psave$8[ebp]
  000c5	89 4d e8	 mov	 DWORD PTR __Pf$6[ebp], ecx

; 449  : 
; 450  :             (void) _Psave_guard.release();

  000c8	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000cb	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 451  :         }

  000d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d4	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000d7	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  000dc	90		 npad	 1
$LN6@use_facet:

; 452  :     }
; 453  : 
; 454  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000dd	8b 55 e8	 mov	 edx, DWORD PTR __Pf$6[ebp]
  000e0	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  000ed	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000f2	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 455  :     _END_LOCK()
; 456  : } // end of use_facet body

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :             return _Ok;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 130  :         }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Zero_uncaught_exceptions$ = -2			; size = 1
tv72 = -1						; size = 1
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	75 06		 jne	 SHORT $LN4@sentry
  00015	c6 45 ff 01	 mov	 BYTE PTR tv72[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0001b	c6 45 ff 00	 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  0001f	8a 4d ff	 mov	 cl, BYTE PTR tv72[ebp]
  00022	88 4d fe	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 120  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

  00025	0f b6 55 fe	 movzx	 edx, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00029	85 d2		 test	 edx, edx
  0002b	74 0b		 je	 SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
  00037	90		 npad	 1
$LN2@sentry:

; 124  :             }
; 125  :         }

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00040	90		 npad	 1
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00034	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 97   :             if (!_Ostr.good()) {

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00043	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00046	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	75 09		 jne	 SHORT $LN2@sentry

; 98   :                 _Ok = false;

  00052	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 99   :                 return;

  00059	eb 4a		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

  0005b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0005e	8b 02		 mov	 eax, DWORD PTR [edx]
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00063	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00066	e8 00 00 00 00	 call	 ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
  0006b	89 45 ec	 mov	 DWORD PTR __Tied$[ebp], eax

; 103  :             if (!_Tied || _Tied == &_Ostr) {

  0006e	83 7d ec 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  00072	74 08		 je	 SHORT $LN4@sentry
  00074	8b 4d ec	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00077	3b 4d 08	 cmp	 ecx, DWORD PTR __Ostr$[ebp]
  0007a	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

  0007c	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0007f	c6 42 04 01	 mov	 BYTE PTR [edx+4], 1

; 105  :                 return;

  00083	eb 20		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

  00085	8b 4d ec	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00088	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

  0008d	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00090	8b 08		 mov	 ecx, DWORD PTR [eax]
  00092	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00095	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00098	8b ca		 mov	 ecx, edx
  0009a	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  0009f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 110  :         }

  000a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ac	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000af	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b9	59		 pop	 ecx
  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv72 = -20						; size = 4
__Rdbuf$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

  00028	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002d	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00030	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  00038	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0003b	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00040	89 45 f0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 84   :             if (_Rdbuf) {

  00043	83 7d f0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00047	74 0e		 je	 SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

  00049	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	8b 4d f0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00051	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00054	ff d0		 call	 eax
  00056	90		 npad	 1
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
  00066	cc		 int	 3
  00067	cc		 int	 3
  00068	cc		 int	 3
  00069	cc		 int	 3
  0006a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Rdbuf$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00021	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00024	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00029	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 77   :             if (_Rdbuf) {

  0002c	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00030	74 0e		 je	 SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

  00032	8b 45 fc	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	ff d0		 call	 eax
  0003f	90		 npad	 1
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
  00017	90		 npad	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Tmp$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+, COMDAT
; _this$ = ecx

; 313  :     _NODISCARD _CONSTEXPR20 _Vector_iterator operator+(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 314  :         _Vector_iterator _Tmp = *this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 315  :         _Tmp += _Off;

  00011	8b 55 0c	 mov	 edx, DWORD PTR __Off$[ebp]
  00014	52		 push	 edx
  00015	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00018	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=

; 316  :         return _Tmp;

  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00020	8b 4d fc	 mov	 ecx, DWORD PTR __Tmp$[ebp]
  00023	89 08		 mov	 DWORD PTR [eax], ecx
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 317  :     }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 308  :     _CONSTEXPR20 _Vector_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 309  :         _Mybase::operator+=(_Off);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=

; 310  :         return *this;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 311  :     }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=, COMDAT
; _this$ = ecx

; 127  :     _CONSTEXPR20 _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 128  :         _Verify_offset(_Off);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset

; 129  :         _Ptr += _Off;

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 11		 mov	 edx, DWORD PTR [ecx]
  00018	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001b	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	89 0a		 mov	 DWORD PTR [edx], ecx

; 130  :         return *this;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 131  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset, COMDAT
; _this$ = ecx

; 110  :     _CONSTEXPR20 void _Verify_offset(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 111  : #if _ITERATOR_DEBUG_LEVEL == 0
; 112  :         (void) _Off;
; 113  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 / _ITERATOR_DEBUG_LEVEL != 0 vvv
; 114  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());
; 115  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
; 116  :         _STL_VERIFY(_Off == 0 || _Mycont, "cannot seek invalidated vector iterator");
; 117  :         if (_Off < 0) {
; 118  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");
; 119  :         }
; 120  : 
; 121  :         if (_Off > 0) {
; 122  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");
; 123  :         }
; 124  : #endif // ^^^ _ITERATOR_DEBUG_LEVEL != 0 ^^^
; 125  :     }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 46   :     _CONSTEXPR20 _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 47   :         this->_Adopt(_Pvector);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt
  0001b	90		 npad	 1

; 48   :     }

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1018 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1019 :     _Ostr.put(_Ostr.widen('\n'));

  00003	6a 0a		 push	 10			; 0000000aH
  00005	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00008	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0000d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00010	8b ca		 mov	 ecx, edx
  00012	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  00017	0f b6 c0	 movzx	 eax, al
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0001e	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 1020 :     _Ostr.flush();

  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00026	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 1021 :     return _Ostr;

  0002b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 1022 : }

  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\algorithm
;	COMDAT ??$all_of@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA_NV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0P6AHH@Z@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 4
??$all_of@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA_NV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0P6AHH@Z@Z PROC ; std::all_of<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>, COMDAT

; 1321 : _NODISCARD _CONSTEXPR20 bool all_of(_InIt _First, _InIt _Last, _Pr _Pred) { // test if all elements satisfy _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1322 :     _STD _Adl_verify_range(_First, _Last);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Adl_verify_range@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@V12@@std@@YAXABV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0@Z ; std::_Adl_verify_range<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
  00013	83 c4 08	 add	 esp, 8

; 1323 :     auto _UFirst      = _STD _Get_unwrapped(_First);

  00016	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1324 :     const auto _ULast = _STD _Get_unwrapped(_Last);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@std@@YA?A_TAAV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@@Z ; std::_Get_unwrapped<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > &>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1325 :     for (; _UFirst != _ULast; ++_UFirst) {

  00034	eb 09		 jmp	 SHORT $LN4@all_of
$LN2@all_of:
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00039	83 c1 01	 add	 ecx, 1
  0003c	89 4d fc	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@all_of:
  0003f	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00042	3b 55 f8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00045	74 17		 je	 SHORT $LN3@all_of

; 1326 :         if (!_Pred(*_UFirst)) {

  00047	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0004d	51		 push	 ecx
  0004e	ff 55 10	 call	 DWORD PTR __Pred$[ebp]
  00051	83 c4 04	 add	 esp, 4
  00054	85 c0		 test	 eax, eax
  00056	75 04		 jne	 SHORT $LN5@all_of

; 1327 :             return false;

  00058	32 c0		 xor	 al, al
  0005a	eb 04		 jmp	 SHORT $LN1@all_of
$LN5@all_of:

; 1328 :         }
; 1329 :     }

  0005c	eb d8		 jmp	 SHORT $LN2@all_of
$LN3@all_of:

; 1330 : 
; 1331 :     return true;

  0005e	b0 01		 mov	 al, 1
$LN1@all_of:

; 1332 : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$all_of@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA_NV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0P6AHH@Z@Z ENDP ; std::all_of<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
  00017	90		 npad	 1
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped, COMDAT
; _this$ = ecx

; 346  :     _NODISCARD _CONSTEXPR20 value_type* _Unwrapped() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 347  :         return const_cast<value_type*>(_STD _Unfancy_maybe_null(this->_Ptr));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@$$CBD@std@@YAPBDPBD@Z ; std::_Unfancy_maybe_null<char const >
  00012	83 c4 04	 add	 esp, 4

; 348  :     }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Unwrapped@?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEPADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_Unwrapped
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 41   :     _CONSTEXPR20 _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 42   :         this->_Adopt(_Pstring);

  0000f	8b 55 0c	 mov	 edx, DWORD PTR __Pstring$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ; std::_Iterator_base0::_Adopt
  0001b	90		 npad	 1

; 43   :     }

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T2 = -80						; size = 8
__Ok$ = -72						; size = 8
tv292 = -64						; size = 8
$T3 = -56						; size = 4
__Ctype_fac$4 = -52					; size = 4
tv255 = -48						; size = 4
tv254 = -44						; size = 4
tv251 = -40						; size = 4
tv65 = -36						; size = 4
__Meta$5 = -32						; size = 4
__Size$6 = -28						; size = 4
__State$ = -24						; size = 4
tv256 = -18						; size = 1
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Istr$ = 8						; size = 4
__Str$ = 12						; size = 4
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3372 :     basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 40	 sub	 esp, 64			; 00000040H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 3373 :     using _Myis   = basic_istream<_Elem, _Traits>;
; 3374 :     using _Ctype  = typename _Myis::_Ctype;
; 3375 :     using _Mystr  = basic_string<_Elem, _Traits, _Alloc>;
; 3376 :     using _Mysizt = typename _Mystr::size_type;
; 3377 : 
; 3378 :     typename _Myis::iostate _State = _Myis::goodbit;

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 3379 :     bool _Changed                  = false;

  00033	c6 45 ef 00	 mov	 BYTE PTR __Changed$[ebp], 0

; 3380 :     const typename _Myis::sentry _Ok(_Istr);

  00037	6a 00		 push	 0
  00039	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  0003c	50		 push	 eax
  0003d	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00040	e8 00 00 00 00	 call	 ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
  00045	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 3381 : 
; 3382 :     if (_Ok) { // state okay, extract characters

  0004c	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0004f	e8 00 00 00 00	 call	 ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
  00054	0f b6 c8	 movzx	 ecx, al
  00057	85 c9		 test	 ecx, ecx
  00059	0f 84 a2 01 00
	00		 je	 $LN19@operator

; 3383 :         const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(_Istr.getloc());

  0005f	8d 55 b0	 lea	 edx, DWORD PTR $T2[ebp]
  00062	52		 push	 edx
  00063	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0006b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006e	8b ca		 mov	 ecx, edx
  00070	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00075	89 45 dc	 mov	 DWORD PTR tv65[ebp], eax
  00078	8b 45 dc	 mov	 eax, DWORD PTR tv65[ebp]
  0007b	89 45 d8	 mov	 DWORD PTR tv251[ebp], eax
  0007e	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00082	8b 4d d8	 mov	 ecx, DWORD PTR tv251[ebp]
  00085	51		 push	 ecx
  00086	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008b	83 c4 04	 add	 esp, 4
  0008e	89 45 cc	 mov	 DWORD PTR __Ctype_fac$4[ebp], eax
  00091	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00095	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  00098	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0009d	90		 npad	 1

; 3384 :         _Str.erase();

  0009e	6a 00		 push	 0
  000a0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000a3	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 3385 : 
; 3386 :         _TRY_IO_BEGIN

  000a8	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 3387 :         _Mysizt _Size;
; 3388 :         if (0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size()) {

  000ac	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000b4	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000b7	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  000bc	89 45 c0	 mov	 DWORD PTR tv292[ebp], eax
  000bf	89 55 c4	 mov	 DWORD PTR tv292[ebp+4], edx
  000c2	83 7d c4 00	 cmp	 DWORD PTR tv292[ebp+4], 0
  000c6	7c 3d		 jl	 SHORT $LN7@operator
  000c8	7f 06		 jg	 SHORT $LN21@operator
  000ca	83 7d c0 00	 cmp	 DWORD PTR tv292[ebp], 0
  000ce	76 35		 jbe	 SHORT $LN7@operator
$LN21@operator:
  000d0	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  000d3	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  000d8	8b f0		 mov	 esi, eax
  000da	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000df	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  000e2	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000e5	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  000ea	3b c6		 cmp	 eax, esi
  000ec	73 17		 jae	 SHORT $LN7@operator

; 3389 :             _Size = static_cast<_Mysizt>(_Istr.width());

  000ee	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  000f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f3	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  000f6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000f9	8b ca		 mov	 ecx, edx
  000fb	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00100	89 45 e4	 mov	 DWORD PTR __Size$6[ebp], eax

; 3390 :         } else {

  00103	eb 0b		 jmp	 SHORT $LN8@operator
$LN7@operator:

; 3391 :             _Size = _Str.max_size();

  00105	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  00108	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0010d	89 45 e4	 mov	 DWORD PTR __Size$6[ebp], eax
$LN8@operator:

; 3392 :         }
; 3393 : 
; 3394 :         typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  00110	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00113	8b 08		 mov	 ecx, DWORD PTR [eax]
  00115	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00118	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0011b	8b ca		 mov	 ecx, edx
  0011d	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00122	8b c8		 mov	 ecx, eax
  00124	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
  00129	89 45 d4	 mov	 DWORD PTR tv254[ebp], eax
  0012c	8b 45 d4	 mov	 eax, DWORD PTR tv254[ebp]
  0012f	89 45 e0	 mov	 DWORD PTR __Meta$5[ebp], eax

; 3395 : 
; 3396 :         for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc()) {

  00132	eb 29		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00134	8b 4d e4	 mov	 ecx, DWORD PTR __Size$6[ebp]
  00137	83 e9 01	 sub	 ecx, 1
  0013a	89 4d e4	 mov	 DWORD PTR __Size$6[ebp], ecx
  0013d	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00140	8b 02		 mov	 eax, DWORD PTR [edx]
  00142	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  00145	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00148	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0014d	8b c8		 mov	 ecx, eax
  0014f	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  00154	89 45 d0	 mov	 DWORD PTR tv255[ebp], eax
  00157	8b 4d d0	 mov	 ecx, DWORD PTR tv255[ebp]
  0015a	89 4d e0	 mov	 DWORD PTR __Meta$5[ebp], ecx
$LN4@operator:
  0015d	83 7d e4 00	 cmp	 DWORD PTR __Size$6[ebp], 0
  00161	76 71		 jbe	 SHORT $LN3@operator

; 3397 :             if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  00163	8b 55 e0	 mov	 edx, DWORD PTR __Meta$5[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00172	83 c4 08	 add	 esp, 8
  00175	0f b6 c0	 movzx	 eax, al
  00178	85 c0		 test	 eax, eax
  0017a	74 0d		 je	 SHORT $LN9@operator

; 3398 :                 _State |= _Myis::eofbit;

  0017c	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  0017f	83 c9 01	 or	 ecx, 1
  00182	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx

; 3399 :                 break;

  00185	eb 4d		 jmp	 SHORT $LN3@operator
  00187	eb 46		 jmp	 SHORT $LN12@operator
$LN9@operator:

; 3400 :             } else if (_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  00189	8b 55 e0	 mov	 edx, DWORD PTR __Meta$5[ebp]
  0018c	52		 push	 edx
  0018d	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00192	83 c4 04	 add	 esp, 4
  00195	0f b6 c0	 movzx	 eax, al
  00198	50		 push	 eax
  00199	6a 48		 push	 72			; 00000048H
  0019b	8b 4d cc	 mov	 ecx, DWORD PTR __Ctype_fac$4[ebp]
  0019e	e8 00 00 00 00	 call	 ?is@?$ctype@D@std@@QBE_NFD@Z ; std::ctype<char>::is
  001a3	88 45 ee	 mov	 BYTE PTR tv256[ebp], al
  001a6	0f b6 4d ee	 movzx	 ecx, BYTE PTR tv256[ebp]
  001aa	85 c9		 test	 ecx, ecx
  001ac	74 04		 je	 SHORT $LN11@operator

; 3401 :                 break; // whitespace, quit

  001ae	eb 24		 jmp	 SHORT $LN3@operator

; 3402 :             } else { // add character to string

  001b0	eb 1d		 jmp	 SHORT $LN12@operator
$LN11@operator:

; 3403 :                 _Str.push_back(_Traits::to_char_type(_Meta));

  001b2	8b 55 e0	 mov	 edx, DWORD PTR __Meta$5[ebp]
  001b5	52		 push	 edx
  001b6	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  001bb	83 c4 04	 add	 esp, 4
  001be	0f b6 c0	 movzx	 eax, al
  001c1	50		 push	 eax
  001c2	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  001c5	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
  001ca	90		 npad	 1

; 3404 :                 _Changed = true;

  001cb	c6 45 ef 01	 mov	 BYTE PTR __Changed$[ebp], 1
$LN12@operator:

; 3405 :             }
; 3406 :         }

  001cf	e9 60 ff ff ff	 jmp	 $LN2@operator
$LN3@operator:
  001d4	eb 1b		 jmp	 SHORT $LN15@operator
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 3407 :         _CATCH_IO_(_Myis, _Istr)

  001d6	6a 01		 push	 1
  001d8	6a 04		 push	 4
  001da	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001dd	8b 11		 mov	 edx, DWORD PTR [ecx]
  001df	8b 4d 08	 mov	 ecx, DWORD PTR __Istr$[ebp]
  001e2	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001e5	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  001ea	90		 npad	 1
  001eb	b8 00 00 00 00	 mov	 eax, $LN20@operator
  001f0	c3		 ret	 0
$LN15@operator:
  001f1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  001f8	eb 07		 jmp	 SHORT $LN19@operator
$LN20@operator:
  001fa	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN19@operator:

; 3408 :     }
; 3409 : 
; 3410 :     _Istr.width(0);

  00201	6a 00		 push	 0
  00203	6a 00		 push	 0
  00205	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00208	8b 08		 mov	 ecx, DWORD PTR [eax]
  0020a	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  0020d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00210	8b ca		 mov	 ecx, edx
  00212	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width
  00217	90		 npad	 1

; 3411 :     if (!_Changed) {

  00218	0f b6 45 ef	 movzx	 eax, BYTE PTR __Changed$[ebp]
  0021c	85 c0		 test	 eax, eax
  0021e	75 09		 jne	 SHORT $LN13@operator

; 3412 :         _State |= _Myis::failbit;

  00220	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  00223	83 c9 02	 or	 ecx, 2
  00226	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx
$LN13@operator:

; 3413 :     }
; 3414 : 
; 3415 :     _Istr.setstate(_State);

  00229	6a 00		 push	 0
  0022b	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  0022e	52		 push	 edx
  0022f	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00232	8b 08		 mov	 ecx, DWORD PTR [eax]
  00234	8b 55 08	 mov	 edx, DWORD PTR __Istr$[ebp]
  00237	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0023a	8b ca		 mov	 ecx, edx
  0023c	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00241	90		 npad	 1

; 3416 :     return _Istr;

  00242	8b 45 08	 mov	 eax, DWORD PTR __Istr$[ebp]
  00245	89 45 c8	 mov	 DWORD PTR $T3[ebp], eax
  00248	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0024f	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00252	e8 00 00 00 00	 call	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00257	8b 45 c8	 mov	 eax, DWORD PTR $T3[ebp]

; 3417 : }

  0025a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0025d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00264	59		 pop	 ecx
  00265	5f		 pop	 edi
  00266	5e		 pop	 esi
  00267	5b		 pop	 ebx
  00268	8b e5		 mov	 esp, ebp
  0026a	5d		 pop	 ebp
  0026b	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
  00000	8d 4d b8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$3:
  00008	8d 4d b0	 lea	 ecx, DWORD PTR $T2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\istream
;	COMDAT ?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
_TEXT	SEGMENT
$T2 = -60						; size = 8
__Ctype_fac$3 = -52					; size = 4
tv247 = -48						; size = 4
tv246 = -44						; size = 4
tv243 = -40						; size = 4
tv245 = -36						; size = 4
__Tied$ = -32						; size = 4
__Meta$4 = -28						; size = 4
_this$ = -24						; size = 4
tv248 = -18						; size = 1
__Eof$ = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Noskip$ = 8						; size = 1
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Ipfx, COMDAT
; _this$ = ecx

; 111  :     bool __CLR_OR_THIS_CALL _Ipfx(bool _Noskip = false) { // test stream state and skip whitespace as needed

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 112  :         if (!this->good()) {

  0002f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00037	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0003a	8b ca		 mov	 ecx, edx
  0003c	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  00041	0f b6 c0	 movzx	 eax, al
  00044	85 c0		 test	 eax, eax
  00046	75 1b		 jne	 SHORT $LN5@Ipfx

; 113  :             _Myios::setstate(ios_base::failbit);

  00048	6a 00		 push	 0
  0004a	6a 02		 push	 2
  0004c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00051	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00057	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 114  :             return false;

  0005c	32 c0		 xor	 al, al
  0005e	e9 7f 01 00 00	 jmp	 $LN1@Ipfx
$LN5@Ipfx:

; 115  :         }
; 116  : 
; 117  :         // state okay, flush tied stream and skip whitespace
; 118  :         const auto _Tied = _Myios::tie();

  00063	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b 08		 mov	 ecx, DWORD PTR [eax]
  00068	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0006b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006e	8b ca		 mov	 ecx, edx
  00070	e8 00 00 00 00	 call	 ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
  00075	89 45 e0	 mov	 DWORD PTR __Tied$[ebp], eax

; 119  :         if (_Tied) {

  00078	83 7d e0 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  0007c	74 09		 je	 SHORT $LN6@Ipfx

; 120  :             _Tied->flush();

  0007e	8b 4d e0	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00081	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
  00086	90		 npad	 1
$LN6@Ipfx:

; 121  :         }
; 122  : 
; 123  :         bool _Eof = false;

  00087	c6 45 ef 00	 mov	 BYTE PTR __Eof$[ebp], 0

; 124  :         if (!_Noskip && this->flags() & ios_base::skipws) { // skip whitespace

  0008b	0f b6 45 08	 movzx	 eax, BYTE PTR __Noskip$[ebp]
  0008f	85 c0		 test	 eax, eax
  00091	0f 85 1c 01 00
	00		 jne	 $LN17@Ipfx
  00097	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000a2	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  000a7	83 e0 01	 and	 eax, 1
  000aa	0f 84 03 01 00
	00		 je	 $LN17@Ipfx

; 125  :             const _Ctype& _Ctype_fac = _STD use_facet<_Ctype>(this->getloc());

  000b0	8d 45 c4	 lea	 eax, DWORD PTR $T2[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000b9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000bf	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  000c4	89 45 dc	 mov	 DWORD PTR tv245[ebp], eax
  000c7	8b 45 dc	 mov	 eax, DWORD PTR tv245[ebp]
  000ca	89 45 d8	 mov	 DWORD PTR tv243[ebp], eax
  000cd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000d4	8b 4d d8	 mov	 ecx, DWORD PTR tv243[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  000dd	83 c4 04	 add	 esp, 4
  000e0	89 45 cc	 mov	 DWORD PTR __Ctype_fac$3[ebp], eax
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000ea	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  000ed	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  000f2	90		 npad	 1

; 126  : 
; 127  :             _TRY_IO_BEGIN

  000f3	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 128  :             int_type _Meta = _Myios::rdbuf()->sgetc();

  000fa	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000fd	8b 02		 mov	 eax, DWORD PTR [edx]
  000ff	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00102	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00105	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0010a	8b c8		 mov	 ecx, eax
  0010c	e8 00 00 00 00	 call	 ?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::sgetc
  00111	89 45 d4	 mov	 DWORD PTR tv246[ebp], eax
  00114	8b 4d d4	 mov	 ecx, DWORD PTR tv246[ebp]
  00117	89 4d e4	 mov	 DWORD PTR __Meta$4[ebp], ecx

; 129  : 
; 130  :             for (;; _Meta = _Myios::rdbuf()->snextc()) {

  0011a	eb 20		 jmp	 SHORT $LN4@Ipfx
$LN2@Ipfx:
  0011c	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0011f	8b 02		 mov	 eax, DWORD PTR [edx]
  00121	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00124	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00127	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0012c	8b c8		 mov	 ecx, eax
  0012e	e8 00 00 00 00	 call	 ?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::snextc
  00133	89 45 d0	 mov	 DWORD PTR tv247[ebp], eax
  00136	8b 4d d0	 mov	 ecx, DWORD PTR tv247[ebp]
  00139	89 4d e4	 mov	 DWORD PTR __Meta$4[ebp], ecx
$LN4@Ipfx:

; 131  :                 if (_Traits::eq_int_type(_Traits::eof(), _Meta)) { // end of file, quit

  0013c	8b 55 e4	 mov	 edx, DWORD PTR __Meta$4[ebp]
  0013f	52		 push	 edx
  00140	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0014b	83 c4 08	 add	 esp, 8
  0014e	0f b6 c0	 movzx	 eax, al
  00151	85 c0		 test	 eax, eax
  00153	74 08		 je	 SHORT $LN9@Ipfx

; 132  :                     _Eof = true;

  00155	c6 45 ef 01	 mov	 BYTE PTR __Eof$[ebp], 1

; 133  :                     break;

  00159	eb 2b		 jmp	 SHORT $LN3@Ipfx
  0015b	eb 27		 jmp	 SHORT $LN11@Ipfx
$LN9@Ipfx:

; 134  :                 } else if (!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta))) {

  0015d	8b 4d e4	 mov	 ecx, DWORD PTR __Meta$4[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ; std::_Narrow_char_traits<char,int>::to_char_type
  00166	83 c4 04	 add	 esp, 4
  00169	0f b6 d0	 movzx	 edx, al
  0016c	52		 push	 edx
  0016d	6a 48		 push	 72			; 00000048H
  0016f	8b 4d cc	 mov	 ecx, DWORD PTR __Ctype_fac$3[ebp]
  00172	e8 00 00 00 00	 call	 ?is@?$ctype@D@std@@QBE_NFD@Z ; std::ctype<char>::is
  00177	88 45 ee	 mov	 BYTE PTR tv248[ebp], al
  0017a	0f b6 45 ee	 movzx	 eax, BYTE PTR tv248[ebp]
  0017e	85 c0		 test	 eax, eax
  00180	75 02		 jne	 SHORT $LN11@Ipfx

; 135  :                     break; // not whitespace, quit

  00182	eb 02		 jmp	 SHORT $LN3@Ipfx
$LN11@Ipfx:

; 136  :                 }
; 137  :             }

  00184	eb 96		 jmp	 SHORT $LN2@Ipfx
$LN3@Ipfx:
  00186	eb 1b		 jmp	 SHORT $LN14@Ipfx
__catch$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$0:

; 138  :             _CATCH_IO_END

  00188	6a 01		 push	 1
  0018a	6a 04		 push	 4
  0018c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0018f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00191	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00194	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00197	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0019c	90		 npad	 1
  0019d	b8 00 00 00 00	 mov	 eax, $LN18@Ipfx
  001a2	c3		 ret	 0
$LN14@Ipfx:
  001a3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001aa	eb 07		 jmp	 SHORT $LN17@Ipfx
$LN18@Ipfx:
  001ac	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN17@Ipfx:

; 139  :         }
; 140  : 
; 141  :         if (_Eof) {

  001b3	0f b6 45 ef	 movzx	 eax, BYTE PTR __Eof$[ebp]
  001b7	85 c0		 test	 eax, eax
  001b9	74 15		 je	 SHORT $LN12@Ipfx

; 142  :             _Myios::setstate(ios_base::eofbit | ios_base::failbit);

  001bb	6a 00		 push	 0
  001bd	6a 03		 push	 3
  001bf	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c2	8b 11		 mov	 edx, DWORD PTR [ecx]
  001c4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001c7	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001ca	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  001cf	90		 npad	 1
$LN12@Ipfx:

; 143  :         }
; 144  : 
; 145  :         return this->good();

  001d0	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  001d5	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001d8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001db	8b ca		 mov	 ecx, edx
  001dd	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
$LN1@Ipfx:

; 146  :     }

  001e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001ec	59		 pop	 ecx
  001ed	5f		 pop	 edi
  001ee	5e		 pop	 esi
  001ef	5b		 pop	 ebx
  001f0	8b e5		 mov	 esp, ebp
  001f2	5d		 pop	 ebp
  001f3	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z$2:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Ipfx
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -88						; size = 8
tv283 = -80						; size = 8
tv332 = -72						; size = 8
tv320 = -64						; size = 8
tv135 = -56						; size = 8
__Count$ = -48						; size = 8
__Pad$ = -40						; size = 8
$T2 = -32						; size = 4
tv284 = -28						; size = 4
tv137 = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 774  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 48	 sub	 esp, 72			; 00000048H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 775  :     // insert NTBS into char stream
; 776  :     using _Elem = char;
; 777  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 778  : 
; 779  :     ios_base::iostate _State = ios_base::goodbit;

  0002c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 780  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0003c	83 c4 04	 add	 esp, 4
  0003f	33 c9		 xor	 ecx, ecx
  00041	89 45 d0	 mov	 DWORD PTR __Count$[ebp], eax
  00044	89 4d d4	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 781  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00047	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00052	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00057	89 45 c0	 mov	 DWORD PTR tv320[ebp], eax
  0005a	89 55 c4	 mov	 DWORD PTR tv320[ebp+4], edx
  0005d	83 7d c4 00	 cmp	 DWORD PTR tv320[ebp+4], 0
  00061	7c 4e		 jl	 SHORT $LN17@operator
  00063	7f 06		 jg	 SHORT $LN24@operator
  00065	83 7d c0 00	 cmp	 DWORD PTR tv320[ebp], 0
  00069	76 46		 jbe	 SHORT $LN17@operator
$LN24@operator:
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00073	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00076	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  0007b	89 45 b8	 mov	 DWORD PTR tv332[ebp], eax
  0007e	89 55 bc	 mov	 DWORD PTR tv332[ebp+4], edx
  00081	8b 45 bc	 mov	 eax, DWORD PTR tv332[ebp+4]
  00084	3b 45 d4	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  00087	7c 28		 jl	 SHORT $LN17@operator
  00089	7f 08		 jg	 SHORT $LN25@operator
  0008b	8b 4d b8	 mov	 ecx, DWORD PTR tv332[ebp]
  0008e	3b 4d d0	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00091	76 1e		 jbe	 SHORT $LN17@operator
$LN25@operator:
  00093	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00096	8b 02		 mov	 eax, DWORD PTR [edx]
  00098	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0009b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0009e	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  000a3	2b 45 d0	 sub	 eax, DWORD PTR __Count$[ebp]
  000a6	1b 55 d4	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  000a9	89 45 c8	 mov	 DWORD PTR tv135[ebp], eax
  000ac	89 55 cc	 mov	 DWORD PTR tv135[ebp+4], edx
  000af	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000b1	0f 57 c0	 xorps	 xmm0, xmm0
  000b4	66 0f 13 45 c8	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  000b9	8b 4d c8	 mov	 ecx, DWORD PTR tv135[ebp]
  000bc	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp+4]
  000bf	89 4d d8	 mov	 DWORD PTR __Pad$[ebp], ecx
  000c2	89 55 dc	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 782  :     const typename _Myos::sentry _Ok(_Ostr);

  000c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000c8	50		 push	 eax
  000c9	8d 4d a8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000cc	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  000d1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 783  : 
; 784  :     if (!_Ok) {

  000d8	8d 4d a8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000db	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000e0	0f b6 c8	 movzx	 ecx, al
  000e3	85 c9		 test	 ecx, ecx
  000e5	75 0e		 jne	 SHORT $LN8@operator

; 785  :         _State |= ios_base::badbit;

  000e7	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  000ea	83 ca 04	 or	 edx, 4
  000ed	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx

; 786  :     } else { // state okay, insert

  000f0	e9 9e 01 00 00	 jmp	 $LN22@operator
$LN8@operator:

; 787  :         _TRY_IO_BEGIN

  000f5	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 788  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000f9	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000fc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fe	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00101	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00104	8b ca		 mov	 ecx, edx
  00106	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0010b	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00110	83 f8 40	 cmp	 eax, 64			; 00000040H
  00113	74 76		 je	 SHORT $LN3@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00115	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00117	8b 45 d8	 mov	 eax, DWORD PTR __Pad$[ebp]
  0011a	83 e8 01	 sub	 eax, 1
  0011d	8b 4d dc	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00120	83 d9 00	 sbb	 ecx, 0
  00123	89 45 d8	 mov	 DWORD PTR __Pad$[ebp], eax
  00126	89 4d dc	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  00129	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  0012d	7c 5c		 jl	 SHORT $LN3@operator
  0012f	7f 06		 jg	 SHORT $LN26@operator
  00131	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00135	76 54		 jbe	 SHORT $LN3@operator
$LN26@operator:

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00137	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0013a	8b 02		 mov	 eax, DWORD PTR [edx]
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0013f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00142	e8 00 00 00 00	 call	 ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
  00147	0f b6 c8	 movzx	 ecx, al
  0014a	51		 push	 ecx
  0014b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0014e	8b 02		 mov	 eax, DWORD PTR [edx]
  00150	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00153	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00156	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0015b	8b c8		 mov	 ecx, eax
  0015d	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  00162	89 45 e8	 mov	 DWORD PTR tv137[ebp], eax
  00165	8b 4d e8	 mov	 ecx, DWORD PTR tv137[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0016e	50		 push	 eax
  0016f	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00174	83 c4 08	 add	 esp, 8
  00177	0f b6 d0	 movzx	 edx, al
  0017a	85 d2		 test	 edx, edx
  0017c	74 0b		 je	 SHORT $LN12@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

  0017e	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00181	83 c8 04	 or	 eax, 4
  00184	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 792  :                     break;

  00187	eb 02		 jmp	 SHORT $LN3@operator
$LN12@operator:

; 793  :                 }
; 794  :             }

  00189	eb 8c		 jmp	 SHORT $LN2@operator
$LN3@operator:

; 795  :         }
; 796  : 
; 797  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0018b	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  0018f	75 42		 jne	 SHORT $LN13@operator
  00191	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  00194	51		 push	 ecx
  00195	8b 55 d0	 mov	 edx, DWORD PTR __Count$[ebp]
  00198	52		 push	 edx
  00199	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0019c	50		 push	 eax
  0019d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001a2	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001a5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001a8	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  001ad	8b c8		 mov	 ecx, eax
  001af	e8 00 00 00 00	 call	 ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
  001b4	89 45 b0	 mov	 DWORD PTR tv283[ebp], eax
  001b7	89 55 b4	 mov	 DWORD PTR tv283[ebp+4], edx
  001ba	8b 45 b0	 mov	 eax, DWORD PTR tv283[ebp]
  001bd	3b 45 d0	 cmp	 eax, DWORD PTR __Count$[ebp]
  001c0	75 08		 jne	 SHORT $LN27@operator
  001c2	8b 4d b4	 mov	 ecx, DWORD PTR tv283[ebp+4]
  001c5	3b 4d d4	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  001c8	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 798  :             _State |= ios_base::badbit;

  001ca	8b 55 ec	 mov	 edx, DWORD PTR __State$[ebp]
  001cd	83 ca 04	 or	 edx, 4
  001d0	89 55 ec	 mov	 DWORD PTR __State$[ebp], edx
$LN13@operator:

; 799  :         }
; 800  : 
; 801  :         if (_State == ios_base::goodbit) {

  001d3	83 7d ec 00	 cmp	 DWORD PTR __State$[ebp], 0
  001d7	75 76		 jne	 SHORT $LN6@operator

; 802  :             for (; 0 < _Pad; --_Pad) { // pad on right

  001d9	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  001db	8b 45 d8	 mov	 eax, DWORD PTR __Pad$[ebp]
  001de	83 e8 01	 sub	 eax, 1
  001e1	8b 4d dc	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  001e4	83 d9 00	 sbb	 ecx, 0
  001e7	89 45 d8	 mov	 DWORD PTR __Pad$[ebp], eax
  001ea	89 4d dc	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  001ed	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  001f1	7c 5c		 jl	 SHORT $LN6@operator
  001f3	7f 06		 jg	 SHORT $LN28@operator
  001f5	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001f9	76 54		 jbe	 SHORT $LN6@operator
$LN28@operator:

; 803  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001fb	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001fe	8b 02		 mov	 eax, DWORD PTR [edx]
  00200	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00203	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00206	e8 00 00 00 00	 call	 ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
  0020b	0f b6 c8	 movzx	 ecx, al
  0020e	51		 push	 ecx
  0020f	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00212	8b 02		 mov	 eax, DWORD PTR [edx]
  00214	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00217	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0021a	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0021f	8b c8		 mov	 ecx, eax
  00221	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  00226	89 45 e4	 mov	 DWORD PTR tv284[ebp], eax
  00229	8b 4d e4	 mov	 ecx, DWORD PTR tv284[ebp]
  0022c	51		 push	 ecx
  0022d	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00238	83 c4 08	 add	 esp, 8
  0023b	0f b6 d0	 movzx	 edx, al
  0023e	85 d2		 test	 edx, edx
  00240	74 0b		 je	 SHORT $LN15@operator

; 804  :                     _State |= ios_base::badbit; // insertion failed, quit

  00242	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00245	83 c8 04	 or	 eax, 4
  00248	89 45 ec	 mov	 DWORD PTR __State$[ebp], eax

; 805  :                     break;

  0024b	eb 02		 jmp	 SHORT $LN6@operator
$LN15@operator:

; 806  :                 }
; 807  :             }

  0024d	eb 8c		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 808  :         }
; 809  : 
; 810  :         _Ostr.width(0);

  0024f	6a 00		 push	 0
  00251	6a 00		 push	 0
  00253	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00256	8b 11		 mov	 edx, DWORD PTR [ecx]
  00258	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0025b	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0025e	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width
  00263	90		 npad	 1
  00264	eb 1d		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 811  :         _CATCH_IO_(ios_base, _Ostr)

  00266	6a 01		 push	 1
  00268	6a 04		 push	 4
  0026a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0026d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0026f	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00272	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00275	8b ca		 mov	 ecx, edx
  00277	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0027c	90		 npad	 1
  0027d	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00282	c3		 ret	 0
$LN19@operator:
  00283	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0028a	eb 07		 jmp	 SHORT $LN22@operator
$LN23@operator:
  0028c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN22@operator:

; 812  :     }
; 813  : 
; 814  :     _Ostr.setstate(_State);

  00293	6a 00		 push	 0
  00295	8b 45 ec	 mov	 eax, DWORD PTR __State$[ebp]
  00298	50		 push	 eax
  00299	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0029c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0029e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002a1	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  002a4	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  002a9	90		 npad	 1

; 815  :     return _Ostr;

  002aa	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002ad	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  002b0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002b7	8d 4d a8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  002ba	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  002bf	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 816  : }

  002c2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002c5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002cc	59		 pop	 ecx
  002cd	5f		 pop	 edi
  002ce	5e		 pop	 esi
  002cf	5b		 pop	 ebx
  002d0	8b e5		 mov	 esp, ebp
  002d2	5d		 pop	 ebp
  002d3	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d a8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a4	 mov	 ecx, DWORD PTR [edx-92]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$2 = -40						; size = 8
tv77 = -32						; size = 4
__Rdbuf$ = -28						; size = 4
__State$3 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 568  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 18	 sub	 esp, 24			; 00000018H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 569  :         const auto _Rdbuf = _Myios::rdbuf();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00037	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0003a	8b ca		 mov	 ecx, edx
  0003c	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00041	89 45 e4	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 570  :         if (_Rdbuf) { // buffer exists, flush it

  00044	83 7d e4 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00048	0f 84 9d 00 00
	00		 je	 $LN2@flush

; 571  :             const sentry _Ok(*this);

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	50		 push	 eax
  00052	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00055	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 572  : 
; 573  :             if (_Ok) {

  00061	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00064	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00069	0f b6 c8	 movzx	 ecx, al
  0006c	85 c9		 test	 ecx, ecx
  0006e	74 6b		 je	 SHORT $LN3@flush

; 574  :                 ios_base::iostate _State = ios_base::goodbit;

  00070	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$3[ebp], 0

; 575  :                 _TRY_IO_BEGIN

  00077	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 576  :                 if (_Rdbuf->pubsync() == -1) {

  0007b	8b 4d e4	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0007e	e8 00 00 00 00	 call	 ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
  00083	89 45 e0	 mov	 DWORD PTR tv77[ebp], eax
  00086	83 7d e0 ff	 cmp	 DWORD PTR tv77[ebp], -1
  0008a	75 09		 jne	 SHORT $LN5@flush

; 577  :                     _State |= ios_base::badbit; // sync failed

  0008c	8b 55 e8	 mov	 edx, DWORD PTR __State$3[ebp]
  0008f	83 ca 04	 or	 edx, 4
  00092	89 55 e8	 mov	 DWORD PTR __State$3[ebp], edx
$LN5@flush:
  00095	eb 1d		 jmp	 SHORT $LN7@flush
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:

; 578  :                 }
; 579  :                 _CATCH_IO_END

  00097	6a 01		 push	 1
  00099	6a 04		 push	 4
  0009b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a0	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000a3	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000a6	8b ca		 mov	 ecx, edx
  000a8	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000ad	90		 npad	 1
  000ae	b8 00 00 00 00	 mov	 eax, $LN11@flush
  000b3	c3		 ret	 0
$LN7@flush:
  000b4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000bb	eb 07		 jmp	 SHORT $LN10@flush
$LN11@flush:
  000bd	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN10@flush:

; 580  :                 _Myios::setstate(_State);

  000c4	6a 00		 push	 0
  000c6	8b 45 e8	 mov	 eax, DWORD PTR __State$3[ebp]
  000c9	50		 push	 eax
  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cf	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000d5	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000da	90		 npad	 1
$LN3@flush:

; 581  :             }
; 582  :         }

  000db	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000e2	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  000e5	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  000ea	90		 npad	 1
$LN2@flush:

; 583  :         return *this;

  000eb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 584  :     }

  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000f1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f8	59		 pop	 ecx
  000f9	5f		 pop	 edi
  000fa	5e		 pop	 esi
  000fb	5b		 pop	 ebx
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
$T2 = -32						; size = 4
tv65 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 531  :     basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch) { // insert a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 18	 sub	 esp, 24			; 00000018H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 532  :         ios_base::iostate _State = ios_base::goodbit;

  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 533  :         const sentry _Ok(*this);

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 534  : 
; 535  :         if (!_Ok) {

  00049	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0004c	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00051	0f b6 c8	 movzx	 ecx, al
  00054	85 c9		 test	 ecx, ecx
  00056	75 0b		 jne	 SHORT $LN2@put

; 536  :             _State |= ios_base::badbit;

  00058	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  0005b	83 ca 04	 or	 edx, 4
  0005e	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx

; 537  :         } else { // state okay, insert character

  00061	eb 74		 jmp	 SHORT $LN10@put
$LN2@put:

; 538  :             _TRY_IO_BEGIN

  00063	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 539  :             if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {

  00067	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00071	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00074	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00077	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0007c	8b c8		 mov	 ecx, eax
  0007e	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  00083	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  00086	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00095	83 c4 08	 add	 esp, 8
  00098	0f b6 c8	 movzx	 ecx, al
  0009b	85 c9		 test	 ecx, ecx
  0009d	74 09		 je	 SHORT $LN5@put

; 540  :                 _State |= ios_base::badbit;

  0009f	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  000a2	83 ca 04	 or	 edx, 4
  000a5	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx
$LN5@put:
  000a8	eb 1d		 jmp	 SHORT $LN7@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:

; 541  :             }
; 542  :             _CATCH_IO_END

  000aa	6a 01		 push	 1
  000ac	6a 04		 push	 4
  000ae	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b3	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000b6	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000b9	8b ca		 mov	 ecx, edx
  000bb	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000c0	90		 npad	 1
  000c1	b8 00 00 00 00	 mov	 eax, $LN11@put
  000c6	c3		 ret	 0
$LN7@put:
  000c7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  000ce	eb 07		 jmp	 SHORT $LN10@put
$LN11@put:
  000d0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN10@put:

; 543  :         }
; 544  : 
; 545  :         _Myios::setstate(_State);

  000d7	6a 00		 push	 0
  000d9	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  000dc	50		 push	 eax
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000e8	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000ed	90		 npad	 1

; 546  :         return *this;

  000ee	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  000f4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000fb	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000fe	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00103	8b 45 e0	 mov	 eax, DWORD PTR $T2[ebp]

; 547  :     }

  00106	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00109	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00110	59		 pop	 ecx
  00111	5f		 pop	 edi
  00112	5e		 pop	 esi
  00113	5b		 pop	 ebx
  00114	8b e5		 mov	 esp, ebp
  00116	5d		 pop	 ebp
  00117	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
$T2 = -84						; size = 8
$T3 = -76						; size = 8
$T4 = -68						; size = 8
__Ok$ = -60						; size = 8
$T5 = -52						; size = 4
tv209 = -48						; size = 4
__Nput_fac$6 = -44					; size = 4
tv206 = -40						; size = 4
tv65 = -36						; size = 4
__Tmp$7 = -32						; size = 4
__Bfl$8 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Val$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 283  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(int _Val) { // insert an int

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 44	 sub	 esp, 68			; 00000044H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 284  :         ios_base::iostate _State = ios_base::goodbit;

  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 285  :         const sentry _Ok(*this);

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d c4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 286  : 
; 287  :         if (_Ok) { // state okay, use facet to insert

  00049	8d 4d c4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0004c	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00051	0f b6 c8	 movzx	 ecx, al
  00054	85 c9		 test	 ecx, ecx
  00056	0f 84 15 01 00
	00		 je	 $LN13@operator

; 288  :             const _Nput& _Nput_fac  = _STD use_facet<_Nput>(this->getloc());

  0005c	8d 55 bc	 lea	 edx, DWORD PTR $T4[ebp]
  0005f	52		 push	 edx
  00060	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00063	8b 08		 mov	 ecx, DWORD PTR [eax]
  00065	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00068	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006b	8b ca		 mov	 ecx, edx
  0006d	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00072	89 45 dc	 mov	 DWORD PTR tv65[ebp], eax
  00075	8b 45 dc	 mov	 eax, DWORD PTR tv65[ebp]
  00078	89 45 d8	 mov	 DWORD PTR tv206[ebp], eax
  0007b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  0007f	8b 4d d8	 mov	 ecx, DWORD PTR tv206[ebp]
  00082	51		 push	 ecx
  00083	e8 00 00 00 00	 call	 ??$use_facet@V?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@@std@@YAABV?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@0@ABVlocale@0@@Z ; std::use_facet<std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > >
  00088	83 c4 04	 add	 esp, 4
  0008b	89 45 d4	 mov	 DWORD PTR __Nput_fac$6[ebp], eax
  0008e	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+12], 0
  00092	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  00095	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0009a	90		 npad	 1

; 289  :             ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

  0009b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000a6	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  000ab	25 00 0e 00 00	 and	 eax, 3584		; 00000e00H
  000b0	89 45 e4	 mov	 DWORD PTR __Bfl$8[ebp], eax

; 290  : 
; 291  :             long _Tmp;
; 292  :             if (_Bfl == ios_base::oct || _Bfl == ios_base::hex) {

  000b3	81 7d e4 00 04
	00 00		 cmp	 DWORD PTR __Bfl$8[ebp], 1024 ; 00000400H
  000ba	74 09		 je	 SHORT $LN5@operator
  000bc	81 7d e4 00 08
	00 00		 cmp	 DWORD PTR __Bfl$8[ebp], 2048 ; 00000800H
  000c3	75 08		 jne	 SHORT $LN3@operator
$LN5@operator:

; 293  :                 _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));

  000c5	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  000c8	89 4d e0	 mov	 DWORD PTR __Tmp$7[ebp], ecx

; 294  :             } else {

  000cb	eb 06		 jmp	 SHORT $LN4@operator
$LN3@operator:

; 295  :                 _Tmp = static_cast<long>(_Val);

  000cd	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000d0	89 55 e0	 mov	 DWORD PTR __Tmp$7[ebp], edx
$LN4@operator:

; 296  :             }
; 297  : 
; 298  :             _TRY_IO_BEGIN

  000d3	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 299  :             if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed()) {

  000d7	8b 45 e0	 mov	 eax, DWORD PTR __Tmp$7[ebp]
  000da	50		 push	 eax
  000db	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000e6	e8 00 00 00 00	 call	 ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
  000eb	0f b6 c0	 movzx	 eax, al
  000ee	50		 push	 eax
  000ef	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f2	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f4	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f7	03 42 04	 add	 eax, DWORD PTR [edx+4]
  000fa	50		 push	 eax
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	8b 11		 mov	 edx, DWORD PTR [ecx]
  00100	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00103	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00106	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  0010b	50		 push	 eax
  0010c	8d 4d b4	 lea	 ecx, DWORD PTR $T3[ebp]
  0010f	e8 00 00 00 00	 call	 ??0?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z ; std::ostreambuf_iterator<char,std::char_traits<char> >::ostreambuf_iterator<char,std::char_traits<char> >
  00114	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00117	51		 push	 ecx
  00118	8b 10		 mov	 edx, DWORD PTR [eax]
  0011a	52		 push	 edx
  0011b	8d 45 ac	 lea	 eax, DWORD PTR $T2[ebp]
  0011e	50		 push	 eax
  0011f	8b 4d d4	 mov	 ecx, DWORD PTR __Nput_fac$6[ebp]
  00122	e8 00 00 00 00	 call	 ?put@?$num_put@DV?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@QBE?AV?$ostreambuf_iterator@DU?$char_traits@D@std@@@2@V32@AAVios_base@2@DJ@Z ; std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >::put
  00127	89 45 d0	 mov	 DWORD PTR tv209[ebp], eax
  0012a	8b 4d d0	 mov	 ecx, DWORD PTR tv209[ebp]
  0012d	e8 00 00 00 00	 call	 ?failed@?$ostreambuf_iterator@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::ostreambuf_iterator<char,std::char_traits<char> >::failed
  00132	0f b6 c8	 movzx	 ecx, al
  00135	85 c9		 test	 ecx, ecx
  00137	74 09		 je	 SHORT $LN7@operator

; 300  :                 _State |= ios_base::badbit;

  00139	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  0013c	83 ca 04	 or	 edx, 4
  0013f	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx
$LN7@operator:
  00142	eb 1d		 jmp	 SHORT $LN9@operator
__catch$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$0:

; 301  :             }
; 302  :             _CATCH_IO_END

  00144	6a 01		 push	 1
  00146	6a 04		 push	 4
  00148	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0014b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0014d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00150	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00153	8b ca		 mov	 ecx, edx
  00155	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0015a	90		 npad	 1
  0015b	b8 00 00 00 00	 mov	 eax, $LN14@operator
  00160	c3		 ret	 0
$LN9@operator:
  00161	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00168	eb 07		 jmp	 SHORT $LN13@operator
$LN14@operator:
  0016a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator:

; 303  :         }
; 304  : 
; 305  :         _Myios::setstate(_State);

  00171	6a 00		 push	 0
  00173	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00176	50		 push	 eax
  00177	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0017c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0017f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00182	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  00187	90		 npad	 1

; 306  :         return *this;

  00188	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018b	89 45 cc	 mov	 DWORD PTR $T5[ebp], eax
  0018e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00195	8d 4d c4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00198	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0019d	8b 45 cc	 mov	 eax, DWORD PTR $T5[ebp]

; 307  :     }

  001a0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  001a3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001aa	59		 pop	 ecx
  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$2:
  00000	8d 4d c4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z$3:
  00008	8d 4d bc	 lea	 ecx, DWORD PTR $T4[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 195  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 196  :         // call basic_ostream manipulator
; 197  :         return _Pfn(*this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	ff 55 08	 call	 DWORD PTR __Pfn$[ebp]
  0000e	83 c4 04	 add	 esp, 4

; 198  :     }

  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c2 04 00	 ret	 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv149 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 165  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 08	 sub	 esp, 8
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 166  :         _TRY_BEGIN

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 167  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00041	8b ca		 mov	 ecx, edx
  00043	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 4e		 je	 SHORT $LN4@Osfx
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0005a	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0005f	83 e0 02	 and	 eax, 2
  00062	74 39		 je	 SHORT $LN4@Osfx

; 168  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00064	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00076	8b c8		 mov	 ecx, eax
  00078	e8 00 00 00 00	 call	 ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
  0007d	89 45 e8	 mov	 DWORD PTR tv149[ebp], eax
  00080	83 7d e8 ff	 cmp	 DWORD PTR tv149[ebp], -1
  00084	75 17		 jne	 SHORT $LN4@Osfx

; 169  :                 _Myios::setstate(ios_base::badbit);

  00086	6a 00		 push	 0
  00088	6a 04		 push	 4
  0008a	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00092	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00095	8b ca		 mov	 ecx, edx
  00097	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  0009c	90		 npad	 1
$LN4@Osfx:
  0009d	eb 06		 jmp	 SHORT $LN7@Osfx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 170  :             }
; 171  :         }
; 172  :         _CATCH_ALL
; 173  :         _CATCH_END

  0009f	b8 00 00 00 00	 mov	 eax, $LN10@Osfx
  000a4	c3		 ret	 0
$LN7@Osfx:
  000a5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000ac	eb 07		 jmp	 SHORT $LN9@Osfx
$LN10@Osfx:
  000ae	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN9@Osfx:

; 174  :     }

  000b5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bf	59		 pop	 ecx
  000c0	5f		 pop	 edi
  000c1	5e		 pop	 esi
  000c2	5b		 pop	 ebx
  000c3	8b e5		 mov	 esp, ebp
  000c5	5d		 pop	 ebp
  000c6	c3		 ret	 0
  000c7	cc		 int	 3
  000c8	cc		 int	 3
  000c9	cc		 int	 3
  000ca	cc		 int	 3
  000cb	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T2 = -36						; size = 8
tv79 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 112  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 113  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  00028	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]
  0002c	50		 push	 eax
  0002d	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00030	51		 push	 ecx
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00039	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003c	8b 55 e8	 mov	 edx, DWORD PTR tv80[ebp]
  0003f	89 55 e4	 mov	 DWORD PTR tv79[ebp], edx
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00049	8b 45 e4	 mov	 eax, DWORD PTR tv79[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  00052	83 c4 04	 add	 esp, 4
  00055	8b c8		 mov	 ecx, eax
  00057	e8 00 00 00 00	 call	 ?widen@?$ctype@D@std@@QBEDD@Z ; std::ctype<char>::widen
  0005c	88 45 f3	 mov	 BYTE PTR $T3[ebp], al
  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00069	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  0006e	0f b6 45 f3	 movzx	 eax, BYTE PTR $T3[ebp]

; 114  :     }

  00072	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00075	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007c	59		 pop	 ecx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 98   :     _Elem __CLR_OR_THIS_CALL fill() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   :         return _Fillch;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 40	 movzx	 eax, BYTE PTR [eax+64]

; 100  :     }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 77   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   :         return _Mystrbuf;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 79   :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 67   :     _Myos* __CLR_OR_THIS_CALL tie() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   :         return _Tiestr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]

; 69   :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);

  00007	0f b6 45 0c	 movzx	 eax, BYTE PTR __Reraise$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate
  00014	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
  00020	90		 npad	 1

; 52   :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv72 = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 38   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :         // set state, possibly reraise exception
; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00010	74 09		 je	 SHORT $LN3@clear
  00012	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  00019	eb 07		 jmp	 SHORT $LN4@clear
$LN3@clear:
  0001b	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR tv72[ebp], 4
$LN4@clear:
  00022	0f b6 4d 0c	 movzx	 ecx, BYTE PTR __Reraise$[ebp]
  00026	51		 push	 ecx
  00027	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  0002a	0b 55 fc	 or	 edx, DWORD PTR tv72[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear
  00036	90		 npad	 1

; 41   :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\kpo_lab1.cpp
_TEXT	SEGMENT
$T2 = -328						; size = 12
$T3 = -316						; size = 12
$T4 = -304						; size = 12
$T5 = -292						; size = 12
$T6 = -280						; size = 12
$T7 = -268						; size = 12
_bday_year$ = -256					; size = 4
$T8 = -252						; size = 4
$T9 = -248						; size = 4
$T10 = -244						; size = 4
$T11 = -240						; size = 4
$T12 = -236						; size = 4
$T13 = -232						; size = 4
$T14 = -228						; size = 4
$T15 = -224						; size = 4
$T16 = -220						; size = 4
$T17 = -216						; size = 4
$T18 = -212						; size = 4
$T19 = -208						; size = 4
$T20 = -204						; size = 4
$T21 = -200						; size = 4
$T22 = -196						; size = 4
$T23 = -192						; size = 4
tv340 = -188						; size = 4
tv459 = -184						; size = 4
tv457 = -180						; size = 4
tv287 = -176						; size = 4
tv453 = -172						; size = 4
tv451 = -168						; size = 4
tv266 = -164						; size = 4
tv447 = -160						; size = 4
tv445 = -156						; size = 4
$T24 = -152						; size = 4
$T25 = -148						; size = 4
$T26 = -144						; size = 4
$T27 = -140						; size = 4
$T28 = -136						; size = 4
$T29 = -132						; size = 4
tv186 = -128						; size = 4
tv439 = -124						; size = 4
tv437 = -120						; size = 4
tv165 = -116						; size = 4
tv433 = -112						; size = 4
tv431 = -108						; size = 4
tv144 = -104						; size = 4
tv427 = -100						; size = 4
tv425 = -96						; size = 4
tv395 = -92						; size = 4
tv361 = -88						; size = 4
_temp_cur_year$30 = -84					; size = 4
_bday_month$ = -80					; size = 4
_bday_day$ = -76					; size = 4
_bday_serial_number$ = -72				; size = 4
_cur_serial_number$ = -68				; size = 4
_temp_cur_year$31 = -64					; size = 4
_cur_day$ = -60						; size = 4
_remaining_days_for_bday$ = -56				; size = 4
_cur_month$ = -52					; size = 4
_cur_year$ = -48					; size = 4
_is_viscos$ = -41					; size = 1
_current_date$ = -40					; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 16   : 	setlocale(LC_ALL, "Russian");

  0002b	68 00 00 00 00	 push	 OFFSET $SG37478
  00030	6a 00		 push	 0
  00032	e8 00 00 00 00	 call	 _setlocale
  00037	83 c4 08	 add	 esp, 8

; 17   : 	string current_date;

  0003a	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00042	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 18   : 	cout << "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ (–î–î–ú–ú–ì–ì–ì–ì): ";

  00049	68 00 00 00 00	 push	 OFFSET $SG37479
  0004e	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00053	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00058	83 c4 08	 add	 esp, 8

; 19   : 	cin >> current_date;

  0005b	8d 45 d8	 lea	 eax, DWORD PTR _current_date$[ebp]
  0005e	50		 push	 eax
  0005f	68 00 00 00 00	 push	 OFFSET ?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A ; std::cin
  00064	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
  00069	83 c4 08	 add	 esp, 8

; 20   : 
; 21   : 	// –í–∞–ª–∏–¥–∞—Ü–∏—è —Å—Ç—Ä–æ–∫–∏ —Å –ø–æ–º–æ—â—å—é —É–Ω–∞—Ä–Ω–æ–≥–æ –ø—Ä–µ–¥–∏–∫–∞—Ç–∞
; 22   : 	if (!all_of(current_date.begin(), current_date.end(), ::isdigit) || current_date.length() != 8)

  0006c	68 00 00 00 00	 push	 OFFSET _isdigit
  00071	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  00077	51		 push	 ecx
  00078	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  0007b	e8 00 00 00 00	 call	 ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
  00080	8b 10		 mov	 edx, DWORD PTR [eax]
  00082	52		 push	 edx
  00083	8d 85 38 ff ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00089	50		 push	 eax
  0008a	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  0008d	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ??$all_of@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@P6AHH@Z@std@@YA_NV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@0@0P6AHH@Z@Z ; std::all_of<std::_String_iterator<std::_String_val<std::_Simple_types<char> > >,int (__cdecl*)(int)>
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	0f b6 d0	 movzx	 edx, al
  000a0	85 d2		 test	 edx, edx
  000a2	74 0d		 je	 SHORT $LN7@main
  000a4	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  000a7	e8 00 00 00 00	 call	 ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
  000ac	83 f8 08	 cmp	 eax, 8
  000af	74 43		 je	 SHORT $LN6@main
$LN7@main:

; 23   : 	{
; 24   : 		cerr << "–û—à–∏–±–∫–∞! –í–≤–µ–¥–µ–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –¥–∞—Ç–∞" << endl;

  000b1	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b6	68 00 00 00 00	 push	 OFFSET $SG37482
  000bb	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  000c0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c5	83 c4 08	 add	 esp, 8
  000c8	8b c8		 mov	 ecx, eax
  000ca	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  000cf	90		 npad	 1

; 25   : 		return 1;

  000d0	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T22[ebp], 1
  000da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e1	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  000e4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000e9	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T22[ebp]
  000ef	e9 81 05 00 00	 jmp	 $LN1@main
$LN6@main:

; 26   : 	}
; 27   : 
; 28   : 	int cur_day = splitData(current_date)[0];

  000f4	6a 00		 push	 0
  000f6	83 ec 18	 sub	 esp, 24			; 00000018H
  000f9	8b cc		 mov	 ecx, esp
  000fb	89 a5 34 ff ff
	ff		 mov	 DWORD PTR $T20[ebp], esp
  00101	8d 45 d8	 lea	 eax, DWORD PTR _current_date$[ebp]
  00104	50		 push	 eax
  00105	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0010a	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  00116	83 c4 1c	 add	 esp, 28			; 0000001cH
  00119	89 45 a0	 mov	 DWORD PTR tv425[ebp], eax
  0011c	8b 55 a0	 mov	 edx, DWORD PTR tv425[ebp]
  0011f	89 55 9c	 mov	 DWORD PTR tv427[ebp], edx
  00122	8b 4d 9c	 mov	 ecx, DWORD PTR tv427[ebp]
  00125	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  0012a	89 45 98	 mov	 DWORD PTR tv144[ebp], eax
  0012d	8b 45 98	 mov	 eax, DWORD PTR tv144[ebp]
  00130	8b 08		 mov	 ecx, DWORD PTR [eax]
  00132	89 4d c4	 mov	 DWORD PTR _cur_day$[ebp], ecx
  00135	8d 8d f4 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0013b	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00140	90		 npad	 1

; 29   : 	int cur_month = splitData(current_date)[1];

  00141	6a 01		 push	 1
  00143	83 ec 18	 sub	 esp, 24			; 00000018H
  00146	8b cc		 mov	 ecx, esp
  00148	89 a5 30 ff ff
	ff		 mov	 DWORD PTR $T19[ebp], esp
  0014e	8d 55 d8	 lea	 edx, DWORD PTR _current_date$[ebp]
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00157	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0015d	50		 push	 eax
  0015e	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  00163	83 c4 1c	 add	 esp, 28			; 0000001cH
  00166	89 45 94	 mov	 DWORD PTR tv431[ebp], eax
  00169	8b 4d 94	 mov	 ecx, DWORD PTR tv431[ebp]
  0016c	89 4d 90	 mov	 DWORD PTR tv433[ebp], ecx
  0016f	8b 4d 90	 mov	 ecx, DWORD PTR tv433[ebp]
  00172	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00177	89 45 8c	 mov	 DWORD PTR tv165[ebp], eax
  0017a	8b 55 8c	 mov	 edx, DWORD PTR tv165[ebp]
  0017d	8b 02		 mov	 eax, DWORD PTR [edx]
  0017f	89 45 cc	 mov	 DWORD PTR _cur_month$[ebp], eax
  00182	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00188	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0018d	90		 npad	 1

; 30   : 	int cur_year = splitData(current_date)[2];

  0018e	6a 02		 push	 2
  00190	83 ec 18	 sub	 esp, 24			; 00000018H
  00193	8b cc		 mov	 ecx, esp
  00195	89 a5 2c ff ff
	ff		 mov	 DWORD PTR $T18[ebp], esp
  0019b	8d 55 d8	 lea	 edx, DWORD PTR _current_date$[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a4	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  001b0	83 c4 1c	 add	 esp, 28			; 0000001cH
  001b3	89 45 88	 mov	 DWORD PTR tv437[ebp], eax
  001b6	8b 4d 88	 mov	 ecx, DWORD PTR tv437[ebp]
  001b9	89 4d 84	 mov	 DWORD PTR tv439[ebp], ecx
  001bc	8b 4d 84	 mov	 ecx, DWORD PTR tv439[ebp]
  001bf	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  001c4	89 45 80	 mov	 DWORD PTR tv186[ebp], eax
  001c7	8b 55 80	 mov	 edx, DWORD PTR tv186[ebp]
  001ca	8b 02		 mov	 eax, DWORD PTR [edx]
  001cc	89 45 d0	 mov	 DWORD PTR _cur_year$[ebp], eax
  001cf	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  001d5	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  001da	90		 npad	 1

; 31   : 
; 32   : 	bool is_viscos;
; 33   : 	if (is_viscos = detViscosity(cur_year))

  001db	8b 4d d0	 mov	 ecx, DWORD PTR _cur_year$[ebp]
  001de	51		 push	 ecx
  001df	e8 00 00 00 00	 call	 ?detViscosity@@YA_NH@Z	; detViscosity
  001e4	83 c4 04	 add	 esp, 4
  001e7	88 45 d7	 mov	 BYTE PTR _is_viscos$[ebp], al
  001ea	0f b6 55 d7	 movzx	 edx, BYTE PTR _is_viscos$[ebp]
  001ee	85 d2		 test	 edx, edx
  001f0	74 55		 je	 SHORT $LN8@main

; 34   : 	{
; 35   : 		days_in_months.insert(days_in_months.begin() + 1, 29);

  001f2	c7 85 7c ff ff
	ff 1d 00 00 00	 mov	 DWORD PTR $T29[ebp], 29	; 0000001dH
  001fc	6a 01		 push	 1
  001fe	8d 85 28 ff ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00204	50		 push	 eax
  00205	8d 8d 24 ff ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  0020b	51		 push	 ecx
  0020c	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00211	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
  00216	8b c8		 mov	 ecx, eax
  00218	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
  0021d	8b 10		 mov	 edx, DWORD PTR [eax]
  0021f	89 95 78 ff ff
	ff		 mov	 DWORD PTR $T28[ebp], edx
  00225	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T29[ebp]
  0022b	50		 push	 eax
  0022c	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T28[ebp]
  00232	51		 push	 ecx
  00233	8d 95 04 ff ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00239	52		 push	 edx
  0023a	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  0023f	e8 00 00 00 00	 call	 ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z ; std::vector<int,std::allocator<int> >::insert
  00244	90		 npad	 1

; 36   : 	}

  00245	eb 53		 jmp	 SHORT $LN9@main
$LN8@main:

; 37   : 	else
; 38   : 	{
; 39   : 		days_in_months.insert(days_in_months.begin() + 1, 28);

  00247	c7 85 74 ff ff
	ff 1c 00 00 00	 mov	 DWORD PTR $T27[ebp], 28	; 0000001cH
  00251	6a 01		 push	 1
  00253	8d 85 1c ff ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00259	50		 push	 eax
  0025a	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00260	51		 push	 ecx
  00261	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00266	e8 00 00 00 00	 call	 ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
  0026b	8b c8		 mov	 ecx, eax
  0026d	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator+
  00272	8b 10		 mov	 edx, DWORD PTR [eax]
  00274	89 95 70 ff ff
	ff		 mov	 DWORD PTR $T26[ebp], edx
  0027a	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR $T27[ebp]
  00280	50		 push	 eax
  00281	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T26[ebp]
  00287	51		 push	 ecx
  00288	8d 95 14 ff ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  0028e	52		 push	 edx
  0028f	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00294	e8 00 00 00 00	 call	 ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z ; std::vector<int,std::allocator<int> >::insert
  00299	90		 npad	 1
$LN9@main:

; 40   : 	}
; 41   : 
; 42   : 	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å –≤–≤–µ–¥–µ–Ω–Ω—ã—Ö —á–∏—Å–µ–ª
; 43   : 	if (cur_month > 12 || cur_day > days_in_months[cur_month - 1])

  0029a	83 7d cc 0c	 cmp	 DWORD PTR _cur_month$[ebp], 12 ; 0000000cH
  0029e	7f 18		 jg	 SHORT $LN11@main
  002a0	8b 45 cc	 mov	 eax, DWORD PTR _cur_month$[ebp]
  002a3	83 e8 01	 sub	 eax, 1
  002a6	50		 push	 eax
  002a7	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  002ac	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  002b1	8b 4d c4	 mov	 ecx, DWORD PTR _cur_day$[ebp]
  002b4	3b 08		 cmp	 ecx, DWORD PTR [eax]
  002b6	7e 43		 jle	 SHORT $LN10@main
$LN11@main:

; 44   : 	{
; 45   : 		cerr << "–û—à–∏–±–∫–∞! –í–≤–µ–¥–µ–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –¥–∞—Ç–∞" << endl;

  002b8	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002bd	68 00 00 00 00	 push	 OFFSET $SG37488
  002c2	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  002c7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002cc	83 c4 08	 add	 esp, 8
  002cf	8b c8		 mov	 ecx, eax
  002d1	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  002d6	90		 npad	 1

; 46   : 		return 1;

  002d7	c7 85 6c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T25[ebp], 1
  002e1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002e8	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  002eb	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  002f0	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  002f6	e9 7a 03 00 00	 jmp	 $LN1@main
$LN10@main:

; 47   : 	}
; 48   : 
; 49   : 	if (cur_year == 0 || cur_month == 0 || cur_day == 0)

  002fb	83 7d d0 00	 cmp	 DWORD PTR _cur_year$[ebp], 0
  002ff	74 0c		 je	 SHORT $LN13@main
  00301	83 7d cc 00	 cmp	 DWORD PTR _cur_month$[ebp], 0
  00305	74 06		 je	 SHORT $LN13@main
  00307	83 7d c4 00	 cmp	 DWORD PTR _cur_day$[ebp], 0
  0030b	75 43		 jne	 SHORT $LN12@main
$LN13@main:

; 50   : 	{
; 51   : 		cerr << "–û—à–∏–±–∫–∞! –í–≤–µ–¥–µ–Ω–∞ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∞—è –¥–∞—Ç–∞" << endl;

  0030d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00312	68 00 00 00 00	 push	 OFFSET $SG37492
  00317	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0031c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00321	83 c4 08	 add	 esp, 8
  00324	8b c8		 mov	 ecx, eax
  00326	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  0032b	90		 npad	 1

; 52   : 		return 1;

  0032c	c7 85 68 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T24[ebp], 1
  00336	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0033d	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  00340	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00345	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR $T24[ebp]
  0034b	e9 25 03 00 00	 jmp	 $LN1@main
$LN12@main:

; 53   : 	}
; 54   : 
; 55   : 	int cur_serial_number = detSerialNumber(cur_day, cur_month, days_in_months);

  00350	68 00 00 00 00	 push	 OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00355	8b 55 cc	 mov	 edx, DWORD PTR _cur_month$[ebp]
  00358	52		 push	 edx
  00359	8b 45 c4	 mov	 eax, DWORD PTR _cur_day$[ebp]
  0035c	50		 push	 eax
  0035d	e8 00 00 00 00	 call	 ?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; detSerialNumber
  00362	83 c4 0c	 add	 esp, 12			; 0000000cH
  00365	89 45 bc	 mov	 DWORD PTR _cur_serial_number$[ebp], eax

; 56   : 
; 57   : 	int bday_day = splitData(BDAY_DATE)[0];

  00368	6a 00		 push	 0
  0036a	83 ec 18	 sub	 esp, 24			; 00000018H
  0036d	8b cc		 mov	 ecx, esp
  0036f	89 a5 10 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], esp
  00375	68 00 00 00 00	 push	 OFFSET ?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
  0037a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0037f	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00385	51		 push	 ecx
  00386	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  0038b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0038e	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv445[ebp], eax
  00394	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv445[ebp]
  0039a	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv447[ebp], edx
  003a0	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv447[ebp]
  003a6	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  003ab	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv266[ebp], eax
  003b1	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv266[ebp]
  003b7	8b 08		 mov	 ecx, DWORD PTR [eax]
  003b9	89 4d b4	 mov	 DWORD PTR _bday_day$[ebp], ecx
  003bc	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  003c2	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  003c7	90		 npad	 1

; 58   : 	int bday_month = splitData(BDAY_DATE)[1];

  003c8	6a 01		 push	 1
  003ca	83 ec 18	 sub	 esp, 24			; 00000018H
  003cd	8b cc		 mov	 ecx, esp
  003cf	89 a5 0c ff ff
	ff		 mov	 DWORD PTR $T10[ebp], esp
  003d5	68 00 00 00 00	 push	 OFFSET ?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
  003da	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  003df	8d 95 c4 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  003e5	52		 push	 edx
  003e6	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  003eb	83 c4 1c	 add	 esp, 28			; 0000001cH
  003ee	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv451[ebp], eax
  003f4	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  003fa	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv453[ebp], eax
  00400	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv453[ebp]
  00406	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  0040b	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  00411	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp]
  00417	8b 11		 mov	 edx, DWORD PTR [ecx]
  00419	89 55 b0	 mov	 DWORD PTR _bday_month$[ebp], edx
  0041c	8d 8d c4 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00422	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00427	90		 npad	 1

; 59   : 	int bday_year = splitData(BDAY_DATE)[2];

  00428	6a 02		 push	 2
  0042a	83 ec 18	 sub	 esp, 24			; 00000018H
  0042d	8b cc		 mov	 ecx, esp
  0042f	89 a5 08 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], esp
  00435	68 00 00 00 00	 push	 OFFSET ?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
  0043a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0043f	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00445	50		 push	 eax
  00446	e8 00 00 00 00	 call	 ?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; splitData
  0044b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0044e	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv457[ebp], eax
  00454	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv457[ebp]
  0045a	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv459[ebp], ecx
  00460	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv459[ebp]
  00466	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  0046b	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv340[ebp], eax
  00471	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv340[ebp]
  00477	8b 02		 mov	 eax, DWORD PTR [edx]
  00479	89 85 00 ff ff
	ff		 mov	 DWORD PTR _bday_year$[ebp], eax
  0047f	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00485	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0048a	90		 npad	 1

; 60   : 	int bday_serial_number = detSerialNumber(bday_day, bday_month, days_in_months);

  0048b	68 00 00 00 00	 push	 OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00490	8b 4d b0	 mov	 ecx, DWORD PTR _bday_month$[ebp]
  00493	51		 push	 ecx
  00494	8b 55 b4	 mov	 edx, DWORD PTR _bday_day$[ebp]
  00497	52		 push	 edx
  00498	e8 00 00 00 00	 call	 ?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; detSerialNumber
  0049d	83 c4 0c	 add	 esp, 12			; 0000000cH
  004a0	89 45 b8	 mov	 DWORD PTR _bday_serial_number$[ebp], eax

; 61   : 
; 62   : 	int remaining_days_for_bday;
; 63   : 	if (bday_serial_number >= cur_serial_number) // –ï—Å–ª–∏ –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –µ—â–µ –Ω–µ –ø—Ä–æ—à–µ–ª

  004a3	8b 45 b8	 mov	 eax, DWORD PTR _bday_serial_number$[ebp]
  004a6	3b 45 bc	 cmp	 eax, DWORD PTR _cur_serial_number$[ebp]
  004a9	7c 46		 jl	 SHORT $LN14@main

; 64   : 	{
; 65   : 		remaining_days_for_bday = bday_serial_number - cur_serial_number;

  004ab	8b 4d b8	 mov	 ecx, DWORD PTR _bday_serial_number$[ebp]
  004ae	2b 4d bc	 sub	 ecx, DWORD PTR _cur_serial_number$[ebp]
  004b1	89 4d c8	 mov	 DWORD PTR _remaining_days_for_bday$[ebp], ecx

; 66   : 		if (bday_day == 29 && bday_month == 2)

  004b4	83 7d b4 1d	 cmp	 DWORD PTR _bday_day$[ebp], 29 ; 0000001dH
  004b8	75 35		 jne	 SHORT $LN3@main
  004ba	83 7d b0 02	 cmp	 DWORD PTR _bday_month$[ebp], 2
  004be	75 2f		 jne	 SHORT $LN3@main

; 67   : 		{
; 68   : 			int temp_cur_year = cur_year;

  004c0	8b 55 d0	 mov	 edx, DWORD PTR _cur_year$[ebp]
  004c3	89 55 c0	 mov	 DWORD PTR _temp_cur_year$31[ebp], edx
$LN2@main:

; 69   : 			while (!detViscosity(temp_cur_year))

  004c6	8b 45 c0	 mov	 eax, DWORD PTR _temp_cur_year$31[ebp]
  004c9	50		 push	 eax
  004ca	e8 00 00 00 00	 call	 ?detViscosity@@YA_NH@Z	; detViscosity
  004cf	83 c4 04	 add	 esp, 4
  004d2	0f b6 c8	 movzx	 ecx, al
  004d5	85 c9		 test	 ecx, ecx
  004d7	75 16		 jne	 SHORT $LN3@main

; 70   : 			{
; 71   : 				temp_cur_year++;

  004d9	8b 55 c0	 mov	 edx, DWORD PTR _temp_cur_year$31[ebp]
  004dc	83 c2 01	 add	 edx, 1
  004df	89 55 c0	 mov	 DWORD PTR _temp_cur_year$31[ebp], edx

; 72   : 				remaining_days_for_bday += 365;

  004e2	8b 45 c8	 mov	 eax, DWORD PTR _remaining_days_for_bday$[ebp]
  004e5	05 6d 01 00 00	 add	 eax, 365		; 0000016dH
  004ea	89 45 c8	 mov	 DWORD PTR _remaining_days_for_bday$[ebp], eax

; 73   : 			}

  004ed	eb d7		 jmp	 SHORT $LN2@main
$LN3@main:

; 74   : 		}
; 75   : 	}

  004ef	eb 6e		 jmp	 SHORT $LN5@main
$LN14@main:

; 76   : 	else // –ï—Å–ª–∏ –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è —É–∂–µ –ø—Ä–æ—à–µ–ª
; 77   : 	{
; 78   : 		remaining_days_for_bday = (detViscosity(cur_year + 1) ? 366 : 365) - cur_serial_number + bday_serial_number;

  004f1	8b 4d d0	 mov	 ecx, DWORD PTR _cur_year$[ebp]
  004f4	83 c1 01	 add	 ecx, 1
  004f7	51		 push	 ecx
  004f8	e8 00 00 00 00	 call	 ?detViscosity@@YA_NH@Z	; detViscosity
  004fd	83 c4 04	 add	 esp, 4
  00500	0f b6 d0	 movzx	 edx, al
  00503	85 d2		 test	 edx, edx
  00505	74 09		 je	 SHORT $LN19@main
  00507	c7 45 a8 6e 01
	00 00		 mov	 DWORD PTR tv361[ebp], 366 ; 0000016eH
  0050e	eb 07		 jmp	 SHORT $LN20@main
$LN19@main:
  00510	c7 45 a8 6d 01
	00 00		 mov	 DWORD PTR tv361[ebp], 365 ; 0000016dH
$LN20@main:
  00517	8b 45 a8	 mov	 eax, DWORD PTR tv361[ebp]
  0051a	2b 45 bc	 sub	 eax, DWORD PTR _cur_serial_number$[ebp]
  0051d	03 45 b8	 add	 eax, DWORD PTR _bday_serial_number$[ebp]
  00520	89 45 c8	 mov	 DWORD PTR _remaining_days_for_bday$[ebp], eax

; 79   : 		if (bday_day == 29 && bday_month == 2)

  00523	83 7d b4 1d	 cmp	 DWORD PTR _bday_day$[ebp], 29 ; 0000001dH
  00527	75 36		 jne	 SHORT $LN5@main
  00529	83 7d b0 02	 cmp	 DWORD PTR _bday_month$[ebp], 2
  0052d	75 30		 jne	 SHORT $LN5@main

; 80   : 		{
; 81   : 			int temp_cur_year = cur_year;

  0052f	8b 4d d0	 mov	 ecx, DWORD PTR _cur_year$[ebp]
  00532	89 4d ac	 mov	 DWORD PTR _temp_cur_year$30[ebp], ecx
$LN4@main:

; 82   : 			while (!detViscosity(temp_cur_year))

  00535	8b 55 ac	 mov	 edx, DWORD PTR _temp_cur_year$30[ebp]
  00538	52		 push	 edx
  00539	e8 00 00 00 00	 call	 ?detViscosity@@YA_NH@Z	; detViscosity
  0053e	83 c4 04	 add	 esp, 4
  00541	0f b6 c0	 movzx	 eax, al
  00544	85 c0		 test	 eax, eax
  00546	75 17		 jne	 SHORT $LN5@main

; 83   : 			{
; 84   : 				temp_cur_year++;

  00548	8b 4d ac	 mov	 ecx, DWORD PTR _temp_cur_year$30[ebp]
  0054b	83 c1 01	 add	 ecx, 1
  0054e	89 4d ac	 mov	 DWORD PTR _temp_cur_year$30[ebp], ecx

; 85   : 				remaining_days_for_bday += 365;

  00551	8b 55 c8	 mov	 edx, DWORD PTR _remaining_days_for_bday$[ebp]
  00554	81 c2 6d 01 00
	00		 add	 edx, 365		; 0000016dH
  0055a	89 55 c8	 mov	 DWORD PTR _remaining_days_for_bday$[ebp], edx

; 86   : 			}

  0055d	eb d6		 jmp	 SHORT $LN4@main
$LN5@main:

; 87   : 		}
; 88   : 	}
; 89   : 
; 90   : 	cout << "–í–≤–µ–¥–µ–Ω–Ω–∞—è –¥–∞—Ç–∞: " << cur_day << "\t" << cur_month << "\t" << cur_year << endl;

  0055f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00564	8b 45 d0	 mov	 eax, DWORD PTR _cur_year$[ebp]
  00567	50		 push	 eax
  00568	68 00 00 00 00	 push	 OFFSET $SG37498
  0056d	8b 4d cc	 mov	 ecx, DWORD PTR _cur_month$[ebp]
  00570	51		 push	 ecx
  00571	68 00 00 00 00	 push	 OFFSET $SG37499
  00576	8b 55 c4	 mov	 edx, DWORD PTR _cur_day$[ebp]
  00579	52		 push	 edx
  0057a	68 00 00 00 00	 push	 OFFSET $SG37500
  0057f	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00584	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00589	83 c4 08	 add	 esp, 8
  0058c	8b c8		 mov	 ecx, eax
  0058e	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00593	50		 push	 eax
  00594	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00599	83 c4 08	 add	 esp, 8
  0059c	8b c8		 mov	 ecx, eax
  0059e	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  005a3	50		 push	 eax
  005a4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005a9	83 c4 08	 add	 esp, 8
  005ac	8b c8		 mov	 ecx, eax
  005ae	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  005b3	8b c8		 mov	 ecx, eax
  005b5	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 91   : 	cout << "–ì–æ–¥ - " << (is_viscos ? "–≤–∏—Å–æ–∫–æ—Å–Ω—ã–π" : "–Ω–µ –≤–∏—Å–æ–∫–æ—Å–Ω—ã–π") << endl;

  005ba	0f b6 45 d7	 movzx	 eax, BYTE PTR _is_viscos$[ebp]
  005be	85 c0		 test	 eax, eax
  005c0	74 09		 je	 SHORT $LN21@main
  005c2	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv395[ebp], OFFSET $SG37501
  005c9	eb 07		 jmp	 SHORT $LN22@main
$LN21@main:
  005cb	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR tv395[ebp], OFFSET $SG37502
$LN22@main:
  005d2	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005d7	8b 4d a4	 mov	 ecx, DWORD PTR tv395[ebp]
  005da	51		 push	 ecx
  005db	68 00 00 00 00	 push	 OFFSET $SG37503
  005e0	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  005e5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005ea	83 c4 08	 add	 esp, 8
  005ed	50		 push	 eax
  005ee	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  005f3	83 c4 08	 add	 esp, 8
  005f6	8b c8		 mov	 ecx, eax
  005f8	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 92   : 	cout << "–ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –¥–Ω—è: " << detSerialNumber(cur_day, cur_month, days_in_months) << endl;

  005fd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00602	68 00 00 00 00	 push	 OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00607	8b 55 cc	 mov	 edx, DWORD PTR _cur_month$[ebp]
  0060a	52		 push	 edx
  0060b	8b 45 c4	 mov	 eax, DWORD PTR _cur_day$[ebp]
  0060e	50		 push	 eax
  0060f	e8 00 00 00 00	 call	 ?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z ; detSerialNumber
  00614	83 c4 0c	 add	 esp, 12			; 0000000cH
  00617	50		 push	 eax
  00618	68 00 00 00 00	 push	 OFFSET $SG37504
  0061d	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00622	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00627	83 c4 08	 add	 esp, 8
  0062a	8b c8		 mov	 ecx, eax
  0062c	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00631	8b c8		 mov	 ecx, eax
  00633	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 93   : 	cout << "–û—Å—Ç–∞–ª–æ—Å—å –¥–Ω–µ–π –¥–æ –º–æ–µ–≥–æ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è: " << remaining_days_for_bday;

  00638	8b 4d c8	 mov	 ecx, DWORD PTR _remaining_days_for_bday$[ebp]
  0063b	51		 push	 ecx
  0063c	68 00 00 00 00	 push	 OFFSET $SG37505
  00641	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00646	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0064b	83 c4 08	 add	 esp, 8
  0064e	8b c8		 mov	 ecx, eax
  00650	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  00655	90		 npad	 1

; 94   : 
; 95   : 	return 0;

  00656	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T23[ebp], 0
  00660	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00667	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  0066a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0066f	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR $T23[ebp]
$LN1@main:

; 96   : }

  00675	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00678	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0067f	59		 pop	 ecx
  00680	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00683	33 cd		 xor	 ecx, ebp
  00685	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0068a	8b e5		 mov	 esp, ebp
  0068c	5d		 pop	 ebp
  0068d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR _current_date$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$_main:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a c0 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-320]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp
;	COMDAT ??__Fdays_in_months@@YAXXZ
text$yd	SEGMENT
??__Fdays_in_months@@YAXXZ PROC				; `dynamic atexit destructor for 'days_in_months'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00008	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0000d	90		 npad	 1
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__Fdays_in_months@@YAXXZ ENDP				; `dynamic atexit destructor for 'days_in_months''
text$yd	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list
;	COMDAT ?size@?$initializer_list@H@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$initializer_list@H@std@@QBEIXZ PROC		; std::initializer_list<int>::size, COMDAT
; _this$ = ecx

; 44   :     _NODISCARD constexpr size_t size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 45   :         return static_cast<size_t>(_Last - _First);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000d	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00010	2b 01		 sub	 eax, DWORD PTR [ecx]
  00012	c1 f8 02	 sar	 eax, 2

; 46   :     }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?size@?$initializer_list@H@std@@QBEIXZ ENDP		; std::initializer_list<int>::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list
;	COMDAT ?end@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?end@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::end, COMDAT
; _this$ = ecx

; 40   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 41   :         return _Last;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 42   :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?end@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?begin@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::begin, COMDAT
; _this$ = ecx

; 36   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 37   :         return _First;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 38   :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?begin@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QAE@PBH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@H@std@@QAE@PBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT
; _this$ = ecx

; 34   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$initializer_list@H@std@@QAE@PBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\kpo_lab1.cpp
;	COMDAT ??__Edays_in_months@@YAXXZ
text$di	SEGMENT
$T1 = -64						; size = 8
$T2 = -53						; size = 1
$T3 = -52						; size = 44
__$ArrayPad$ = -4					; size = 4
??__Edays_in_months@@YAXXZ PROC				; `dynamic initializer for 'days_in_months'', COMDAT

; 12   : vector<int> days_in_months = {31, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	c7 45 cc 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp], 31	; 0000001fH
  00017	c7 45 d0 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 31 ; 0000001fH
  0001e	c7 45 d4 1e 00
	00 00		 mov	 DWORD PTR $T3[ebp+8], 30 ; 0000001eH
  00025	c7 45 d8 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+12], 31 ; 0000001fH
  0002c	c7 45 dc 1e 00
	00 00		 mov	 DWORD PTR $T3[ebp+16], 30 ; 0000001eH
  00033	c7 45 e0 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+20], 31 ; 0000001fH
  0003a	c7 45 e4 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+24], 31 ; 0000001fH
  00041	c7 45 e8 1e 00
	00 00		 mov	 DWORD PTR $T3[ebp+28], 30 ; 0000001eH
  00048	c7 45 ec 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+32], 31 ; 0000001fH
  0004f	c7 45 f0 1e 00
	00 00		 mov	 DWORD PTR $T3[ebp+36], 30 ; 0000001eH
  00056	c7 45 f4 1f 00
	00 00		 mov	 DWORD PTR $T3[ebp+40], 31 ; 0000001fH
  0005d	8d 4d cb	 lea	 ecx, DWORD PTR $T2[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00065	50		 push	 eax
  00066	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp+44]
  00069	50		 push	 eax
  0006a	8d 4d cc	 lea	 ecx, DWORD PTR $T3[ebp]
  0006d	51		 push	 ecx
  0006e	8d 4d c0	 lea	 ecx, DWORD PTR $T1[ebp]
  00071	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00076	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00079	52		 push	 edx
  0007a	8b 00		 mov	 eax, DWORD PTR [eax]
  0007c	50		 push	 eax
  0007d	b9 00 00 00 00	 mov	 ecx, OFFSET ?days_in_months@@3V?$vector@HV?$allocator@H@std@@@std@@A ; days_in_months
  00082	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00087	90		 npad	 1
  00088	68 00 00 00 00	 push	 OFFSET ??__Fdays_in_months@@YAXXZ ; `dynamic atexit destructor for 'days_in_months''
  0008d	e8 00 00 00 00	 call	 _atexit
  00092	83 c4 04	 add	 esp, 4
  00095	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00098	33 cd		 xor	 ecx, ebp
  0009a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
??__Edays_in_months@@YAXXZ ENDP				; `dynamic initializer for 'days_in_months''
text$di	ENDS
; Function compile flags: /Odtp
;	COMDAT ??__FBDAY_DATE@@YAXXZ
text$yd	SEGMENT
??__FBDAY_DATE@@YAXXZ PROC				; `dynamic atexit destructor for 'BDAY_DATE'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
  00008	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000d	90		 npad	 1
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
??__FBDAY_DATE@@YAXXZ ENDP				; `dynamic atexit destructor for 'BDAY_DATE''
text$yd	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\kpo_lab1.cpp
;	COMDAT ??__EBDAY_DATE@@YAXXZ
text$di	SEGMENT
??__EBDAY_DATE@@YAXXZ PROC				; `dynamic initializer for 'BDAY_DATE'', COMDAT

; 10   : const string BDAY_DATE = "02012007";

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	68 00 00 00 00	 push	 OFFSET $SG36711
  00008	b9 00 00 00 00	 mov	 ecx, OFFSET ?BDAY_DATE@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@B
  0000d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	68 00 00 00 00	 push	 OFFSET ??__FBDAY_DATE@@YAXXZ ; `dynamic atexit destructor for 'BDAY_DATE''
  00017	e8 00 00 00 00	 call	 _atexit
  0001c	83 c4 04	 add	 esp, 4
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??__EBDAY_DATE@@YAXXZ ENDP				; `dynamic initializer for 'BDAY_DATE''
text$di	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\splitData.hpp
_TEXT	SEGMENT
_temp$ = -140						; size = 12
$T2 = -128						; size = 4
tv150 = -124						; size = 4
tv157 = -120						; size = 4
$T3 = -116						; size = 4
tv148 = -112						; size = 4
tv140 = -108						; size = 4
$T4 = -104						; size = 4
tv146 = -100						; size = 4
tv66 = -96						; size = 4
$T5 = -92						; size = 4
$T6 = -88						; size = 24
$T7 = -64						; size = 24
$T8 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_date$ = 12						; size = 24
?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; splitData

; 5    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	50		 push	 eax
  00022	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00025	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0002b	c7 45 a4 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 4    : std::vector<int> splitData(string date)

  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 6    :     std::vector<int> temp;

  00039	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0003f	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00044	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 7    : 
; 8    :     temp.push_back(stoi(date.substr(0, 2))); // day

  00048	6a 0a		 push	 10			; 0000000aH
  0004a	6a 00		 push	 0
  0004c	6a 02		 push	 2
  0004e	6a 00		 push	 0
  00050	8d 45 d8	 lea	 eax, DWORD PTR $T8[ebp]
  00053	50		 push	 eax
  00054	8d 4d 0c	 lea	 ecx, DWORD PTR _date$[ebp]
  00057	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  0005c	89 45 a0	 mov	 DWORD PTR tv66[ebp], eax
  0005f	8b 4d a0	 mov	 ecx, DWORD PTR tv66[ebp]
  00062	89 4d 9c	 mov	 DWORD PTR tv146[ebp], ecx
  00065	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00069	8b 55 9c	 mov	 edx, DWORD PTR tv146[ebp]
  0006c	52		 push	 edx
  0006d	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH
  00075	89 45 98	 mov	 DWORD PTR $T4[ebp], eax
  00078	8d 45 98	 lea	 eax, DWORD PTR $T4[ebp]
  0007b	50		 push	 eax
  0007c	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  00082	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  00087	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0008b	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  0008e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00093	90		 npad	 1

; 9    :     temp.push_back(stoi(date.substr(2, 2))); // month

  00094	6a 0a		 push	 10			; 0000000aH
  00096	6a 00		 push	 0
  00098	6a 02		 push	 2
  0009a	6a 02		 push	 2
  0009c	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  0009f	51		 push	 ecx
  000a0	8d 4d 0c	 lea	 ecx, DWORD PTR _date$[ebp]
  000a3	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  000a8	89 45 94	 mov	 DWORD PTR tv140[ebp], eax
  000ab	8b 55 94	 mov	 edx, DWORD PTR tv140[ebp]
  000ae	89 55 90	 mov	 DWORD PTR tv148[ebp], edx
  000b1	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  000b5	8b 45 90	 mov	 eax, DWORD PTR tv148[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 45 8c	 mov	 DWORD PTR $T3[ebp], eax
  000c4	8d 4d 8c	 lea	 ecx, DWORD PTR $T3[ebp]
  000c7	51		 push	 ecx
  000c8	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  000ce	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  000d3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  000d7	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  000da	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000df	90		 npad	 1

; 10   :     temp.push_back(stoi(date.substr(4, 4))); // year

  000e0	6a 0a		 push	 10			; 0000000aH
  000e2	6a 00		 push	 0
  000e4	6a 04		 push	 4
  000e6	6a 04		 push	 4
  000e8	8d 55 a8	 lea	 edx, DWORD PTR $T6[ebp]
  000eb	52		 push	 edx
  000ec	8d 4d 0c	 lea	 ecx, DWORD PTR _date$[ebp]
  000ef	e8 00 00 00 00	 call	 ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
  000f4	89 45 88	 mov	 DWORD PTR tv157[ebp], eax
  000f7	8b 45 88	 mov	 eax, DWORD PTR tv157[ebp]
  000fa	89 45 84	 mov	 DWORD PTR tv150[ebp], eax
  000fd	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00101	8b 4d 84	 mov	 ecx, DWORD PTR tv150[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  0010a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010d	89 45 80	 mov	 DWORD PTR $T2[ebp], eax
  00110	8d 55 80	 lea	 edx, DWORD PTR $T2[ebp]
  00113	52		 push	 edx
  00114	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0011a	e8 00 00 00 00	 call	 ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ; std::vector<int,std::allocator<int> >::push_back
  0011f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00123	8d 4d a8	 lea	 ecx, DWORD PTR $T6[ebp]
  00126	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0012b	90		 npad	 1

; 11   : 
; 12   :     return temp;

  0012c	8d 85 74 ff ff
	ff		 lea	 eax, DWORD PTR _temp$[ebp]
  00132	50		 push	 eax
  00133	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00136	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0013b	8b 4d a4	 mov	 ecx, DWORD PTR $T5[ebp]
  0013e	83 c9 01	 or	 ecx, 1
  00141	89 4d a4	 mov	 DWORD PTR $T5[ebp], ecx
  00144	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00148	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0014e	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00153	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0015a	8d 4d 0c	 lea	 ecx, DWORD PTR _date$[ebp]
  0015d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00162	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 13   : }

  00165	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00168	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0016f	59		 pop	 ecx
  00170	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00173	33 cd		 xor	 ecx, ebp
  00175	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017a	8b e5		 mov	 esp, ebp
  0017c	5d		 pop	 ebp
  0017d	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$0:
  00000	8d 4d 0c	 lea	 ecx, DWORD PTR _date$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$1:
  00008	8d 8d 74 ff ff
	ff		 lea	 ecx, DWORD PTR _temp$[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$2:
  00013	8d 4d d8	 lea	 ecx, DWORD PTR $T8[ebp]
  00016	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$3:
  0001b	8d 4d c0	 lea	 ecx, DWORD PTR $T7[ebp]
  0001e	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$4:
  00023	8d 4d a8	 lea	 ecx, DWORD PTR $T6[ebp]
  00026	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002b	cc		 int	 3
  0002c	cc		 int	 3
  0002d	cc		 int	 3
  0002e	cc		 int	 3
  0002f	cc		 int	 3
__ehhandler$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
  00030	90		 npad	 1
  00031	90		 npad	 1
  00032	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00036	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00039	8b 8a 7c ff ff
	ff		 mov	 ecx, DWORD PTR [edx-132]
  0003f	33 c8		 xor	 ecx, eax
  00041	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00046	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00049	33 c8		 xor	 ecx, eax
  0004b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00050	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
  00055	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?splitData@@YA?AV?$vector@HV?$allocator@H@std@@@std@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; splitData
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1506 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1507 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1508 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1503 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1504 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@PAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__End$ = 16						; size = 4
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@PAH00@Z PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 403  :         : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 10	 mov	 edx, DWORD PTR __End$[ebp]
  0001e	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 0c 00	 ret	 12			; 0000000cH
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@PAH00@Z ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 400  :     _CONSTEXPR20 _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0
  0001a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 4
?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z PROC ; std::vector<int,std::allocator<int> >::_Make_iterator, COMDAT
; _this$ = ecx

; 2191 :     _NODISCARD _CONSTEXPR20 iterator _Make_iterator(const pointer _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2192 :         return iterator(_Ptr, _STD addressof(_Mypair._Myval2));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00017	51		 push	 ecx
  00018	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
  00020	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2193 :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
?_Make_iterator@?$vector@HV?$allocator@H@std@@@std@@AAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@QAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Make_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 2187 :     _NODISCARD _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2188 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 2189 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 2183 :     _NODISCARD _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2184 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 2185 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 2180 :     _CONSTEXPR20 void _Orphan_range(pointer, pointer) const {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 08 00	 ret	 8
?_Orphan_range@?$vector@HV?$allocator@H@std@@@std@@ABEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 2140 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2141 :         _Xlength_error("vector too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
  0000d	90		 npad	 1
$LN1@Xlength:

; 2142 :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
__Myend$ = -36						; size = 4
__Mylast$ = -32						; size = 4
__Al$ = -28						; size = 4
_this$ = -24						; size = 4
__My_data$ = -20					; size = 4
__Myfirst$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 2038 :     _CONSTEXPR20 void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx

; 2039 :         auto& _Al         = _Getal();

  00028	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00030	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 2040 :         auto& _My_data    = _Mypair._Myval2;

  00033	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00036	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 2041 :         pointer& _Myfirst = _My_data._Myfirst;

  00039	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003c	89 4d f0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 2042 :         pointer& _Mylast  = _My_data._Mylast;

  0003f	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  00042	83 c2 04	 add	 edx, 4
  00045	89 55 e0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 2043 :         pointer& _Myend   = _My_data._Myend;

  00048	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004b	83 c0 08	 add	 eax, 8
  0004e	89 45 dc	 mov	 DWORD PTR __Myend$[ebp], eax

; 2044 : 
; 2045 :         _My_data._Orphan_all();

  00051	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all
  00059	90		 npad	 1

; 2046 : 
; 2047 :         if (_Myfirst) { // destroy and deallocate old array

  0005a	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005d	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00060	74 4f		 je	 SHORT $LN2@Tidy

; 2048 :             _STD _Destroy_range(_Myfirst, _Mylast, _Al);

  00062	8b 55 e4	 mov	 edx, DWORD PTR __Al$[ebp]
  00065	52		 push	 edx
  00066	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	51		 push	 ecx
  0006c	8b 55 f0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0006f	8b 02		 mov	 eax, DWORD PTR [edx]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2049 :             _ASAN_VECTOR_REMOVE;
; 2050 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0007a	8b 4d dc	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0007d	8b 55 f0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00080	8b 01		 mov	 eax, DWORD PTR [ecx]
  00082	2b 02		 sub	 eax, DWORD PTR [edx]
  00084	c1 f8 02	 sar	 eax, 2
  00087	50		 push	 eax
  00088	8b 4d f0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008d	52		 push	 edx
  0008e	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00091	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 2051 : 
; 2052 :             _Myfirst = nullptr;

  00096	8b 45 f0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00099	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2053 :             _Mylast  = nullptr;

  0009f	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000a2	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2054 :             _Myend   = nullptr;

  000a8	8b 55 dc	 mov	 edx, DWORD PTR __Myend$[ebp]
  000ab	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN2@Tidy:

; 2055 :         }
; 2056 :     }

  000b1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000b4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000bb	59		 pop	 ecx
  000bc	8b e5		 mov	 esp, ebp
  000be	5d		 pop	 ebp
  000bf	c3		 ret	 0
  000c0	cc		 int	 3
  000c1	cc		 int	 3
  000c2	cc		 int	 3
  000c3	cc		 int	 3
  000c4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z
_TEXT	SEGMENT
__Myend$ = -24						; size = 4
__Mylast$ = -20						; size = 4
__Al$ = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Myfirst$ = -4						; size = 4
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z PROC ; std::vector<int,std::allocator<int> >::_Change_array, COMDAT
; _this$ = ecx

; 2016 :     _CONSTEXPR20 void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2017 :         // orphan all iterators, discard old array, acquire new array
; 2018 :         auto& _Al         = _Getal();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00011	89 45 f0	 mov	 DWORD PTR __Al$[ebp], eax

; 2019 :         auto& _My_data    = _Mypair._Myval2;

  00014	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00017	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2020 :         pointer& _Myfirst = _My_data._Myfirst;

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 2021 :         pointer& _Mylast  = _My_data._Mylast;

  00020	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00023	83 c2 04	 add	 edx, 4
  00026	89 55 ec	 mov	 DWORD PTR __Mylast$[ebp], edx

; 2022 :         pointer& _Myend   = _My_data._Myend;

  00029	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002c	83 c0 08	 add	 eax, 8
  0002f	89 45 e8	 mov	 DWORD PTR __Myend$[ebp], eax

; 2023 : 
; 2024 :         _My_data._Orphan_all();

  00032	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00035	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all
  0003a	90		 npad	 1

; 2025 : 
; 2026 :         if (_Myfirst) { // destroy and deallocate old array

  0003b	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0003e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00041	74 35		 je	 SHORT $LN2@Change_arr

; 2027 :             _Destroy_range(_Myfirst, _Mylast, _Al);

  00043	8b 55 f0	 mov	 edx, DWORD PTR __Al$[ebp]
  00046	52		 push	 edx
  00047	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0004a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004c	51		 push	 ecx
  0004d	8b 55 fc	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2028 :             _ASAN_VECTOR_REMOVE;
; 2029 :             _Al.deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myend$[ebp]
  0005e	8b 55 fc	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00061	8b 01		 mov	 eax, DWORD PTR [ecx]
  00063	2b 02		 sub	 eax, DWORD PTR [edx]
  00065	c1 f8 02	 sar	 eax, 2
  00068	50		 push	 eax
  00069	8b 4d fc	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0006c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006e	52		 push	 edx
  0006f	8b 4d f0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00072	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate
  00077	90		 npad	 1
$LN2@Change_arr:

; 2030 :         }
; 2031 : 
; 2032 :         _Myfirst = _Newvec;

  00078	8b 45 fc	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0007b	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007e	89 08		 mov	 DWORD PTR [eax], ecx

; 2033 :         _Mylast  = _Newvec + _Newsize;

  00080	8b 55 0c	 mov	 edx, DWORD PTR __Newsize$[ebp]
  00083	8b 45 08	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00086	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  00089	8b 55 ec	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0008c	89 0a		 mov	 DWORD PTR [edx], ecx

; 2034 :         _Myend   = _Newvec + _Newcapacity;

  0008e	8b 45 10	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00091	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00094	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00097	8b 45 e8	 mov	 eax, DWORD PTR __Myend$[ebp]
  0009a	89 10		 mov	 DWORD PTR [eax], edx

; 2035 :         _ASAN_VECTOR_CREATE;
; 2036 :     }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@HV?$allocator@H@std@@@std@@AAEXQAHII@Z ENDP ; std::vector<int,std::allocator<int> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1998 :     _CONSTEXPR20 void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1999 :         // allocate array with _Newcapacity elements
; 2000 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 2001 :         auto& _My_data    = _Mypair._Myval2;
; 2002 :         pointer& _Myfirst = _My_data._Myfirst;
; 2003 :         pointer& _Mylast  = _My_data._Mylast;
; 2004 :         pointer& _Myend   = _My_data._Myend;
; 2005 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 2006 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 2007 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 2008 : 
; 2009 :         if (_Newcapacity > max_size()) {

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0000f	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  00012	76 06		 jbe	 SHORT $LN2@Buy_nonzer

; 2010 :             _Xlength();

  00014	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
  00019	90		 npad	 1
$LN2@Buy_nonzer:

; 2011 :         }
; 2012 : 
; 2013 :         _Buy_raw(_Newcapacity);

  0001a	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
  00026	90		 npad	 1
$LN1@Buy_nonzer:

; 2014 :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
__Myend$ = -24						; size = 4
__Mylast$ = -20						; size = 4
__Myfirst$ = -16					; size = 4
_this$ = -12						; size = 4
__Newvec$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1982 :     _CONSTEXPR20 void _Buy_raw(size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1983 :         // allocate array with _Newcapacity elements
; 1984 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1985 :         pointer& _Myfirst = _My_data._Myfirst;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	89 4d f0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1986 :         pointer& _Mylast  = _My_data._Mylast;

  00015	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00018	83 c2 04	 add	 edx, 4
  0001b	89 55 ec	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1987 :         pointer& _Myend   = _My_data._Myend;

  0001e	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00021	83 c0 08	 add	 eax, 8
  00024	89 45 e8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1988 : 
; 1989 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1990 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1991 : 
; 1992 :         const pointer _Newvec = _STD _Allocate_at_least_helper(_Getal(), _Newcapacity);

  00027	8d 4d 08	 lea	 ecx, DWORD PTR __Newcapacity$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@H@std@@@std@@YAPAHAAV?$allocator@H@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<int> >
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 f8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1993 :         _Myfirst              = _Newvec;

  0003f	8b 55 f0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00042	8b 45 f8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00045	89 02		 mov	 DWORD PTR [edx], eax

; 1994 :         _Mylast               = _Newvec;

  00047	8b 4d ec	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0004a	8b 55 f8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  0004d	89 11		 mov	 DWORD PTR [ecx], edx

; 1995 :         _Myend                = _Newvec + _Newcapacity;

  0004f	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00052	8b 4d f8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  00055	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00058	8b 45 e8	 mov	 eax, DWORD PTR __Myend$[ebp]
  0005b	89 10		 mov	 DWORD PTR [eax], edx

; 1996 :     }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 04 00	 ret	 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -16					; size = 4
__Max$ = -12						; size = 4
_this$ = -8						; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z PROC ; std::vector<int,std::allocator<int> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1964 :     _CONSTEXPR20 size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1965 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1966 :         const size_type _Oldcapacity = capacity();

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::capacity
  00011	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1967 :         const auto _Max              = max_size();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  0001c	89 45 f4	 mov	 DWORD PTR __Max$[ebp], eax

; 1968 : 
; 1969 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  0001f	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  00022	d1 e8		 shr	 eax, 1
  00024	8b 4d f4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00027	2b c8		 sub	 ecx, eax
  00029	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  0002c	76 05		 jbe	 SHORT $LN2@Calculate_

; 1970 :             return _Max; // geometric growth would overflow

  0002e	8b 45 f4	 mov	 eax, DWORD PTR __Max$[ebp]
  00031	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1971 :         }
; 1972 : 
; 1973 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  00033	8b 55 fc	 mov	 edx, DWORD PTR __Oldcapacity$[ebp]
  00036	d1 ea		 shr	 edx, 1
  00038	03 55 fc	 add	 edx, DWORD PTR __Oldcapacity$[ebp]
  0003b	89 55 f0	 mov	 DWORD PTR __Geometric$[ebp], edx

; 1974 : 
; 1975 :         if (_Geometric < _Newsize) {

  0003e	8b 45 f0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  00041	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  00044	73 05		 jae	 SHORT $LN3@Calculate_

; 1976 :             return _Newsize; // geometric growth would be insufficient

  00046	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00049	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1977 :         }
; 1978 : 
; 1979 :         return _Geometric; // geometric growth is sufficient

  0004b	8b 45 f0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1980 :     }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@HV?$allocator@H@std@@@std@@ABEII@Z ENDP ; std::vector<int,std::allocator<int> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z PROC	; std::vector<int,std::allocator<int> >::operator[], COMDAT
; _this$ = ecx

; 1885 :     _NODISCARD _CONSTEXPR20 _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1886 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1887 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1888 :         _STL_VERIFY(
; 1889 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1890 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1891 : 
; 1892 :         return _My_data._Myfirst[_Pos];

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00017	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1893 :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ENDP	; std::vector<int,std::allocator<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::capacity, COMDAT
; _this$ = ecx

; 1880 :     _NODISCARD _CONSTEXPR20 size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1881 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1882 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00015	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00018	2b 02		 sub	 eax, DWORD PTR [edx]
  0001a	c1 f8 02	 sar	 eax, 2

; 1883 :     }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?capacity@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1876 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1877 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()), _Alty_traits::max_size(_Getal()));

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
  00017	83 c4 04	 add	 esp, 4
  0001a	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0001d	e8 00 00 00 00	 call	 ??$_Max_limit@H@std@@YAHXZ ; std::_Max_limit<int>
  00022	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00025	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00028	50		 push	 eax
  00029	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00032	83 c4 08	 add	 esp, 8
  00035	8b 00		 mov	 eax, DWORD PTR [eax]

; 1878 :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 1798 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1799 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 1800 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@H@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<int> > >
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0001f	8b 02		 mov	 eax, DWORD PTR [edx]
  00021	50		 push	 eax
  00022	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base0@1@@Z
  0002a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1801 :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
__Val$ = 16						; size = 4
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::insert, COMDAT
; _this$ = ecx

; 1000 :     _CONSTEXPR20 iterator insert(const_iterator _Where, _Ty&& _Val) { // insert by moving _Val at _Where

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1001 :         return emplace(_Where, _STD move(_Val));

  00007	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 0c	 mov	 ecx, DWORD PTR __Where$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$emplace@H@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@1@$$QAH@Z ; std::vector<int,std::allocator<int> >::emplace<int>
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1002 :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z PROC ; std::vector<int,std::allocator<int> >::push_back, COMDAT
; _this$ = ecx

; 870  :     _CONSTEXPR20 void push_back(_Ty&& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 871  :         // insert by moving into element at end, provide strong guarantee
; 872  :         _Emplace_one_at_back(_STD move(_Val));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$move@AAH@std@@YA$$QAHAAH@Z ; std::move<int &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??$_Emplace_one_at_back@H@?$vector@HV?$allocator@H@std@@@std@@AAEAAH$$QAH@Z ; std::vector<int,std::allocator<int> >::_Emplace_one_at_back<int>
  0001c	90		 npad	 1

; 873  :     }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?push_back@?$vector@HV?$allocator@H@std@@@std@@QAEX$$QAH@Z ENDP ; std::vector<int,std::allocator<int> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 760  :     _CONSTEXPR20 ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 761  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
  0000f	90		 npad	 1

; 762  : #if _ITERATOR_DEBUG_LEVEL != 0
; 763  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 764  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));
; 765  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 766  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 4
$T2 = -28						; size = 4
$T3 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
$T6 = -12						; size = 4
_this$ = -8						; size = 4
$T7 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 694  :             _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 691  :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),

  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T6[ebp], 0
  00010	8d 45 f4	 lea	 eax, DWORD PTR $T6[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00017	83 c1 08	 add	 ecx, 8
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z ; std::exchange<int *,std::nullptr_t>
  00020	83 c4 08	 add	 esp, 8
  00023	89 45 e8	 mov	 DWORD PTR $T3[ebp], eax
  00026	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0
  0002d	8d 55 f0	 lea	 edx, DWORD PTR $T5[ebp]
  00030	52		 push	 edx
  00031	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00034	83 c0 04	 add	 eax, 4
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 ??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z ; std::exchange<int *,std::nullptr_t>
  0003d	83 c4 08	 add	 esp, 8
  00040	89 45 e4	 mov	 DWORD PTR $T2[ebp], eax
  00043	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR $T4[ebp], 0
  0004a	8d 4d ec	 lea	 ecx, DWORD PTR $T4[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??$exchange@PAH$$T@std@@YAPAHAAPAH$$QA$$T@Z ; std::exchange<int *,std::nullptr_t>
  00057	83 c4 08	 add	 esp, 8
  0005a	89 45 e0	 mov	 DWORD PTR $T1[ebp], eax
  0005d	8d 45 e8	 lea	 eax, DWORD PTR $T3[ebp]
  00060	50		 push	 eax
  00061	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  00064	51		 push	 ecx
  00065	8d 55 e0	 lea	 edx, DWORD PTR $T1[ebp]
  00068	52		 push	 edx
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0006c	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::move<std::allocator<int> &>
  00077	83 c4 04	 add	 esp, 4
  0007a	50		 push	 eax
  0007b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T7[ebp]
  0007f	50		 push	 eax
  00080	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00083	e8 00 00 00 00	 call	 ??$?0V?$allocator@H@std@@PAHPAHPAH@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@$$QAPAH22@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int>,int *,int *,int *>
  00088	90		 npad	 1

; 695  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00089	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B
  0008e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 696  :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00096	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00099	51		 push	 ecx
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
  000a2	90		 npad	 1

; 697  :     }

  000a3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 04 00	 ret	 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
$T2 = -12						; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 651  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0000c	50		 push	 eax
  0000d	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T3[ebp]
  00011	51		 push	 ecx
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
  0001a	90		 npad	 1

; 652  :         _Construct_n(_Convert_size<size_type>(_Ilist.size()), _Ilist.begin(), _Ilist.end());

  0001b	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  0001e	e8 00 00 00 00	 call	 ?end@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::end
  00023	89 45 f4	 mov	 DWORD PTR $T2[ebp], eax
  00026	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  00029	e8 00 00 00 00	 call	 ?begin@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::begin
  0002e	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00031	8d 55 f4	 lea	 edx, DWORD PTR $T2[ebp]
  00034	52		 push	 edx
  00035	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00038	50		 push	 eax
  00039	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  0003c	e8 00 00 00 00	 call	 ?size@?$initializer_list@H@std@@QBEIXZ ; std::initializer_list<int>::size
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  00047	83 c4 04	 add	 esp, 4
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ??$_Construct_n@PBHPBH@?$vector@HV?$allocator@H@std@@@std@@AAEXI$$QAPBH0@Z ; std::vector<int,std::allocator<int> >::_Construct_n<int const *,int const *>
  00053	90		 npad	 1

; 653  :     }

  00054	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 0c 00	 ret	 12			; 0000000cH
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 601  :     _CONSTEXPR20 vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0000d	50		 push	 eax
  0000e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><>
  00016	90		 npad	 1

; 602  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00017	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
  00024	90		 npad	 1

; 603  :     }

  00025	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??0?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 715  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  00019	83 c4 04	 add	 esp, 4

; 955  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 946  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 947  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 948  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 949  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	c1 e0 02	 shl	 eax, 2
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00011	51		 push	 ecx
  00012	e8 00 00 00 00	 call	 ??$_Deallocate@$07@std@@YAXPAXI@Z ; std::_Deallocate<8>
  00017	83 c4 08	 add	 esp, 8

; 950  :     }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 938  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\detSerialNumber.hpp
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_serial_number$ = -4					; size = 4
_day$ = 8						; size = 4
_month$ = 12						; size = 4
_days_in_months$ = 16					; size = 4
?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z PROC ; detSerialNumber

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 5    :     int serial_number = 0;

  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _serial_number$[ebp], 0

; 6    :     for (int i = 0; i < month - 1; i++)

  0000d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00014	eb 09		 jmp	 SHORT $LN4@detSerialN
$LN2@detSerialN:
  00016	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00019	83 c0 01	 add	 eax, 1
  0001c	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@detSerialN:
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _month$[ebp]
  00022	83 e9 01	 sub	 ecx, 1
  00025	39 4d f8	 cmp	 DWORD PTR _i$1[ebp], ecx
  00028	7d 16		 jge	 SHORT $LN3@detSerialN

; 7    :     {
; 8    :         serial_number += days_in_months[i];

  0002a	8b 55 f8	 mov	 edx, DWORD PTR _i$1[ebp]
  0002d	52		 push	 edx
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR _days_in_months$[ebp]
  00031	e8 00 00 00 00	 call	 ??A?$vector@HV?$allocator@H@std@@@std@@QAEAAHI@Z ; std::vector<int,std::allocator<int> >::operator[]
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _serial_number$[ebp]
  00039	03 08		 add	 ecx, DWORD PTR [eax]
  0003b	89 4d fc	 mov	 DWORD PTR _serial_number$[ebp], ecx

; 9    :     }

  0003e	eb d6		 jmp	 SHORT $LN2@detSerialN
$LN3@detSerialN:

; 10   :     serial_number = serial_number + day;

  00040	8b 55 fc	 mov	 edx, DWORD PTR _serial_number$[ebp]
  00043	03 55 08	 add	 edx, DWORD PTR _day$[ebp]
  00046	89 55 fc	 mov	 DWORD PTR _serial_number$[ebp], edx

; 11   :     return serial_number;

  00049	8b 45 fc	 mov	 eax, DWORD PTR _serial_number$[ebp]

; 12   : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
?detSerialNumber@@YAHHHAAV?$vector@HV?$allocator@H@std@@@std@@@Z ENDP ; detSerialNumber
_TEXT	ENDS
; Function compile flags: /Odtp
; File D:\University\Labs_1_course\ œŒ\1\kpo_lab1\detViscosity.hpp
_TEXT	SEGMENT
_year$ = 8						; size = 4
?detViscosity@@YA_NH@Z PROC				; detViscosity

; 2    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 3    :     if (year % 4 == 0)

  00003	8b 45 08	 mov	 eax, DWORD PTR _year$[ebp]
  00006	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  0000b	79 05		 jns	 SHORT $LN5@detViscosi
  0000d	48		 dec	 eax
  0000e	83 c8 fc	 or	 eax, -4			; fffffffcH
  00011	40		 inc	 eax
$LN5@detViscosi:
  00012	85 c0		 test	 eax, eax
  00014	75 06		 jne	 SHORT $LN2@detViscosi

; 4    :     {
; 5    :         return true;

  00016	b0 01		 mov	 al, 1
  00018	eb 04		 jmp	 SHORT $LN3@detViscosi

; 6    :     }

  0001a	eb 02		 jmp	 SHORT $LN3@detViscosi
$LN2@detViscosi:

; 7    :     else
; 8    :     {
; 9    :         return false;

  0001c	32 c0		 xor	 al, al
$LN3@detViscosi:

; 10   :     }
; 11   : }

  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?detViscosity@@YA_NH@Z ENDP				; detViscosity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\string
;	COMDAT ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z
_TEXT	SEGMENT
__Ans$ = -16						; size = 4
__Eptr$ = -12						; size = 4
__Errno_ref$ = -8					; size = 4
__Ptr$ = -4						; size = 4
__Str$ = 8						; size = 4
__Idx$ = 12						; size = 4
__Base$ = 16						; size = 4
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z PROC ; std::stoi, COMDAT

; 88   : _EXPORT_STD _NODISCARD inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 89   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  00006	e8 00 00 00 00	 call	 __errno
  0000b	89 45 f8	 mov	 DWORD PTR __Errno_ref$[ebp], eax

; 90   :     const char* _Ptr = _Str.c_str();

  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00011	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00016	89 45 fc	 mov	 DWORD PTR __Ptr$[ebp], eax

; 91   :     char* _Eptr;
; 92   :     _Errno_ref      = 0;

  00019	8b 45 f8	 mov	 eax, DWORD PTR __Errno_ref$[ebp]
  0001c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 93   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Base$[ebp]
  00025	51		 push	 ecx
  00026	8d 55 f4	 lea	 edx, DWORD PTR __Eptr$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 fc	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 _strtol
  00033	83 c4 0c	 add	 esp, 12			; 0000000cH
  00036	89 45 f0	 mov	 DWORD PTR __Ans$[ebp], eax

; 94   : 
; 95   :     if (_Ptr == _Eptr) {

  00039	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003c	3b 4d f4	 cmp	 ecx, DWORD PTR __Eptr$[ebp]
  0003f	75 0b		 jne	 SHORT $LN2@stoi

; 96   :         _Xinvalid_argument("invalid stoi argument");

  00041	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00046	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPBD@Z ; std::_Xinvalid_argument
  0004b	90		 npad	 1
$LN2@stoi:

; 97   :     }
; 98   : 
; 99   :     if (_Errno_ref == ERANGE) {

  0004c	8b 55 f8	 mov	 edx, DWORD PTR __Errno_ref$[ebp]
  0004f	83 3a 22	 cmp	 DWORD PTR [edx], 34	; 00000022H
  00052	75 0b		 jne	 SHORT $LN3@stoi

; 100  :         _Xout_of_range("stoi argument out of range");

  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00059	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
  0005e	90		 npad	 1
$LN3@stoi:

; 101  :     }
; 102  : 
; 103  :     if (_Idx) {

  0005f	83 7d 0c 00	 cmp	 DWORD PTR __Idx$[ebp], 0
  00063	74 0b		 je	 SHORT $LN4@stoi

; 104  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  00065	8b 45 f4	 mov	 eax, DWORD PTR __Eptr$[ebp]
  00068	2b 45 fc	 sub	 eax, DWORD PTR __Ptr$[ebp]
  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR __Idx$[ebp]
  0006e	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@stoi:

; 105  :     }
; 106  : 
; 107  :     return static_cast<int>(_Ans);

  00070	8b 45 f0	 mov	 eax, DWORD PTR __Ans$[ebp]
$LN1@stoi:

; 108  : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 288  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 289  :         return *_Ploc;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0locale@std@@QAE@ABV01@@Z ; std::locale::locale
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 290  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Oldwidth$ = -12					; size = 8
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 281  :     streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 282  :         // set width to argument
; 283  :         const streamsize _Oldwidth = _Wide;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00012	89 4d f4	 mov	 DWORD PTR __Oldwidth$[ebp], ecx
  00015	89 55 f8	 mov	 DWORD PTR __Oldwidth$[ebp+4], edx

; 284  :         _Wide                      = _Newwidth;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Newwidth$[ebp]
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Newwidth$[ebp+4]
  00021	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00024	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 285  :         return _Oldwidth;

  00027	8b 45 f4	 mov	 eax, DWORD PTR __Oldwidth$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __Oldwidth$[ebp+4]

; 286  :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 277  :     _NODISCARD streamsize __CLR_OR_THIS_CALL width() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :         return _Wide;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0000d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 279  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?precision@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?precision@ios_base@std@@QBE_JXZ PROC			; std::ios_base::precision, COMDAT
; _this$ = ecx

; 266  :     _NODISCARD streamsize __CLR_OR_THIS_CALL precision() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 267  :         return _Prec;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 18	 mov	 eax, DWORD PTR [ecx+24]
  0000d	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 268  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?precision@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::precision
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 236  :     _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 237  :         return _Fmtfl;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 238  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 205  :     _NODISCARD bool __CLR_OR_THIS_CALL good() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 206  :         return rdstate() == ios_base::goodbit;

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $LN3@good
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@good
$LN3@good:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@good:
  00025	0f b6 45 fc	 movzx	 eax, BYTE PTR tv67[ebp]

; 207  :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 186  :     _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 187  :         return _Mystate;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 188  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -20						; size = 8
_this$ = -12						; size = 4
__Msg$3 = -8						; size = 4
__Filtered$ = -4					; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 154  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 155  :         _State &= _Statmask;

  00009	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000c	83 e0 17	 and	 eax, 23			; 00000017H
  0000f	89 45 08	 mov	 DWORD PTR __State$[ebp], eax

; 156  :         _Mystate             = _State;

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  00018	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 157  :         const auto _Filtered = _State & _Except;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00021	23 48 10	 and	 ecx, DWORD PTR [eax+16]
  00024	89 4d fc	 mov	 DWORD PTR __Filtered$[ebp], ecx

; 158  :         if (_Filtered) {

  00027	74 65		 je	 SHORT $LN2@clear

; 159  :             if (_Reraise) {

  00029	0f b6 55 0c	 movzx	 edx, BYTE PTR __Reraise$[ebp]
  0002d	85 d2		 test	 edx, edx
  0002f	74 0a		 je	 SHORT $LN3@clear

; 160  :                 _RERAISE;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 __CxxThrowException@8
  0003a	90		 npad	 1
$LN3@clear:

; 161  :             }
; 162  : 
; 163  :             const char* _Msg;
; 164  :             if (_Filtered & ios_base::badbit) {

  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Filtered$[ebp]
  0003e	83 e0 04	 and	 eax, 4
  00041	74 09		 je	 SHORT $LN4@clear

; 165  :                 _Msg = "ios_base::badbit set";

  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  0004a	eb 18		 jmp	 SHORT $LN7@clear
$LN4@clear:

; 166  :             } else if (_Filtered & ios_base::failbit) {

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR __Filtered$[ebp]
  0004f	83 e1 02	 and	 ecx, 2
  00052	74 09		 je	 SHORT $LN6@clear

; 167  :                 _Msg = "ios_base::failbit set";

  00054	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@

; 168  :             } else {

  0005b	eb 07		 jmp	 SHORT $LN7@clear
$LN6@clear:

; 169  :                 _Msg = "ios_base::eofbit set";

  0005d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
$LN7@clear:

; 170  :             }
; 171  : 
; 172  :             _THROW(failure(_Msg));

  00064	6a 01		 push	 1
  00066	8d 55 ec	 lea	 edx, DWORD PTR $T2[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0006f	83 c4 08	 add	 esp, 8
  00072	50		 push	 eax
  00073	8b 45 f8	 mov	 eax, DWORD PTR __Msg$3[ebp]
  00076	50		 push	 eax
  00077	8d 4d d8	 lea	 ecx, DWORD PTR $T1[ebp]
  0007a	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0007f	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00084	8d 4d d8	 lea	 ecx, DWORD PTR $T1[ebp]
  00087	51		 push	 ecx
  00088	e8 00 00 00 00	 call	 __CxxThrowException@8
  0008d	90		 npad	 1
$LN2@clear:
$LN1@clear:

; 173  :         }
; 174  :     }

  0008e	8b e5		 mov	 esp, ebp
  00090	5d		 pop	 ebp
  00091	c2 08 00	 ret	 8
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1failure@ios_base@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1system_error@std@@UAE@XZ
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 116  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  :             : system_error(_Errcode, _Message) {} // construct with message

  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  0000e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00011	52		 push	 edx
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z PROC	; std::_Adl_verify_range<char *,char const *>, COMDAT

; 1292 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1293 :     // check that [_First, _Last) forms an iterator range
; 1294 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1295 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1296 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1297 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1298 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1299 :         _Verify_range(_First, _Last);
; 1300 :     }
; 1301 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ENDP	; std::_Adl_verify_range<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
__Lock$3 = -36						; size = 4
__Id$4 = -32						; size = 4
__Psave_guard$5 = -28					; size = 4
__Pf$6 = -24						; size = 4
__Pfmod$7 = -20						; size = 4
__Psave$8 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 420  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 421  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00025	6a 00		 push	 0
  00027	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  0002a	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 422  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00036	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  0003b	89 45 f0	 mov	 DWORD PTR __Psave$8[ebp], eax

; 423  : 
; 424  :     const size_t _Id         = _Facet::id;

  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  00043	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00048	89 45 e0	 mov	 DWORD PTR __Id$4[ebp], eax

; 425  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  0004b	8b 4d e0	 mov	 ecx, DWORD PTR __Id$4[ebp]
  0004e	51		 push	 ecx
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00057	89 45 e8	 mov	 DWORD PTR __Pf$6[ebp], eax

; 426  : 
; 427  :     if (!_Pf) {

  0005a	83 7d e8 00	 cmp	 DWORD PTR __Pf$6[ebp], 0
  0005e	75 7d		 jne	 SHORT $LN6@use_facet

; 428  :         if (_Psave) {

  00060	83 7d f0 00	 cmp	 DWORD PTR __Psave$8[ebp], 0
  00064	74 08		 je	 SHORT $LN3@use_facet

; 429  :             _Pf = _Psave; // lazy facet already allocated

  00066	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  00069	89 55 e8	 mov	 DWORD PTR __Pf$6[ebp], edx
  0006c	eb 6f		 jmp	 SHORT $LN6@use_facet
$LN3@use_facet:

; 430  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  0006e	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  00071	50		 push	 eax
  00072	8d 4d f0	 lea	 ecx, DWORD PTR __Psave$8[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  0007b	83 c4 08	 add	 esp, 8
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	75 08		 jne	 SHORT $LN5@use_facet

; 431  : #if _HAS_EXCEPTIONS
; 432  :             _Throw_bad_cast(); // lazy disallowed

  00083	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast
  00088	90		 npad	 1

; 433  : #else
; 434  :             _CSTD abort(); // lazy disallowed
; 435  : #endif
; 436  :         } else { // queue up lazy facet for destruction

  00089	eb 52		 jmp	 SHORT $LN6@use_facet
$LN5@use_facet:

; 437  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  0008b	8b 55 f0	 mov	 edx, DWORD PTR __Psave$8[ebp]
  0008e	89 55 ec	 mov	 DWORD PTR __Pfmod$7[ebp], edx

; 438  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  00091	8b 45 ec	 mov	 eax, DWORD PTR __Pfmod$7[ebp]
  00094	50		 push	 eax
  00095	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  00098	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
  0009d	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 439  : 
; 440  : #if defined(_M_CEE)
; 441  :             _Facet_Register_m(_Pfmod);
; 442  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 443  :             _Facet_Register(_Pfmod);

  000a1	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000a4	51		 push	 ecx
  000a5	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  000aa	83 c4 04	 add	 esp, 4

; 444  : #endif // ^^^ !defined(_M_CEE) ^^^
; 445  : 
; 446  :             _Pfmod->_Incref();

  000ad	8b 55 ec	 mov	 edx, DWORD PTR __Pfmod$7[ebp]
  000b0	8b 02		 mov	 eax, DWORD PTR [edx]
  000b2	8b 4d ec	 mov	 ecx, DWORD PTR __Pfmod$7[ebp]
  000b5	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000b8	ff d2		 call	 edx

; 447  :             _Facetptr<_Facet>::_Psave = _Psave;

  000ba	8b 45 f0	 mov	 eax, DWORD PTR __Psave$8[ebp]
  000bd	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 448  :             _Pf                       = _Psave;

  000c2	8b 4d f0	 mov	 ecx, DWORD PTR __Psave$8[ebp]
  000c5	89 4d e8	 mov	 DWORD PTR __Pf$6[ebp], ecx

; 449  : 
; 450  :             (void) _Psave_guard.release();

  000c8	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000cb	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 451  :         }

  000d0	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000d4	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  000d7	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  000dc	90		 npad	 1
$LN6@use_facet:

; 452  :     }
; 453  : 
; 454  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000dd	8b 55 e8	 mov	 edx, DWORD PTR __Pf$6[ebp]
  000e0	89 55 d8	 mov	 DWORD PTR $T2[ebp], edx
  000e3	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ea	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  000ed	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000f2	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@use_facet:

; 455  :     _END_LOCK()
; 456  : } // end of use_facet body

  000f5	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f8	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ff	59		 pop	 ecx
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR __Lock$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z$1:
  00008	8d 4d e4	 lea	 ecx, DWORD PTR __Psave_guard$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
  0002d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$ctype@D@std@@MAE@XZ ; std::ctype<char>::~ctype<char>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 18		 push	 24			; 00000018H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2861 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2862 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2863 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2864 :         return _Last;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2865 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2856 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2857 :         return _Ch;

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]

; 2858 :     }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2850 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2851 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2852 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2853 :         return _Last;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2854 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2845 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2846 :         return _Byte;

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]

; 2847 :     }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2836 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2837 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2838 :         for (; _First != _Last; ++_First) {

  00017	eb 09		 jmp	 SHORT $LN4@do_toupper
$LN2@do_toupper:
  00019	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001c	83 c2 01	 add	 edx, 1
  0001f	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@do_toupper:
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00028	74 1d		 je	 SHORT $LN3@do_toupper

; 2839 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __Toupper
  0003d	83 c4 08	 add	 esp, 8
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	88 01		 mov	 BYTE PTR [ecx], al

; 2840 :         }

  00045	eb d2		 jmp	 SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2841 : 
; 2842 :         return _First;

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2843 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2831 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2832 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __Toupper
  00018	83 c4 08	 add	 esp, 8

; 2833 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2822 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2823 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2824 :         for (; _First != _Last; ++_First) {

  00017	eb 09		 jmp	 SHORT $LN4@do_tolower
$LN2@do_tolower:
  00019	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001c	83 c2 01	 add	 edx, 1
  0001f	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@do_tolower:
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00028	74 1d		 je	 SHORT $LN3@do_tolower

; 2825 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __Tolower
  0003d	83 c4 08	 add	 esp, 8
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	88 01		 mov	 BYTE PTR [ecx], al

; 2826 :         }

  00045	eb d2		 jmp	 SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2827 : 
; 2828 :         return _First;

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2829 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2817 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2818 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __Tolower
  00018	83 c4 08	 add	 esp, 8

; 2819 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2807 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2808 :         if (0 < _Ctype._Delfl) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 11		 jle	 SHORT $LN2@Tidy

; 2809 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 _free
  0001e	83 c4 04	 add	 esp, 4
  00021	eb 1e		 jmp	 SHORT $LN4@Tidy
$LN2@Tidy:

; 2810 :         } else if (_Ctype._Delfl < 0) {

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	7d 15		 jge	 SHORT $LN4@Tidy

; 2811 :             delete[] _Ctype._Table;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00032	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00035	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003e	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 2812 :         }
; 2813 : 
; 2814 :         _CSTD free(_Ctype._LocaleName);

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _free
  0004d	83 c4 04	 add	 esp, 4

; 2815 :     }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2803 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2804 :         _Ctype = _Lobj._Getctype();

  00009	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 08	 add	 ecx, 8
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00025	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00028	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0002b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2805 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2799 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2800 :         _Tidy();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy
  00018	90		 npad	 1

; 2801 :     }

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  00021	90		 npad	 1
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T2 = -88						; size = 52
$T3 = -36						; size = 4
tv128 = -32						; size = 4
tv131 = -28						; size = 4
tv89 = -24						; size = 4
$T4 = -20						; size = 4
$T5 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2780 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T5[ebp], 0

; 2781 :         if (_Ppf && !*_Ppf) {

  0002c	83 7d 08 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00030	0f 84 98 00 00
	00		 je	 $LN9@Getcat
  00036	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00039	83 38 00	 cmp	 DWORD PTR [eax], 0
  0003c	0f 85 8c 00 00
	00		 jne	 $LN9@Getcat

; 2782 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  00042	6a 18		 push	 24			; 00000018H
  00044	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 ec	 mov	 DWORD PTR $T4[ebp], eax
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00056	83 7d ec 00	 cmp	 DWORD PTR $T4[ebp], 0
  0005a	74 3a		 je	 SHORT $LN4@Getcat
  0005c	6a 00		 push	 0
  0005e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00061	e8 00 00 00 00	 call	 ?_C_str@locale@std@@QBEPBDXZ ; std::locale::_C_str
  00066	50		 push	 eax
  00067	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0006a	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  0006f	89 45 e4	 mov	 DWORD PTR tv131[ebp], eax
  00072	8b 4d e4	 mov	 ecx, DWORD PTR tv131[ebp]
  00075	89 4d e0	 mov	 DWORD PTR tv128[ebp], ecx
  00078	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0007c	8b 55 f0	 mov	 edx, DWORD PTR $T5[ebp]
  0007f	83 ca 01	 or	 edx, 1
  00082	89 55 f0	 mov	 DWORD PTR $T5[ebp], edx
  00085	8b 45 e0	 mov	 eax, DWORD PTR tv128[ebp]
  00088	50		 push	 eax
  00089	8b 4d ec	 mov	 ecx, DWORD PTR $T4[ebp]
  0008c	e8 00 00 00 00	 call	 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>
  00091	89 45 e8	 mov	 DWORD PTR tv89[ebp], eax
  00094	eb 07		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00096	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN5@Getcat:
  0009d	8b 4d e8	 mov	 ecx, DWORD PTR tv89[ebp]
  000a0	89 4d dc	 mov	 DWORD PTR $T3[ebp], ecx
  000a3	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  000aa	8b 55 08	 mov	 edx, DWORD PTR __Ppf$[ebp]
  000ad	8b 45 dc	 mov	 eax, DWORD PTR $T3[ebp]
  000b0	89 02		 mov	 DWORD PTR [edx], eax
  000b2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR $T5[ebp]
  000bc	83 e1 01	 and	 ecx, 1
  000bf	74 0d		 je	 SHORT $LN9@Getcat
  000c1	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  000c5	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000c8	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
  000cd	90		 npad	 1
$LN9@Getcat:

; 2783 :         }
; 2784 : 
; 2785 :         return _X_CTYPE;

  000ce	b8 02 00 00 00	 mov	 eax, 2

; 2786 :     }

  000d3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000dd	59		 pop	 ecx
  000de	8b e5		 mov	 esp, ebp
  000e0	5d		 pop	 ebp
  000e1	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 ec	 mov	 eax, DWORD PTR $T4[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z$1:
  0000f	8b 45 f0	 mov	 eax, DWORD PTR $T5[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	0f 84 0c 00 00
	00		 je	 $LN8@Getcat
  0001b	83 65 f0 fe	 and	 DWORD PTR $T5[ebp], -2	; fffffffeH
  0001f	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  00022	e9 00 00 00 00	 jmp	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN8@Getcat:
  00027	c3		 ret	 0
  00028	cc		 int	 3
  00029	cc		 int	 3
  0002a	cc		 int	 3
  0002b	cc		 int	 3
  0002c	cc		 int	 3
__ehhandler$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z:
  0002d	90		 npad	 1
  0002e	90		 npad	 1
  0002f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00033	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00036	8b 4a b0	 mov	 ecx, DWORD PTR [edx-80]
  00039	33 c8		 xor	 ecx, eax
  0003b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00040	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
  00045	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2776 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  00029	50		 push	 eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ??0ctype_base@std@@QAE@I@Z ; std::ctype_base::ctype_base
  00032	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00039	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$ctype@D@std@@6B@

; 2777 :         _Init(_Lobj);

  00042	8b 55 08	 mov	 edx, DWORD PTR __Lobj$[ebp]
  00045	52		 push	 edx
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init
  0004e	90		 npad	 1

; 2778 :     }

  0004f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00056	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00063	59		 pop	 ecx
  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z PROC		; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2744 :         _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2745 :         return do_widen(_First, _Last, _Dest);

  00007	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00012	52		 push	 edx
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0001e	ff d0		 call	 eax

; 2746 :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 0c 00	 ret	 12			; 0000000cH
?widen@?$ctype@D@std@@QBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2739 :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2740 :         return do_widen(_Byte);

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00017	ff d0		 call	 eax

; 2741 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?is@?$ctype@D@std@@QBE_NFD@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv73 = -4						; size = 4
__Maskval$ = 8						; size = 2
__Ch$ = 12						; size = 1
?is@?$ctype@D@std@@QBE_NFD@Z PROC			; std::ctype<char>::is, COMDAT
; _this$ = ecx

; 2687 :     bool __CLR_OR_THIS_CALL is(mask _Maskval, _Elem _Ch) const { // test if element fits any mask classifications

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2688 :         return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;

  00009	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00013	0f bf 04 42	 movsx	 eax, WORD PTR [edx+eax*2]
  00017	0f bf 4d 08	 movsx	 ecx, WORD PTR __Maskval$[ebp]
  0001b	23 c1		 and	 eax, ecx
  0001d	74 09		 je	 SHORT $LN3@is
  0001f	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv73[ebp], 1
  00026	eb 07		 jmp	 SHORT $LN4@is
$LN3@is:
  00028	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@is:
  0002f	0f b6 45 fc	 movzx	 eax, BYTE PTR tv73[ebp]

; 2689 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
?is@?$ctype@D@std@@QBE_NFD@Z ENDP			; std::ctype<char>::is
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2435 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00018	90		 npad	 1
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2432 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) noexcept // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2433 :         : locale::facet(_Refs) {}

  00007	8b 45 08	 mov	 eax, DWORD PTR __Refs$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 1292 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1293 :     // check that [_First, _Last) forms an iterator range
; 1294 :     if constexpr (is_pointer_v<_Iter> && is_pointer_v<_Sentinel>) {
; 1295 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1296 :         _STL_VERIFY(_First <= _Last, "transposed pointer range");
; 1297 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1298 :     } else if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1299 :         _Verify_range(_First, _Last);
; 1300 :     }
; 1301 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Ptr0$ = -16						; size = 4
__Facptr$ = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 362  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 363  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Id$[ebp]
  00012	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00015	73 14		 jae	 SHORT $LN6@Getfacet
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	8b 45 08	 mov	 eax, DWORD PTR __Id$[ebp]
  00023	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00026	89 4d f8	 mov	 DWORD PTR tv71[ebp], ecx
  00029	eb 07		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  00032	8b 55 f8	 mov	 edx, DWORD PTR tv71[ebp]
  00035	89 55 f4	 mov	 DWORD PTR __Facptr$[ebp], edx

; 364  :         if (_Facptr || !_Ptr->_Xparent) {

  00038	83 7d f4 00	 cmp	 DWORD PTR __Facptr$[ebp], 0
  0003c	75 0e		 jne	 SHORT $LN3@Getfacet
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00048	85 d2		 test	 edx, edx
  0004a	75 05		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 365  :             return _Facptr; // found facet or not transparent

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Facptr$[ebp]
  0004f	eb 23		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 366  :         }
; 367  : 
; 368  :         // look in current locale
; 369  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  00051	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00056	89 45 f0	 mov	 DWORD PTR __Ptr0$[ebp], eax

; 370  :         if (_Id < _Ptr0->_Facetcount) {

  00059	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0005f	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00062	73 0e		 jae	 SHORT $LN4@Getfacet

; 371  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00064	8b 55 f0	 mov	 edx, DWORD PTR __Ptr0$[ebp]
  00067	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00070	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 372  :         }
; 373  : 
; 374  :         return nullptr; // no entry in current locale

  00072	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 375  :     }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_C_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_C_str@locale@std@@QBEPBDXZ PROC			; std::locale::_C_str, COMDAT
; _this$ = ecx

; 358  :     _Ret_z_ const char* _C_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 359  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 13		 je	 SHORT $LN3@C_str
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	83 c1 18	 add	 ecx, 24			; 00000018H
  0001b	e8 00 00 00 00	 call	 ?c_str@?$_Yarn@D@std@@QBEPBDXZ ; std::_Yarn<char>::c_str
  00020	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00023	eb 07		 jmp	 SHORT $LN4@C_str
$LN3@C_str:
  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN4@C_str:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 360  :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_C_str@locale@std@@QBEPBDXZ ENDP			; std::locale::_C_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv84 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 339  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 36		 je	 SHORT $LN5@locale

; 341  :             delete _Ptr->_Decref();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 12		 mov	 edx, DWORD PTR [edx]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	ff d0		 call	 eax
  00025	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002c	74 13		 je	 SHORT $LN4@locale
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00038	8b 02		 mov	 eax, DWORD PTR [edx]
  0003a	ff d0		 call	 eax
  0003c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0003f	eb 07		 jmp	 SHORT $LN5@locale
$LN4@locale:
  00041	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv84[ebp], 0
$LN5@locale:

; 342  :         }
; 343  :     }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 254  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 255  :         _Ptr->_Incref();

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00021	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00024	ff d2		 call	 edx
  00026	90		 npad	 1

; 256  :     }

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 132  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00018	90		 npad	 1
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 130  :         {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Facet_base@std@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 129  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Initrefs$[ebp]
  0001e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 130  :         {}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 116  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  :             if (_MT_DECR(_Myrefs) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 05		 jne	 SHORT $LN2@Decref

; 118  :                 return this;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	eb 02		 jmp	 SHORT $LN1@Decref
$LN2@Decref:

; 119  :             }
; 120  : 
; 121  :             return nullptr;

  0001c	33 c0		 xor	 eax, eax
$LN1@Decref:

; 122  :         }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 112  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  :             _MT_INCR(_Myrefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 114  :         }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -8						; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :             if (_Id == 0) { // still zero, allocate stamp

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 36		 jne	 SHORT $LN2@operator

; 84   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00011	6a 00		 push	 0
  00013	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  0001b	90		 npad	 1

; 85   :                 if (_Id == 0) {

  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00022	75 1a		 jne	 SHORT $LN3@operator

; 86   :                     _Id = static_cast<size_t>(++_Id_cnt);

  00024	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  0002a	83 c2 01	 add	 edx, 1
  0002d	89 15 00 00 00
	00		 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  0003c	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator:

; 87   :                 }
; 88   :                 _END_LOCK()

  0003e	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00041	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  00046	90		 npad	 1
$LN2@operator:

; 89   :             }
; 90   :             return _Id;

  00047	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]

; 91   :         }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocale
;	COMDAT ??0id@locale@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
??0id@locale@std@@QAE@I@Z PROC				; std::locale::id::id, COMDAT
; _this$ = ecx

; 77   :         __CLR_OR_THIS_CALL id(size_t _Val = 0) : _Id(_Val) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??0id@locale@std@@QAE@I@Z ENDP				; std::locale::id::id
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0e		 je	 SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN2@Tidy:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 212  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Yarn@_W@std@@AAEXXZ ; std::_Yarn<wchar_t>::_Tidy
  0000f	90		 npad	 1

; 183  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	66 89 4a 04	 mov	 WORD PTR [edx+4], cx
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 202  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0e		 je	 SHORT $LN2@Tidy

; 204  : #ifdef _DEBUG
; 205  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 206  : #else
; 207  :             _CSTD free(_Myptr);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN2@Tidy:

; 208  : #endif
; 209  :         }
; 210  : 
; 211  :         _Myptr = nullptr;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 212  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 189  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  :         return _Myptr ? _Myptr : &_Nul;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 0a		 je	 SHORT $LN3@c_str
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  00019	eb 09		 jmp	 SHORT $LN4@c_str
$LN3@c_str:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
$LN4@c_str:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 191  :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 181  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 182  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Yarn@D@std@@AAEXXZ ; std::_Yarn<char>::_Tidy
  0000f	90		 npad	 1

; 183  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 140  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Gettrue@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Gettrue@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Gettrue, COMDAT
; _this$ = ecx

; 322  :     const char* __CLR_OR_THIS_CALL _Gettrue() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 323  :         return "true";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04LOAJBDKD@true@

; 324  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Gettrue@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Gettrue
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Getfalse@_Locinfo@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getfalse@_Locinfo@std@@QBEPBDXZ PROC			; std::_Locinfo::_Getfalse, COMDAT
; _this$ = ecx

; 318  :     const char* __CLR_OR_THIS_CALL _Getfalse() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 319  :         return "false";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_05LAPONLG@false@

; 320  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Getfalse@_Locinfo@std@@QBEPBDXZ ENDP			; std::_Locinfo::_Getfalse
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ PROC		; std::_Locinfo::_Getlconv, COMDAT
; _this$ = ecx

; 284  :     const lconv* __CLR_OR_THIS_CALL _Getlconv() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 285  :         return localeconv();

  00007	e8 00 00 00 00	 call	 _localeconv

; 286  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Getlconv@_Locinfo@std@@QBEPBUlconv@@XZ ENDP		; std::_Locinfo::_Getlconv
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
_TEXT	SEGMENT
$T1 = -96						; size = 44
_this$ = -52						; size = 4
$T2 = -48						; size = 44
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ PROC		; std::_Locinfo::_Getcvt, COMDAT
; _this$ = ecx

; 280  :     _Cvtvec __CLR_OR_THIS_CALL _Getcvt() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	57		 push	 edi
  00012	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx

; 281  :         return ::_Getcvt();

  00015	8d 45 a0	 lea	 eax, DWORD PTR $T1[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 __Getcvt
  0001e	83 c4 04	 add	 esp, 4
  00021	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00026	8b f0		 mov	 esi, eax
  00028	8d 7d d0	 lea	 edi, DWORD PTR $T2[ebp]
  0002b	f3 a5		 rep movsd
  0002d	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00032	8d 75 d0	 lea	 esi, DWORD PTR $T2[ebp]
  00035	8b 7d 08	 mov	 edi, DWORD PTR ___$ReturnUdt$[ebp]
  00038	f3 a5		 rep movsd
  0003a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 282  :     }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00042	33 cd		 xor	 ecx, ebp
  00044	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ ENDP		; std::_Locinfo::_Getcvt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -36						; size = 16
$T2 = -20						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 276  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 277  :         return ::_Getctype();

  00009	8d 45 dc	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	83 c4 04	 add	 esp, 4
  00015	8b 08		 mov	 ecx, DWORD PTR [eax]
  00017	89 4d ec	 mov	 DWORD PTR $T2[ebp], ecx
  0001a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001d	89 55 f0	 mov	 DWORD PTR $T2[ebp+4], edx
  00020	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00023	89 4d f4	 mov	 DWORD PTR $T2[ebp+8], ecx
  00026	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00029	89 55 f8	 mov	 DWORD PTR $T2[ebp+12], edx
  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR $T2[ebp]
  00032	89 08		 mov	 DWORD PTR [eax], ecx
  00034	8b 55 f0	 mov	 edx, DWORD PTR $T2[ebp+4]
  00037	89 50 04	 mov	 DWORD PTR [eax+4], edx
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR $T2[ebp+8]
  0003d	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00040	8b 55 f8	 mov	 edx, DWORD PTR $T2[ebp+12]
  00043	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00046	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 278  :     }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 256  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Locinfo@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 257  :         _Locinfo_dtor(this);

  00026	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  0002f	83 c4 04	 add	 esp, 4

; 258  :     }

  00032	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00038	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0003d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	83 c1 24	 add	 ecx, 36			; 00000024H
  00043	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00048	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0004e	e8 00 00 00 00	 call	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  00053	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00056	83 c1 14	 add	 ecx, 20			; 00000014H
  00059	e8 00 00 00 00	 call	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00064	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00069	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 04	 add	 ecx, 4
  0006f	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00074	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0007c	90		 npad	 1
  0007d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00080	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00087	59		 pop	 ecx
  00088	8b e5		 mov	 esp, ebp
  0008a	5d		 pop	 ebp
  0008b	c3		 ret	 0
  0008c	cc		 int	 3
  0008d	cc		 int	 3
  0008e	cc		 int	 3
  0008f	cc		 int	 3
  00090	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Locinfo@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Locinfo@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_Locinfo@std@@QAE@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 232  :         : _Lock(_LOCK_LOCALE)

  00026	6a 00		 push	 0
  00028	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit
  00030	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 234  :     {

  00037	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  00042	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00046	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0004c	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  00051	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  00055	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	83 c1 14	 add	 ecx, 20			; 00000014H
  0005b	e8 00 00 00 00	 call	 ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  00060	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  00064	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0006a	e8 00 00 00 00	 call	 ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  0006f	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00073	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 24	 add	 ecx, 36			; 00000024H
  00079	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  0007e	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00082	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00085	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00088	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  0008d	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6

; 235  :         if (_Pch) {

  00091	83 7d 08 00	 cmp	 DWORD PTR __Pch$[ebp], 0
  00095	74 12		 je	 SHORT $LN2@Locinfo

; 236  :             _Locinfo_ctor(this, _Pch);

  00097	8b 45 08	 mov	 eax, DWORD PTR __Pch$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009e	51		 push	 ecx
  0009f	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  000a4	83 c4 08	 add	 esp, 8

; 237  :             return;

  000a7	eb 0b		 jmp	 SHORT $LN1@Locinfo
$LN2@Locinfo:

; 238  :         }
; 239  : 
; 240  :         _Xruntime_error("bad locale name");

  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  000ae	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
  000b3	90		 npad	 1
$LN1@Locinfo:

; 241  :     }

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
  000be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000c8	59		 pop	 ecx
  000c9	8b e5		 mov	 esp, ebp
  000cb	5d		 pop	 ebp
  000cc	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$1:
  00008	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000b	83 c1 04	 add	 ecx, 4
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$2:
  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00019	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$3:
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 14	 add	 ecx, 20			; 00000014H
  00024	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$4:
  00029	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e9 00 00 00 00	 jmp	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$5:
  00034	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 24	 add	 ecx, 36			; 00000024H
  0003a	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
__unwindfunclet$??0_Locinfo@std@@QAE@PBD@Z$6:
  0003f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00045	e9 00 00 00 00	 jmp	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	cc		 int	 3
  0004b	cc		 int	 3
  0004c	cc		 int	 3
  0004d	cc		 int	 3
  0004e	cc		 int	 3
__ehhandler$??0_Locinfo@std@@QAE@PBD@Z:
  0004f	90		 npad	 1
  00050	90		 npad	 1
  00051	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00055	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00058	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  0005b	33 c8		 xor	 ecx, eax
  0005d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00062	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_Locinfo@std@@QAE@PBD@Z
  00067	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
; Function compile flags: /Odtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 04		 push	 4
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 25   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 62   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 63   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
  0001c	90		 npad	 1
$LN1@Throw_bad_:

; 64   : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_cast@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 153  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :         : exception("bad cast", 1)

  00007	6a 01		 push	 1
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast@
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 153  :     {

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 154  :     }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 667  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 668  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 669  :     return _Static._Storage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 670  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iostream_error_category2@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category2@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category2@std@@UAE@XZ PROC		; std::_Iostream_error_category2::~_Iostream_error_category2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1_Iostream_error_category2@std@@UAE@XZ ENDP		; std::_Iostream_error_category2::~_Iostream_error_category2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__Iostream_error_length$1 = -12				; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 555  :     _NODISCARD string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0

; 556  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

  00010	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  00014	75 26		 jne	 SHORT $LN2@message

; 557  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 558  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

  00016	c7 45 f4 15 00
	00 00		 mov	 DWORD PTR __Iostream_error_length$1[ebp], 21 ; 00000015H

; 559  :             return string{_Iostream_error, _Iostream_error_length};

  0001d	6a 15		 push	 21			; 00000015H
  0001f	68 00 00 00 00	 push	 OFFSET ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0002f	83 c8 01	 or	 eax, 1
  00032	89 45 fc	 mov	 DWORD PTR $T2[ebp], eax
  00035	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00038	eb 23		 jmp	 SHORT $LN3@message

; 560  :         } else {

  0003a	eb 21		 jmp	 SHORT $LN3@message
$LN2@message:

; 561  :             return _Syserror_map(_Errcode);

  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00051	8b 55 fc	 mov	 edx, DWORD PTR $T2[ebp]
  00054	83 ca 01	 or	 edx, 1
  00057	89 55 fc	 mov	 DWORD PTR $T2[ebp], edx
  0005a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 562  :         }
; 563  :     }

  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 551  :     _NODISCARD const char* name() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 552  :         return "iostream";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 553  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1system_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0_System_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_System_error@std@@UAE@XZ
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T2 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 490  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0002b	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  0002e	50		 push	 eax
  0002f	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00032	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0003e	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00041	51		 push	 ecx
  00042	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp+4]
  00045	52		 push	 edx
  00046	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  00052	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00059	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0005c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00061	90		 npad	 1
  00062	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
  0006b	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00071	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00078	59		 pop	 ecx
  00079	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0007c	33 cd		 xor	 ecx, ebp
  0007e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0system_error@std@@QAE@Verror_code@1@PBD@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0system_error@std@@QAE@Verror_code@1@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0system_error@std@@QAE@Verror_code@1@PBD@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_System_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
  0001c	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00022	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00025	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00028	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0002b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1runtime_error@std@@UAE@XZ
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T2 = -56						; size = 4
tv137 = -52						; size = 4
tv135 = -48						; size = 4
_this$ = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 475  :     _System_error(error_code _Errcode, const string& _Message)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx

; 476  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  0002b	83 ec 18	 sub	 esp, 24			; 00000018H
  0002e	8b cc		 mov	 ecx, esp
  00030	89 65 c8	 mov	 DWORD PTR $T2[ebp], esp
  00033	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0003f	51		 push	 ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  00043	52		 push	 edx
  00044	8d 45 d8	 lea	 eax, DWORD PTR $T3[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  0004d	83 c4 24	 add	 esp, 36			; 00000024H
  00050	89 45 d0	 mov	 DWORD PTR tv135[ebp], eax
  00053	8b 4d d0	 mov	 ecx, DWORD PTR tv135[ebp]
  00056	89 4d cc	 mov	 DWORD PTR tv137[ebp], ecx
  00059	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00060	8b 55 cc	 mov	 edx, DWORD PTR tv137[ebp]
  00063	52		 push	 edx
  00064	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  0006c	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00073	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00076	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0007b	90		 npad	 1
  0007c	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_System_error@std@@6B@
  00085	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  0008b	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp+4]
  0008e	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00091	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  00094	8b 45 d4	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0009a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a1	59		 pop	 ecx
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a5	33 cd		 xor	 ecx, ebp
  000a7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ac	8b e5		 mov	 esp, ebp
  000ae	5d		 pop	 ebp
  000af	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$1:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
tv84 = -52						; size = 4
tv79 = -48						; size = 4
$T2 = -44						; size = 4
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 463  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 28	 sub	 esp, 40			; 00000028H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0001e	50		 push	 eax
  0001f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00022	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00028	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 464  :         if (!_Message.empty()) {

  00036	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00039	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  0003e	0f b6 c0	 movzx	 eax, al
  00041	85 c0		 test	 eax, eax
  00043	75 0e		 jne	 SHORT $LN2@Makestr

; 465  :             _Message.append(": ");

  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  0004a	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0004d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00052	90		 npad	 1
$LN2@Makestr:

; 466  :         }
; 467  : 
; 468  :         _Message.append(_Errcode.message());

  00053	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00056	51		 push	 ecx
  00057	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  0005a	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  0005f	89 45 d0	 mov	 DWORD PTR tv79[ebp], eax
  00062	8b 55 d0	 mov	 edx, DWORD PTR tv79[ebp]
  00065	89 55 cc	 mov	 DWORD PTR tv84[ebp], edx
  00068	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0006c	8b 45 cc	 mov	 eax, DWORD PTR tv84[ebp]
  0006f	50		 push	 eax
  00070	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00073	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00078	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0007c	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0007f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00084	90		 npad	 1

; 469  :         return _Message;

  00085	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00088	51		 push	 ecx
  00089	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0008c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00091	8b 55 d4	 mov	 edx, DWORD PTR $T2[ebp]
  00094	83 ca 01	 or	 edx, 1
  00097	89 55 d4	 mov	 DWORD PTR $T2[ebp], edx
  0009a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a1	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  000a4	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000a9	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 470  :     }

  000ac	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000af	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000b6	59		 pop	 ecx
  000b7	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ba	33 cd		 xor	 ecx, ebp
  000bc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$0:
  00000	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z$1:
  00008	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a d4	 mov	 ecx, DWORD PTR [edx-44]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ec$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 429  : _EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 430  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());

  00003	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ec$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00010	e8 00 00 00 00	 call	 ??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 431  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
tv78 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 304  :     _NODISCARD_FRIEND bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 305  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00005	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00008	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0000d	50		 push	 eax
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00011	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  00016	8b c8		 mov	 ecx, eax
  00018	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 1f		 je	 SHORT $LN3@operator
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00027	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  0002c	8b f0		 mov	 esi, eax
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00031	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00036	3b f0		 cmp	 esi, eax
  00038	75 09		 jne	 SHORT $LN3@operator
  0003a	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv78[ebp], 1
  00041	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@operator:
  0004a	0f b6 45 fc	 movzx	 eax, BYTE PTR tv78[ebp]

; 306  :     }

  0004e	5e		 pop	 esi
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 291  :     _NODISCARD const error_category& category() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  :         return *_Mycat;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 293  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 287  :     _NODISCARD int value() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 288  :         return _Myval;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 289  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 262  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 206  :     _NODISCARD string message() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 207  :         return category().message(value());

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  00018	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00023	50		 push	 eax
  00024	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00027	50		 push	 eax
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  0002b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00030	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00033	ff d0		 call	 eax
  00035	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00038	83 c9 01	 or	 ecx, 1
  0003b	89 4d f4	 mov	 DWORD PTR $T1[ebp], ecx
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 208  :     }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 200  :     _NODISCARD const error_category& category() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 201  :         return *_Mycat;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 202  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 196  :     _NODISCARD int value() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 197  :         return _Myval;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 198  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 171  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\type_traits
;	COMDAT ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>, COMDAT

; 2496 : _NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2497 :     return __builtin_bit_cast(_To, _Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 2498 : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 99   :     _NODISCARD bool operator==(const error_category& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _M_CEE_PURE
; 101  :         return _Addr == _Right._Addr;
; 102  : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

  0000a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	83 c0 04	 add	 eax, 4
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
  00016	83 c4 04	 add	 esp, 4
  00019	8b f0		 mov	 esi, eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
  00027	83 c4 04	 add	 esp, 4
  0002a	3b f0		 cmp	 esi, eax
  0002c	75 09		 jne	 SHORT $LN3@operator
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  0003e	0f b6 45 fc	 movzx	 eax, BYTE PTR tv71[ebp]

; 104  : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 105  :     }

  00042	5e		 pop	 esi
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 416  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 417  :     return *this == _Code.category() && _Code.value() == _Errval;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  0000c	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 16		 je	 SHORT $LN3@equivalent
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  00024	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00029	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  0002c	75 09		 jne	 SHORT $LN3@equivalent
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  0003e	0f b6 45 fc	 movzx	 eax, BYTE PTR tv74[ebp]

; 418  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 412  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 413  :     return default_error_condition(_Errval) == _Cond;

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Cond$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Errval$[ebp]
  00010	51		 push	 ecx
  00011	8d 55 f4	 lea	 edx, DWORD PTR $T1[ebp]
  00014	52		 push	 edx
  00015	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00020	ff d0		 call	 eax
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 ??8std@@YA_NABVerror_condition@0@0@Z ; std::operator==
  00028	83 c4 08	 add	 esp, 8

; 414  : }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 407  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 408  :     // make error_condition for error code
; 409  :     return error_condition(_Errval, *this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00017	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 410  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 696  : _EXPORT_STD _NODISCARD inline const error_category& iostream_category() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

  00003	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 698  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1runtime_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0000a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1506 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1507 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1508 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1502 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1503 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1504 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3085 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3086 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3087 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 3081 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3082 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 3083 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 3077 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3078 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
  00013	90		 npad	 1

; 3079 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 3055 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3056 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 3057 :         _My_data._Orphan_all();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all
  00017	90		 npad	 1

; 3058 :         if (_My_data._Large_mode_engaged()) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00020	0f b6 c8	 movzx	 ecx, al
  00023	85 c9		 test	 ecx, ecx
  00025	74 2d		 je	 SHORT $LN2@Tidy_deall

; 3059 :             _ASAN_STRING_REMOVE(*this);
; 3060 :             auto& _Al = _Getal();

  00027	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002f	89 45 f0	 mov	 DWORD PTR __Al$1[ebp], eax

; 3061 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

  00032	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00035	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00038	50		 push	 eax
  00039	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	52		 push	 edx
  0003f	8b 45 f0	 mov	 eax, DWORD PTR __Al$1[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00048	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3062 :             _My_data._Bx._Switch_to_buf();

  0004b	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
  00053	90		 npad	 1
$LN2@Tidy_deall:

; 3063 :         }
; 3064 : 
; 3065 :         _My_data._Mysize = 0;

  00054	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00057	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 3066 :         _My_data._Myres  = _Small_string_capacity;

  0005e	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00061	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 3067 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 3068 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00068	c6 45 ff 00	 mov	 BYTE PTR $T2[ebp], 0
  0006c	8d 45 ff	 lea	 eax, DWORD PTR $T2[ebp]
  0006f	50		 push	 eax
  00070	b9 01 00 00 00	 mov	 ecx, 1
  00075	6b d1 00	 imul	 edx, ecx, 0
  00078	03 55 f8	 add	 edx, DWORD PTR __My_data$[ebp]
  0007b	52		 push	 edx
  0007c	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00081	83 c4 08	 add	 esp, 8

; 3069 :     }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 3049 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3050 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 3051 :         _Mypair._Myval2._Mysize = _New_size;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 3052 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00012	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00016	8d 55 ff	 lea	 edx, DWORD PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00022	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0002b	83 c4 08	 add	 esp, 8

; 3053 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 2965 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2966 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0000f	50		 push	 eax
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __Requested$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2967 :     }

  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 2952 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 2953 :         const size_type _Masked = _Requested | _Alloc_mask;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 2954 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __Masked$[ebp]
  00012	3b 4d 10	 cmp	 ecx, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 2955 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 2956 :         }
; 2957 : 
; 2958 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Old$[ebp]
  0001f	d1 ea		 shr	 edx, 1
  00021	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00024	2b c2		 sub	 eax, edx
  00026	39 45 0c	 cmp	 DWORD PTR __Old$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 2959 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 1d		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 2960 :         }
; 2961 : 
; 2962 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Old$[ebp]
  00033	d1 e9		 shr	 ecx, 1
  00035	03 4d 0c	 add	 ecx, DWORD PTR __Old$[ebp]
  00038	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0003b	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  0003e	52		 push	 edx
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 2963 :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2809 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0

; 2810 :         // return [_Off, _Off + _Count) as new string, default-constructing its allocator
; 2811 :         return basic_string{*this, _Off, _Count};

  00010	8d 4d ff	 lea	 ecx, DWORD PTR $T2[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00018	50		 push	 eax
  00019	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0001c	50		 push	 eax
  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00024	52		 push	 edx
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0002d	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00030	83 c8 01	 or	 eax, 1
  00033	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00036	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2812 :     }

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 2468 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2469 :         return _Mypair._Myval2._Mysize == 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@empty:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 2470 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 2369 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2370 :         // determine new length, padding with _Ch elements as needed
; 2371 :         const size_type _Old_size = size();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00011	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 2372 :         if (_New_size <= _Old_size) {

  00014	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00017	3b 45 f8	 cmp	 eax, DWORD PTR __Old_size$[ebp]
  0001a	77 0f		 ja	 SHORT $LN2@resize

; 2373 :             _Eos(_New_size);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
  00028	90		 npad	 1

; 2374 :         } else {

  00029	eb 15		 jmp	 SHORT $LN3@resize
$LN2@resize:

; 2375 :             append(_New_size - _Old_size, _Ch);

  0002b	0f b6 55 0c	 movzx	 edx, BYTE PTR __Ch$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00033	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00036	50		 push	 eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0003f	90		 npad	 1
$LN3@resize:

; 2376 :         }
; 2377 :     }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 08 00	 ret	 8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Storage_max$ = -16					; size = 4
__Alloc_max$ = -12					; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 2360 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2361 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00017	83 c4 04	 add	 esp, 4
  0001a	89 45 f4	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 2362 :         const size_type _Storage_max = // can always store small string

  0001d	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00024	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00027	50		 push	 eax
  00028	8d 4d f4	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00031	83 c4 08	 add	 esp, 8
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 55 f0	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 2363 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 2364 :         return (_STD min)(static_cast<size_type>(_STD _Max_limit<difference_type>()),

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0003c	83 e8 01	 sub	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00042	e8 00 00 00 00	 call	 ??$_Max_limit@H@std@@YAHXZ ; std::_Max_limit<int>
  00047	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
  0004a	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0004d	51		 push	 ecx
  0004e	8d 55 e8	 lea	 edx, DWORD PTR $T1[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00057	83 c4 08	 add	 esp, 8
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]

; 2365 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 2366 :         );
; 2367 :     }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 2356 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2357 :         return _Mypair._Myval2._Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2358 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 2352 :     _NODISCARD _CONSTEXPR20 size_type length() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2353 :         return _Mypair._Myval2._Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 2354 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 2338 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2339 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 2340 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
__Ptr$1 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 2276 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2277 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 2278 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00018	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0001b	73 47		 jae	 SHORT $LN2@push_back

; 2279 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 2280 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00020	83 c1 01	 add	 ecx, 1
  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 2281 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	89 45 f0	 mov	 DWORD PTR __Ptr$1[ebp], eax

; 2282 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00034	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  00037	50		 push	 eax
  00038	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  0003b	03 4d f4	 add	 ecx, DWORD PTR __Old_size$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00044	83 c4 08	 add	 esp, 8

; 2283 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00047	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  0004b	8d 55 ff	 lea	 edx, DWORD PTR $T3[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00052	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  00055	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0005f	83 c4 08	 add	 esp, 8

; 2284 :             return;

  00062	eb 1a		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 2285 :         }
; 2286 : 
; 2287 :         _Reallocate_grow_by(

  00064	33 c0		 xor	 eax, eax
  00066	88 45 fe	 mov	 BYTE PTR $T2[ebp], al
  00069	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  0006d	51		 push	 ecx
  0006e	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  00072	52		 push	 edx
  00073	6a 01		 push	 1
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
  0007d	90		 npad	 1
$LN1@push_back:

; 2288 :             1,
; 2289 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch)
; 2290 :                 _STATIC_CALL_OPERATOR {
; 2291 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2292 :                     _Traits::assign(_New_ptr[_Old_size], _Ch);
; 2293 :                     _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 2294 :                 },
; 2295 :             _Ch);
; 2296 :     }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2262 :     /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2263 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2264 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 2265 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2266 :         return _Mypair._Myval2._Myptr()[_Off];

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0000f	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 2267 :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEABDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 2254 :     _NODISCARD _CONSTEXPR20 reference operator[](const size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2255 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2256 :         _STL_VERIFY(_Off <= _Mypair._Myval2._Mysize, "string subscript out of range");
; 2257 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2258 :         return _Mypair._Myval2._Myptr()[_Off];

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0000f	03 45 08	 add	 eax, DWORD PTR __Off$[ebp]

; 2259 :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 2156 :     _NODISCARD _CONSTEXPR20 iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2157 :         return iterator(

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ; std::_Refancy<char *,0>
  00022	83 c4 04	 add	 esp, 4
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0002b	50		 push	 eax
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002f	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
  00034	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2158 :             _Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
; 2159 :             _STD addressof(_Mypair._Myval2));
; 2160 :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 2148 :     _NODISCARD _CONSTEXPR20 iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2149 :         return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), _STD addressof(_Mypair._Myval2));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Refancy@PAD$0A@@std@@YAPADPAD@Z ; std::_Refancy<char *,0>
  00022	83 c4 04	 add	 esp, 4
  00025	50		 push	 eax
  00026	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00029	e8 00 00 00 00	 call	 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2150 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1856 :     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1857 :         _Mypair._Myval2._Check_offset(_Off);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1858 :         _Eos(_Off);

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00016	51		 push	 ecx
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 1859 :         return *this;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1860 :     }

  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c2 04 00	 ret	 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -20					; size = 4
__Insert_at$2 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T3 = -1						; size = 1
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1771 :         const size_type _Off, _CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1772 :         // insert _Count * _Ch at _Off
; 1773 :         _Mypair._Myval2._Check_offset(_Off);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 1774 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0001b	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 1775 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  0001e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00024	2b 4d f4	 sub	 ecx, DWORD PTR __Old_size$[ebp]
  00027	39 4d 0c	 cmp	 DWORD PTR __Count$[ebp], ecx
  0002a	77 57		 ja	 SHORT $LN2@insert

; 1776 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1777 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  0002c	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  0002f	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 1778 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00038	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00040	89 45 ec	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 1779 :             _Elem* const _Insert_at = _Old_ptr + _Off;

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  00046	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  00049	89 4d f0	 mov	 DWORD PTR __Insert_at$2[ebp], ecx

; 1780 :             _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  0004c	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  0004f	2b 55 08	 sub	 edx, DWORD PTR __Off$[ebp]
  00052	83 c2 01	 add	 edx, 1
  00055	52		 push	 edx
  00056	8b 45 f0	 mov	 eax, DWORD PTR __Insert_at$2[ebp]
  00059	50		 push	 eax
  0005a	8b 4d f0	 mov	 ecx, DWORD PTR __Insert_at$2[ebp]
  0005d	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1781 :             _Traits::assign(_Insert_at, _Count, _Ch); // fill hole

  00069	0f b6 55 10	 movzx	 edx, BYTE PTR __Ch$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f0	 mov	 ecx, DWORD PTR __Insert_at$2[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1782 :             return *this;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00081	eb 23		 jmp	 SHORT $LN1@insert
$LN2@insert:

; 1783 :         }
; 1784 : 
; 1785 :         return _Reallocate_grow_by(

  00083	33 d2		 xor	 edx, edx
  00085	88 55 ff	 mov	 BYTE PTR $T3[ebp], dl
  00088	0f b6 45 10	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  00094	52		 push	 edx
  00095	0f b6 45 ff	 movzx	 eax, BYTE PTR $T3[ebp]
  00099	50		 push	 eax
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009d	51		 push	 ecx
  0009e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_6607a66f2a10a1261ff9db96cba1015b>@@IID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_6607a66f2a10a1261ff9db96cba1015b>,unsigned int,unsigned int,char>
$LN1@insert:

; 1786 :             _Count,
; 1787 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
; 1788 :                 const size_type _Count, const _Elem _Ch) _STATIC_CALL_OPERATOR {
; 1789 :                 _Traits::copy(_New_ptr, _Old_ptr, _Off);
; 1790 :                 _Traits::assign(_New_ptr + _Off, _Count, _Ch);
; 1791 :                 _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 1792 :             },
; 1793 :             _Off, _Count, _Ch);
; 1794 :     }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c2 0c 00	 ret	 12			; 0000000cH
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1524 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1525 :         // append _Count * _Ch
; 1526 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 1527 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 4e		 ja	 SHORT $LN2@append

; 1528 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1529 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1530 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 1531 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00037	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00043	03 55 f4	 add	 edx, DWORD PTR __Old_size$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1532 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004f	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00053	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00056	50		 push	 eax
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0005a	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  0005d	03 4d f0	 add	 ecx, DWORD PTR __Old_ptr$1[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00066	83 c4 08	 add	 esp, 8

; 1533 :             return *this;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	eb 1f		 jmp	 SHORT $LN1@append
$LN2@append:

; 1534 :         }
; 1535 : 
; 1536 :         return _Reallocate_grow_by(

  0006e	33 d2		 xor	 edx, edx
  00070	88 55 fe	 mov	 BYTE PTR $T2[ebp], dl
  00073	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00077	50		 push	 eax
  00078	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0007b	51		 push	 ecx
  0007c	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  00080	52		 push	 edx
  00081	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN1@append:

; 1537 :             _Count,
; 1538 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 1539 :                 const _Elem _Ch) _STATIC_CALL_OPERATOR {
; 1540 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1541 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 1542 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1543 :             },
; 1544 :             _Count, _Ch);
; 1545 :     }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1520 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1521 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1522 :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1497 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1498 :         // append [_Ptr, _Ptr + _Count)
; 1499 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 1500 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 4d		 ja	 SHORT $LN2@append

; 1501 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 1502 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 1503 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 1504 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00042	03 55 f4	 add	 edx, DWORD PTR __Old_size$[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1505 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004e	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00052	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00055	50		 push	 eax
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00059	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0005c	03 4d f0	 add	 ecx, DWORD PTR __Old_ptr$1[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00065	83 c4 08	 add	 esp, 8

; 1506 :             return *this;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	eb 1e		 jmp	 SHORT $LN1@append
$LN2@append:

; 1507 :         }
; 1508 : 
; 1509 :         return _Reallocate_grow_by(

  0006d	33 d2		 xor	 edx, edx
  0006f	88 55 fe	 mov	 BYTE PTR $T2[ebp], dl
  00072	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00075	50		 push	 eax
  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00079	51		 push	 ecx
  0007a	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00082	50		 push	 eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 1510 :             _Count,
; 1511 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 1512 :                 const size_type _Count) _STATIC_CALL_OPERATOR {
; 1513 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 1514 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 1515 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 1516 :             },
; 1517 :             _Ptr, _Count);
; 1518 :     }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1469 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1470 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00011	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1471 :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1369 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1370 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0000f	90		 npad	 1

; 1371 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1372 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 1373 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 1374 :         _Mypair._Myval2._Myproxy = nullptr;
; 1375 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 1376 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1377 :     }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00018	90		 npad	 1
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -24					; size = 4
__Right_data_mem$2 = -20				; size = 4
_this$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Right_data$ = -8					; size = 4
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 1245 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 1246 :         // assign by stealing _Right's buffer
; 1247 :         // pre: this != &_Right
; 1248 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 1249 :         // pre: *this owns no memory, iterators orphaned
; 1250 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 1251 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1252 :         auto& _Right_data = _Right._Mypair._Myval2;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 1253 : 
; 1254 : #if !defined(_INSERT_STRING_ANNOTATION)
; 1255 :         if constexpr (_Can_memcpy_val) {
; 1256 : #if _HAS_CXX20
; 1257 :             if (!_STD is_constant_evaluated())
; 1258 : #endif // _HAS_CXX20
; 1259 :             {
; 1260 : #if _ITERATOR_DEBUG_LEVEL != 0
; 1261 :                 if (_Right_data._Large_mode_engaged()) {
; 1262 :                     // take ownership of _Right's iterators along with its buffer
; 1263 :                     _Swap_proxy_and_iterators(_Right);
; 1264 :                 } else {
; 1265 :                     _Right_data._Orphan_all();
; 1266 :                 }
; 1267 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 1268 : 
; 1269 :                 const auto _My_data_mem =

  00015	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 e8	 mov	 DWORD PTR __My_data_mem$1[ebp], eax

; 1270 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 1271 :                 const auto _Right_data_mem =

  00024	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 ec	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax

; 1272 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 1273 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00033	6a 18		 push	 24			; 00000018H
  00035	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data_mem$2[ebp]
  00038	51		 push	 ecx
  00039	8b 55 e8	 mov	 edx, DWORD PTR __My_data_mem$1[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1274 : 
; 1275 :                 _Right_data._Mysize = 0;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 1276 :                 _Right_data._Myres  = _Small_string_capacity;

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00052	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 1277 :                 _Right_data._Activate_SSO_buffer();

  00059	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
  00061	90		 npad	 1

; 1278 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00062	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0
  00066	8d 55 ff	 lea	 edx, DWORD PTR $T4[ebp]
  00069	52		 push	 edx
  0006a	b8 01 00 00 00	 mov	 eax, 1
  0006f	6b c8 00	 imul	 ecx, eax, 0
  00072	03 4d f8	 add	 ecx, DWORD PTR __Right_data$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0007b	83 c4 08	 add	 esp, 8

; 1279 :                 return;

  0007e	e9 a8 00 00 00	 jmp	 $LN1@Take_conte

; 1280 :             }
; 1281 :         }
; 1282 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 1283 : 
; 1284 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0008b	0f b6 d0	 movzx	 edx, al
  0008e	85 d2		 test	 edx, edx
  00090	74 27		 je	 SHORT $LN2@Take_conte

; 1285 :             _Swap_proxy_and_iterators(_Right);

  00092	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	50		 push	 eax
  00096	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00099	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 1286 : 
; 1287 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000a1	51		 push	 ecx
  000a2	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  000a5	52		 push	 edx
  000a6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
  000ab	83 c4 08	 add	 esp, 8

; 1288 :             _Right_data._Bx._Switch_to_buf();

  000ae	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
  000b6	90		 npad	 1

; 1289 :         } else { // copy small string buffer

  000b7	eb 2a		 jmp	 SHORT $LN3@Take_conte
$LN2@Take_conte:

; 1290 :             _Right_data._Orphan_all();

  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000bc	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 1291 : 
; 1292 :             _My_data._Activate_SSO_buffer();

  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000c4	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 1293 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000c9	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  000cc	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000cf	83 c1 01	 add	 ecx, 1
  000d2	51		 push	 ecx
  000d3	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000da	50		 push	 eax
  000db	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Take_conte:

; 1294 :         }
; 1295 : 
; 1296 :         _My_data._Myres  = _Right_data._Myres;

  000e3	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000e6	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000e9	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ec	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1297 :         _My_data._Mysize = _Right_data._Mysize;

  000ef	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000f2	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000f5	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000f8	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 1298 : 
; 1299 :         _Right_data._Mysize = 0;

  000fb	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000fe	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 1300 :         _Right_data._Myres  = _Small_string_capacity;

  00105	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  00108	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 1301 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0010f	c6 45 fe 00	 mov	 BYTE PTR $T3[ebp], 0
  00113	8d 45 fe	 lea	 eax, DWORD PTR $T3[ebp]
  00116	50		 push	 eax
  00117	b9 01 00 00 00	 mov	 ecx, 1
  0011c	6b d1 00	 imul	 edx, ecx, 0
  0011f	03 55 f8	 add	 edx, DWORD PTR __Right_data$[ebp]
  00122	52		 push	 edx
  00123	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00128	83 c4 08	 add	 esp, 8
$LN1@Take_conte:

; 1302 :     }

  0012b	8b e5		 mov	 esp, ebp
  0012d	5d		 pop	 ebp
  0012e	c2 04 00	 ret	 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1239 :     _CONSTEXPR20 basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = _STD move(_Right))) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1240 :         *this = _STD move(_Right);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=

; 1241 :         return *this;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1242 :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Pocma_val$ = -16					; size = 4
__Al$ = -12						; size = 4
__Right_al$ = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1212 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1213 :         if (this == _STD addressof(_Right)) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
  00012	83 c4 04	 add	 esp, 4
  00015	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00018	75 05		 jne	 SHORT $LN2@operator

; 1214 :             return *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	eb 44		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 1215 :         }
; 1216 : 
; 1217 :         auto& _Al                 = _Getal();

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00027	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 1218 :         auto& _Right_al           = _Right._Getal();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00032	89 45 f8	 mov	 DWORD PTR __Right_al$[ebp], eax

; 1219 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

  00035	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Pocma_val$[ebp], 0

; 1220 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 1221 :             if (_Al != _Right_al) {
; 1222 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 1223 :                 _Mypair._Myval2._Orphan_all();
; 1224 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 1225 :             }
; 1226 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 1227 :             if (_Al != _Right_al) {
; 1228 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 1229 :                 return *this;
; 1230 :             }
; 1231 :         }
; 1232 : 
; 1233 :         _Tidy_deallocate();

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 1234 :         _Pocma(_Al, _Right_al);

  00044	8b 4d f8	 mov	 ecx, DWORD PTR __Right_al$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 f4	 mov	 edx, DWORD PTR __Al$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
  00051	83 c4 08	 add	 esp, 8

; 1235 :         _Take_contents(_Right);

  00054	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00057	50		 push	 eax
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 1236 :         return *this;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 1237 :     }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1009 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
  00017	83 c4 04	 add	 esp, 4
  0001a	50		 push	 eax
  0001b	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  00028	90		 npad	 1

; 1010 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  00029	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 1011 :         _Take_contents(_Right);

  00036	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00039	51		 push	 ecx
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
  00042	90		 npad	 1

; 1012 :     }

  00043	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -1						; size = 1
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 836  :     _CONSTEXPR20 void _Construct_empty() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 837  :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 838  :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0000f	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B
  00014	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 839  : 
; 840  :         // initialize basic_string data members
; 841  :         _My_data._Mysize = 0;

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 842  :         _My_data._Myres  = _Small_string_capacity;

  00026	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00029	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 843  :         _My_data._Activate_SSO_buffer();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
  00038	90		 npad	 1

; 844  : 
; 845  :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 846  :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00039	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0003d	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  00040	50		 push	 eax
  00041	b9 01 00 00 00	 mov	 ecx, 1
  00046	6b d1 00	 imul	 edx, ecx, 0
  00049	03 55 f8	 add	 edx, DWORD PTR __My_data$[ebp]
  0004c	52		 push	 edx
  0004d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00052	83 c4 08	 add	 esp, 8

; 847  :     }

  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 831  :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 832  :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 833  :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00022	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00025	83 c0 01	 add	 eax, 1
  00028	50		 push	 eax
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0002c	51		 push	 ecx
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00030	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
  00035	90		 npad	 1

; 834  :     }

  00036	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00039	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00040	59		 pop	 ecx
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 766  :         : _Mypair(_Zero_then_variadic_args_t{}) { // construct from _Count * _Ch

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	0f b6 45 f3	 movzx	 eax, BYTE PTR $T2[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 767  :         _Construct<_Construct_strategy::_From_char>(_Ch, _Count);

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003f	51		 push	 ecx
  00040	0f b6 55 0c	 movzx	 edx, BYTE PTR __Ch$[ebp]
  00044	52		 push	 edx
  00045	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??$_Construct@$0A@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<0,char>
  0004d	90		 npad	 1

; 768  :     }

  0004e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00055	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00058	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00062	59		 pop	 ecx
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 749  :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	0f b6 45 f3	 movzx	 eax, BYTE PTR $T2[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 750  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003f	51		 push	 ecx
  00040	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  0004e	83 c4 04	 add	 esp, 4
  00051	50		 push	 eax
  00052	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00055	52		 push	 edx
  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
  0005e	90		 npad	 1

; 751  :     }

  0005f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00073	59		 pop	 ecx
  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 736  :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	0f b6 45 f3	 movzx	 eax, BYTE PTR $T2[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00035	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 737  :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00043	52		 push	 edx
  00044	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00047	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
  0004c	90		 npad	 1

; 738  :     }

  0004d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00054	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00061	59		 pop	 ecx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 716  :         : _Mypair(_One_then_variadic_args_t{}, _Al) { // construct from _Right [_Roff, _Roff + _Count)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  0002b	50		 push	 eax
  0002c	0f b6 4d f3	 movzx	 ecx, BYTE PTR $T2[ebp]
  00030	51		 push	 ecx
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
  00039	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 717  :         _Right._Mypair._Myval2._Check_offset(_Roff);

  00040	8b 55 0c	 mov	 edx, DWORD PTR __Roff$[ebp]
  00043	52		 push	 edx
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00047	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset

; 718  :         _Construct<_Construct_strategy::_From_ptr>(

  0004c	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0004f	50		 push	 eax
  00050	8b 4d 0c	 mov	 ecx, DWORD PTR __Roff$[ebp]
  00053	51		 push	 ecx
  00054	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00057	e8 00 00 00 00	 call	 ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
  0005c	50		 push	 eax
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00060	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00065	03 45 0c	 add	 eax, DWORD PTR __Roff$[ebp]
  00068	50		 push	 eax
  00069	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
  00071	90		 npad	 1

; 719  :             _Right._Mypair._Myval2._Myptr() + _Roff, _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
; 720  :     }

  00072	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00079	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0007f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00086	59		 pop	 ecx
  00087	8b e5		 mov	 esp, ebp
  00089	5d		 pop	 ebp
  0008a	c2 10 00	 ret	 16			; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -14						; size = 1
$T3 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 698  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00030	50		 push	 eax
  00031	8d 45 f3	 lea	 eax, DWORD PTR $T3[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  0003a	83 c4 08	 add	 esp, 8
  0003d	50		 push	 eax
  0003e	0f b6 4d f2	 movzx	 ecx, BYTE PTR $T2[ebp]
  00042	51		 push	 ecx
  00043	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
  0004b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 699  :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00052	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00055	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00058	50		 push	 eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00061	50		 push	 eax
  00062	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	e8 00 00 00 00	 call	 ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
  0006a	90		 npad	 1

; 700  :     }

  0006b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00072	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T2 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 689  :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	0f b6 45 f3	 movzx	 eax, BYTE PTR $T2[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  00035	90		 npad	 1

; 690  :         _Construct_empty();

  00036	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
  0003e	90		 npad	 1

; 691  :     }

  0003f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00045	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0004c	59		 pop	 ecx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
  00051	cc		 int	 3
  00052	cc		 int	 3
  00053	cc		 int	 3
  00054	cc		 int	 3
  00055	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 482  :             _STD _Destroy_in_place(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00010	83 c4 04	 add	 esp, 4

; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00014	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	2b 4d 08	 sub	 ecx, DWORD PTR __Off$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  00015	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00018	52		 push	 edx
  00019	8d 45 0c	 lea	 eax, DWORD PTR __Size$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00022	83 c4 08	 add	 esp, 8
  00025	8b 00		 mov	 eax, DWORD PTR [eax]

; 469  :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 08 00	 ret	 8
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEIII@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 462  :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 463  :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
  0000d	90		 npad	 1
$LN1@Xran:

; 464  :     }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00010	73 06		 jae	 SHORT $LN2@Check_offs

; 451  :             _Xran();

  00012	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00017	90		 npad	 1
$LN2@Check_offs:
$LN1@Check_offs:

; 452  :         }
; 453  :     }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 434  :         return _Myres > _Small_string_capacity;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH
  00010	76 09		 jbe	 SHORT $LN3@Large_mode
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv66[ebp]

; 435  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 425  :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 426  :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 427  :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 428  :         }
; 429  : 
; 430  :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 431  :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 416  :         value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 417  :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 418  :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 419  :         }
; 420  : 
; 421  :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 422  :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 403  : 
; 404  :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 405  :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 406  :     // roundup mask for allocated buffers, [0, 15]
; 407  :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 408  :                                            : sizeof(value_type) <= 2 ? 7
; 409  :                                            : sizeof(value_type) <= 4 ? 3
; 410  :                                            : sizeof(value_type) <= 8 ? 1
; 411  :                                                                      : 0;
; 412  :     // capacity in small mode
; 413  :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 414  : 
; 415  :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 416  :         value_type* _Result = _Bx._Buf;
; 417  :         if (_Large_mode_engaged()) {
; 418  :             _Result = _Unfancy(_Bx._Ptr);
; 419  :         }
; 420  : 
; 421  :         return _Result;
; 422  :     }
; 423  : 
; 424  :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 425  :         const value_type* _Result = _Bx._Buf;
; 426  :         if (_Large_mode_engaged()) {
; 427  :             _Result = _Unfancy(_Bx._Ptr);
; 428  :         }
; 429  : 
; 430  :         return _Result;
; 431  :     }
; 432  : 
; 433  :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 434  :         return _Myres > _Small_string_capacity;
; 435  :     }
; 436  : 
; 437  :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 438  :         // start the lifetime of the array elements
; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 442  :                 _Bx._Buf[_Idx] = value_type();
; 443  :             }
; 444  :         }
; 445  : #endif // _HAS_CXX20
; 446  :     }
; 447  : 
; 448  :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 449  :         // checks whether _Off is in the bounds of [0, size()]
; 450  :         if (_Mysize < _Off) {
; 451  :             _Xran();
; 452  :         }
; 453  :     }
; 454  : 
; 455  :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 456  :         // checks whether _Off is in the bounds of [0, size())
; 457  :         if (_Mysize <= _Off) {
; 458  :             _Xran();
; 459  :         }
; 460  :     }
; 461  : 
; 462  :     [[noreturn]] static void _Xran() {
; 463  :         _Xout_of_range("invalid string position");
; 464  :     }
; 465  : 
; 466  :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 467  :         // trims _Size to the longest it can be assuming a string at/after _Off
; 468  :         return (_STD min)(_Size, _Mysize - _Off);
; 469  :     }
; 470  : 
; 471  :     union _Bxty { // storage for small buffer or pointer to larger one
; 472  :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 473  :         // renaming `_String_val` (and fixing the visualizer).
; 474  :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 475  :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 476  : 
; 477  :         value_type _Buf[_BUF_SIZE];
; 478  :         pointer _Ptr;
; 479  :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 480  : 
; 481  :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 482  :             _STD _Destroy_in_place(_Ptr);
; 483  : 
; 484  : #if _HAS_CXX20
; 485  :             // start the lifetime of the array elements
; 486  :             if (_STD is_constant_evaluated()) {
; 487  :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 488  :                     _Buf[_Idx] = value_type();
; 489  :                 }
; 490  :             }
; 491  : #endif // _HAS_CXX20
; 492  :         }
; 493  :     };
; 494  :     _Bxty _Bx;
; 495  : 
; 496  :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 497  :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 498  :     size_type _Mysize = 0; // current length of string (size)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 499  :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 402  :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 717  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 718  :         return _Al;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 719  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 713  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 714  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	83 c8 ff	 or	 eax, -1

; 715  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 952  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 953  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 954  :         return static_cast<_Ty*>(_STD _Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits>
  00019	83 c4 04	 add	 esp, 4

; 955  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 946  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 947  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 948  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 949  :         _STD _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07@std@@YAXPAXI@Z ; std::_Deallocate<8>
  00014	83 c4 08	 add	 esp, 8

; 950  :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 938  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 516  : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 517  :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
  0000d	90		 npad	 1
$LN1@Xlen_strin:

; 518  : }

  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1417 :     _CONSTEXPR20 void _Release() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1414 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 1155 :     _CONSTEXPR20 void _Adopt(const void*) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1150 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1149 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1148 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 169  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 170  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 171  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	83 c1 23	 add	 ecx, 35			; 00000023H
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00011	89 0a		 mov	 DWORD PTR [edx], ecx

; 172  : 
; 173  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d f4	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 174  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	ba 04 00 00 00	 mov	 edx, 4
  00020	6b c2 ff	 imul	 eax, edx, -1
  00023	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00026	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00029	89 55 f8	 mov	 DWORD PTR __Ptr_container$[ebp], edx

; 175  : 
; 176  :     // If the following asserts, it likely means that we are performing
; 177  :     // an aligned delete on memory coming from an unaligned allocation.
; 178  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 179  : 
; 180  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 181  :     // in range [_Min_back_shift, _Non_user_size]
; 182  : #ifdef _DEBUG
; 183  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 184  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 185  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002c	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 186  : #endif // ^^^ !defined(_DEBUG) ^^^
; 187  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00033	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003b	89 4d fc	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 188  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003e	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00042	72 08		 jb	 SHORT $LN8@Adjust_man
  00044	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00048	77 02		 ja	 SHORT $LN8@Adjust_man
  0004a	eb 0a		 jmp	 SHORT $LN6@Adjust_man
$LN8@Adjust_man:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00051	90		 npad	 1
  00052	33 d2		 xor	 edx, edx
  00054	75 f6		 jne	 SHORT $LN8@Adjust_man
$LN6@Adjust_man:
  00056	33 c0		 xor	 eax, eax
  00058	75 e4		 jne	 SHORT $LN4@Adjust_man

; 189  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0005a	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005d	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00060	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Adjust_man:

; 190  : }

  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 100  :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 101  :         return ::operator new(_Bytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4

; 102  :     }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 74   : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 75   :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
  0001c	90		 npad	 1
$LN1@Throw_bad_:

; 76   : }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 450  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 451  :         return static_cast<int_type>(EOF);

  00003	83 c8 ff	 or	 eax, -1

; 452  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 442  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 443  :         return _Left == _Right;

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Right$[ebp]
  0000a	75 09		 jne	 SHORT $LN3@eq_int_typ
  0000c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00013	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  0001c	0f b6 45 fc	 movzx	 eax, BYTE PTR tv65[ebp]

; 444  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 438  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  :         return static_cast<unsigned char>(_Ch);

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]

; 440  :     }

  00007	5d		 pop	 ebp
  00008	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z PROC	; std::_Narrow_char_traits<char,int>::to_char_type, COMDAT

; 434  :     _NODISCARD static constexpr _Elem to_char_type(const int_type _Meta) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 435  :         return static_cast<_Elem>(_Meta);

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Meta$[ebp]

; 436  :     }

  00007	5d		 pop	 ebp
  00008	c3		 ret	 0
?to_char_type@?$_Narrow_char_traits@DH@std@@SADH@Z ENDP	; std::_Narrow_char_traits<char,int>::to_char_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 417  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 418  : #if _HAS_CXX20
; 419  :         if (_STD is_constant_evaluated()) {
; 420  :             return _Primary_char_traits::assign(_Left, _Right);
; 421  :         }
; 422  : #endif // _HAS_CXX20
; 423  :         _Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 424  :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 406  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 407  :         // assign _Count * _Ch to [_First, ...)
; 408  : #if _HAS_CXX20
; 409  :         if (_STD is_constant_evaluated()) {
; 410  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 411  :         }
; 412  : #endif // _HAS_CXX20
; 413  : 
; 414  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	0f be 4d 10	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _memset
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 415  :     }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 364  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 365  :         // find length of null-terminated string
; 366  : #if _HAS_CXX17
; 367  : #ifdef __cpp_char8_t
; 368  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 369  : #if _HAS_U8_INTRINSICS
; 370  :             return __builtin_u8strlen(_First);
; 371  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 372  :             return _Primary_char_traits::length(_First);
; 373  : #endif // ^^^ no u8 intrinsics ^^^
; 374  :         } else
; 375  : #endif // defined(__cpp_char8_t)
; 376  :         {
; 377  :             return __builtin_strlen(_First);
; 378  :         }
; 379  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 380  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00003	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _strlen
  0000c	83 c4 04	 add	 esp, 4

; 381  : #endif // ^^^ !_HAS_CXX17 ^^^
; 382  :     }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 74   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 75   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 76   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 77   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 78   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 79   : #if _HAS_CXX20
; 80   :         if (_STD is_constant_evaluated()) {
; 81   :             // dest: [_First1, _First1 + _Count)
; 82   :             // src: [_First2, _First2 + _Count)
; 83   :             // We need to handle overlapping ranges.
; 84   :             // If _First1 is in the src range, we need a backward loop.
; 85   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 86   : 
; 87   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 88   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 89   :             bool _Loop_forward = true;
; 90   : 
; 91   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 92   :                 if (_First1 == _Src) {
; 93   :                     _Loop_forward = false;
; 94   :                     break;
; 95   :                 }
; 96   :             }
; 97   : 
; 98   :             if (_Loop_forward) {
; 99   :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 100  :                     _First1[_Idx] = _First2[_Idx];
; 101  :                 }
; 102  :             } else {
; 103  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 104  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 105  :                 }
; 106  :             }
; 107  : 
; 108  :             return _First1;
; 109  :         }
; 110  : #endif // _HAS_CXX20
; 111  : 
; 112  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 113  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 114  : 
; 115  :         return _First1;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 116  :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\__msvc_string_view.hpp
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 43   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 44   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 45   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 46   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 47   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 48   : #if _HAS_CXX20
; 49   :         if (_STD is_constant_evaluated()) {
; 50   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 51   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 52   :                 _First1[_Idx] = _First2[_Idx];
; 53   :             }
; 54   : 
; 55   :             return _First1;
; 56   :         }
; 57   : #endif // _HAS_CXX20
; 58   : 
; 59   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memcpy
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 60   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 61   : 
; 62   :         return _First1;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 63   :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 144  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 143  :         : bad_alloc("bad array new length")

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 144  :     {

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 145  :     }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	90		 npad	 1
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 133  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 132  :         : exception(_Message, 1)

  00007	6a 01		 push	 1
  00009	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 133  :     {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 134  :     }

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 95   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 96   :         return _Data._What ? _Data._What : "Unknown exception";

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 0b		 je	 SHORT $LN3@what
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  0001b	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 97   :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 91   :         __std_exception_destroy(&_Data);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	83 c4 04	 add	 esp, 4

; 92   :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 73   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 72   :         : _Data()

  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	83 c2 04	 add	 edx, 4
  00018	89 0a		 mov	 DWORD PTR [edx], ecx
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 74   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00027	83 c1 04	 add	 ecx, 4
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	83 c4 08	 add	 esp, 8

; 75   :     }

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 67   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 66   :         : _Data()

  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	83 c2 04	 add	 edx, 4
  00018	89 0a		 mov	 DWORD PTR [edx], ecx
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 68   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00023	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 69   :     }

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -12					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 60   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 59   :         : _Data()

  00012	33 c9		 xor	 ecx, ecx
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	83 c2 04	 add	 edx, 4
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx
  0001c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 61   :         __std_exception_data _InitData = { _Message, true };

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00022	89 45 f4	 mov	 DWORD PTR __InitData$[ebp], eax
  00025	c6 45 f8 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 62   :         __std_exception_copy(&_InitData, &_Data);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	8d 55 f4	 lea	 edx, DWORD PTR __InitData$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ___std_exception_copy
  00039	83 c4 08	 add	 esp, 8

; 63   :     }

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__ArgList$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1823 :         {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1824 :             int _Result;
; 1825 :             va_list _ArgList;
; 1826 :             __crt_va_start(_ArgList, _Format);

  00006	8d 45 14	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00009	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 1827 :             _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  0000c	8b 4d fc	 mov	 ecx, DWORD PTR __ArgList$[ebp]
  0000f	51		 push	 ecx
  00010	6a 00		 push	 0
  00012	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00015	52		 push	 edx
  00016	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00019	50		 push	 eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  0001d	51		 push	 ecx
  0001e	e8 00 00 00 00	 call	 __vsprintf_s_l
  00023	83 c4 14	 add	 esp, 20			; 00000014H
  00026	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 1828 :             __crt_va_end(_ArgList);

  00029	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 1829 :             return _Result;

  00030	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 1830 :         }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
tv73 = -8						; size = 4
__Result$ = -4						; size = 4
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsprintf_s_l PROC					; COMDAT

; 1490 :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1491 :         int const _Result = __stdio_common_vsprintf_s(

  00006	8b 45 18	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00009	50		 push	 eax
  0000a	8b 4d 14	 mov	 ecx, DWORD PTR __Locale$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 55 10	 mov	 edx, DWORD PTR __Format$[ebp]
  00011	52		 push	 edx
  00012	8b 45 0c	 mov	 eax, DWORD PTR __BufferCount$[ebp]
  00015	50		 push	 eax
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Buffer$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	52		 push	 edx
  00023	8b 00		 mov	 eax, DWORD PTR [eax]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ___stdio_common_vsprintf_s
  0002b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0002e	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 1492 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1493 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1494 : 
; 1495 :         return _Result < 0 ? -1 : _Result;

  00031	83 7d fc 00	 cmp	 DWORD PTR __Result$[ebp], 0
  00035	7d 09		 jge	 SHORT $LN3@vsprintf_s
  00037	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv73[ebp], -1
  0003e	eb 06		 jmp	 SHORT $LN4@vsprintf_s
$LN3@vsprintf_s:
  00040	8b 4d fc	 mov	 ecx, DWORD PTR __Result$[ebp]
  00043	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
$LN4@vsprintf_s:
  00046	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]

; 1496 :     }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _frexpl
_TEXT	SEGMENT
__X$ = 8						; size = 8
__Y$ = 16						; size = 4
_frexpl	PROC						; COMDAT

; 871  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 872  :         return frexp((double)_X, _Y);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Y$[ebp]
  00006	50		 push	 eax
  00007	83 ec 08	 sub	 esp, 8
  0000a	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000f	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00014	e8 00 00 00 00	 call	 _frexp
  00019	83 c4 0c	 add	 esp, 12			; 0000000cH

; 873  :     }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
_frexpl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT _fabsl
_TEXT	SEGMENT
__X$ = 8						; size = 8
_fabsl	PROC						; COMDAT

; 850  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 851  :         return fabs((double)_X);

  00003	83 ec 08	 sub	 esp, 8
  00006	f2 0f 10 45 08	 movsd	 xmm0, QWORD PTR __X$[ebp]
  0000b	f2 0f 11 04 24	 movsd	 QWORD PTR [esp], xmm0
  00010	e8 00 00 00 00	 call	 _fabs
  00015	83 c4 08	 add	 esp, 8

; 852  :     }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_fabsl	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT ?fpclassify@@YAHO@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHO@Z PROC				; fpclassify, COMDAT

; 305  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 306  :         return _ldtest(&_X);

  00003	8d 45 08	 lea	 eax, DWORD PTR __X$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 __ldtest
  0000c	83 c4 04	 add	 esp, 4
  0000f	98		 cwde

; 307  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?fpclassify@@YAHO@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\corecrt_math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
__X$ = 8						; size = 8
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 300  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 301  :         return _dtest(&_X);

  00003	8d 45 08	 lea	 eax, DWORD PTR __X$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 __dtest
  0000c	83 c4 04	 add	 esp, 4
  0000f	98		 cwde

; 302  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.41.34120\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 164  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 165  :         (void)_Size;
; 166  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 167  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
